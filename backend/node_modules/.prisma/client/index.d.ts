
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model user
 * 
 */
export type user = $Result.DefaultSelection<Prisma.$userPayload>
/**
 * Model admin
 * 
 */
export type admin = $Result.DefaultSelection<Prisma.$adminPayload>
/**
 * Model department
 * 
 */
export type department = $Result.DefaultSelection<Prisma.$departmentPayload>
/**
 * Model domain
 * 
 */
export type domain = $Result.DefaultSelection<Prisma.$domainPayload>
/**
 * Model departmentdomain
 * 
 */
export type departmentdomain = $Result.DefaultSelection<Prisma.$departmentdomainPayload>
/**
 * Model generaluser
 * 
 */
export type generaluser = $Result.DefaultSelection<Prisma.$generaluserPayload>
/**
 * Model student
 * 
 */
export type student = $Result.DefaultSelection<Prisma.$studentPayload>
/**
 * Model teacher
 * 
 */
export type teacher = $Result.DefaultSelection<Prisma.$teacherPayload>
/**
 * Model reviewer
 * 
 */
export type reviewer = $Result.DefaultSelection<Prisma.$reviewerPayload>
/**
 * Model team
 * 
 */
export type team = $Result.DefaultSelection<Prisma.$teamPayload>
/**
 * Model teammember
 * 
 */
export type teammember = $Result.DefaultSelection<Prisma.$teammemberPayload>
/**
 * Model teamapplication
 * 
 */
export type teamapplication = $Result.DefaultSelection<Prisma.$teamapplicationPayload>
/**
 * Model teamcomment
 * 
 */
export type teamcomment = $Result.DefaultSelection<Prisma.$teamcommentPayload>
/**
 * Model paper
 * 
 */
export type paper = $Result.DefaultSelection<Prisma.$paperPayload>
/**
 * Model proposal
 * 
 */
export type proposal = $Result.DefaultSelection<Prisma.$proposalPayload>
/**
 * Model review
 * 
 */
export type review = $Result.DefaultSelection<Prisma.$reviewPayload>
/**
 * Model reviewerassignment
 * 
 */
export type reviewerassignment = $Result.DefaultSelection<Prisma.$reviewerassignmentPayload>
/**
 * Model userdomain
 * 
 */
export type userdomain = $Result.DefaultSelection<Prisma.$userdomainPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  ADMIN: 'ADMIN',
  TEACHER: 'TEACHER',
  REVIEWER: 'REVIEWER',
  STUDENT: 'STUDENT',
  GENERALUSER: 'GENERALUSER'
};

export type Role = (typeof Role)[keyof typeof Role]


export const TeamStatus: {
  ACTIVE: 'ACTIVE',
  RECRUITING: 'RECRUITING',
  INACTIVE: 'INACTIVE'
};

export type TeamStatus = (typeof TeamStatus)[keyof typeof TeamStatus]


export const TeamVisibility: {
  PUBLIC: 'PUBLIC',
  PRIVATE: 'PRIVATE'
};

export type TeamVisibility = (typeof TeamVisibility)[keyof typeof TeamVisibility]


export const ReviewDecision: {
  ACCEPT: 'ACCEPT',
  REJECT: 'REJECT',
  MINOR_REVISIONS: 'MINOR_REVISIONS',
  MAJOR_REVISIONS: 'MAJOR_REVISIONS'
};

export type ReviewDecision = (typeof ReviewDecision)[keyof typeof ReviewDecision]


export const ApplicationStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type ApplicationStatus = (typeof ApplicationStatus)[keyof typeof ApplicationStatus]


export const TeamRole: {
  LEAD: 'LEAD',
  RESEARCHER: 'RESEARCHER',
  ASSISTANT: 'ASSISTANT'
};

export type TeamRole = (typeof TeamRole)[keyof typeof TeamRole]


export const PaperStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  UNDER_REVIEW: 'UNDER_REVIEW'
};

export type PaperStatus = (typeof PaperStatus)[keyof typeof PaperStatus]


export const ReviewerStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  SUSPENDED: 'SUSPENDED',
  PENDING: 'PENDING'
};

export type ReviewerStatus = (typeof ReviewerStatus)[keyof typeof ReviewerStatus]


export const AssignmentStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  OVERDUE: 'OVERDUE'
};

export type AssignmentStatus = (typeof AssignmentStatus)[keyof typeof AssignmentStatus]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type TeamStatus = $Enums.TeamStatus

export const TeamStatus: typeof $Enums.TeamStatus

export type TeamVisibility = $Enums.TeamVisibility

export const TeamVisibility: typeof $Enums.TeamVisibility

export type ReviewDecision = $Enums.ReviewDecision

export const ReviewDecision: typeof $Enums.ReviewDecision

export type ApplicationStatus = $Enums.ApplicationStatus

export const ApplicationStatus: typeof $Enums.ApplicationStatus

export type TeamRole = $Enums.TeamRole

export const TeamRole: typeof $Enums.TeamRole

export type PaperStatus = $Enums.PaperStatus

export const PaperStatus: typeof $Enums.PaperStatus

export type ReviewerStatus = $Enums.ReviewerStatus

export const ReviewerStatus: typeof $Enums.ReviewerStatus

export type AssignmentStatus = $Enums.AssignmentStatus

export const AssignmentStatus: typeof $Enums.AssignmentStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.adminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.department`: Exposes CRUD operations for the **department** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.department.findMany()
    * ```
    */
  get department(): Prisma.departmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.domain`: Exposes CRUD operations for the **domain** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Domains
    * const domains = await prisma.domain.findMany()
    * ```
    */
  get domain(): Prisma.domainDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.departmentdomain`: Exposes CRUD operations for the **departmentdomain** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departmentdomains
    * const departmentdomains = await prisma.departmentdomain.findMany()
    * ```
    */
  get departmentdomain(): Prisma.departmentdomainDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.generaluser`: Exposes CRUD operations for the **generaluser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Generalusers
    * const generalusers = await prisma.generaluser.findMany()
    * ```
    */
  get generaluser(): Prisma.generaluserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): Prisma.studentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teacher`: Exposes CRUD operations for the **teacher** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teachers
    * const teachers = await prisma.teacher.findMany()
    * ```
    */
  get teacher(): Prisma.teacherDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reviewer`: Exposes CRUD operations for the **reviewer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviewers
    * const reviewers = await prisma.reviewer.findMany()
    * ```
    */
  get reviewer(): Prisma.reviewerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.teamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teammember`: Exposes CRUD operations for the **teammember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teammembers
    * const teammembers = await prisma.teammember.findMany()
    * ```
    */
  get teammember(): Prisma.teammemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teamapplication`: Exposes CRUD operations for the **teamapplication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teamapplications
    * const teamapplications = await prisma.teamapplication.findMany()
    * ```
    */
  get teamapplication(): Prisma.teamapplicationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teamcomment`: Exposes CRUD operations for the **teamcomment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teamcomments
    * const teamcomments = await prisma.teamcomment.findMany()
    * ```
    */
  get teamcomment(): Prisma.teamcommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paper`: Exposes CRUD operations for the **paper** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Papers
    * const papers = await prisma.paper.findMany()
    * ```
    */
  get paper(): Prisma.paperDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.proposal`: Exposes CRUD operations for the **proposal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Proposals
    * const proposals = await prisma.proposal.findMany()
    * ```
    */
  get proposal(): Prisma.proposalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.reviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reviewerassignment`: Exposes CRUD operations for the **reviewerassignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviewerassignments
    * const reviewerassignments = await prisma.reviewerassignment.findMany()
    * ```
    */
  get reviewerassignment(): Prisma.reviewerassignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userdomain`: Exposes CRUD operations for the **userdomain** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Userdomains
    * const userdomains = await prisma.userdomain.findMany()
    * ```
    */
  get userdomain(): Prisma.userdomainDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.13.0
   * Query Engine version: 361e86d0ea4987e9f53a565309b3eed797a6bcbd
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    user: 'user',
    admin: 'admin',
    department: 'department',
    domain: 'domain',
    departmentdomain: 'departmentdomain',
    generaluser: 'generaluser',
    student: 'student',
    teacher: 'teacher',
    reviewer: 'reviewer',
    team: 'team',
    teammember: 'teammember',
    teamapplication: 'teamapplication',
    teamcomment: 'teamcomment',
    paper: 'paper',
    proposal: 'proposal',
    review: 'review',
    reviewerassignment: 'reviewerassignment',
    userdomain: 'userdomain'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "admin" | "department" | "domain" | "departmentdomain" | "generaluser" | "student" | "teacher" | "reviewer" | "team" | "teammember" | "teamapplication" | "teamcomment" | "paper" | "proposal" | "review" | "reviewerassignment" | "userdomain"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      user: {
        payload: Prisma.$userPayload<ExtArgs>
        fields: Prisma.userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findFirst: {
            args: Prisma.userFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findMany: {
            args: Prisma.userFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          create: {
            args: Prisma.userCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          createMany: {
            args: Prisma.userCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.userCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          delete: {
            args: Prisma.userDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          update: {
            args: Prisma.userUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          deleteMany: {
            args: Prisma.userDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.userUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          upsert: {
            args: Prisma.userUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.userGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.userCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      admin: {
        payload: Prisma.$adminPayload<ExtArgs>
        fields: Prisma.adminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.adminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.adminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          findFirst: {
            args: Prisma.adminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.adminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          findMany: {
            args: Prisma.adminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>[]
          }
          create: {
            args: Prisma.adminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          createMany: {
            args: Prisma.adminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.adminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>[]
          }
          delete: {
            args: Prisma.adminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          update: {
            args: Prisma.adminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          deleteMany: {
            args: Prisma.adminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.adminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.adminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>[]
          }
          upsert: {
            args: Prisma.adminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.adminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.adminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      department: {
        payload: Prisma.$departmentPayload<ExtArgs>
        fields: Prisma.departmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.departmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.departmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentPayload>
          }
          findFirst: {
            args: Prisma.departmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.departmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentPayload>
          }
          findMany: {
            args: Prisma.departmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentPayload>[]
          }
          create: {
            args: Prisma.departmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentPayload>
          }
          createMany: {
            args: Prisma.departmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.departmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentPayload>[]
          }
          delete: {
            args: Prisma.departmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentPayload>
          }
          update: {
            args: Prisma.departmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentPayload>
          }
          deleteMany: {
            args: Prisma.departmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.departmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.departmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentPayload>[]
          }
          upsert: {
            args: Prisma.departmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentPayload>
          }
          aggregate: {
            args: Prisma.DepartmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartment>
          }
          groupBy: {
            args: Prisma.departmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.departmentCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentCountAggregateOutputType> | number
          }
        }
      }
      domain: {
        payload: Prisma.$domainPayload<ExtArgs>
        fields: Prisma.domainFieldRefs
        operations: {
          findUnique: {
            args: Prisma.domainFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$domainPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.domainFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$domainPayload>
          }
          findFirst: {
            args: Prisma.domainFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$domainPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.domainFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$domainPayload>
          }
          findMany: {
            args: Prisma.domainFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$domainPayload>[]
          }
          create: {
            args: Prisma.domainCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$domainPayload>
          }
          createMany: {
            args: Prisma.domainCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.domainCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$domainPayload>[]
          }
          delete: {
            args: Prisma.domainDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$domainPayload>
          }
          update: {
            args: Prisma.domainUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$domainPayload>
          }
          deleteMany: {
            args: Prisma.domainDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.domainUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.domainUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$domainPayload>[]
          }
          upsert: {
            args: Prisma.domainUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$domainPayload>
          }
          aggregate: {
            args: Prisma.DomainAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDomain>
          }
          groupBy: {
            args: Prisma.domainGroupByArgs<ExtArgs>
            result: $Utils.Optional<DomainGroupByOutputType>[]
          }
          count: {
            args: Prisma.domainCountArgs<ExtArgs>
            result: $Utils.Optional<DomainCountAggregateOutputType> | number
          }
        }
      }
      departmentdomain: {
        payload: Prisma.$departmentdomainPayload<ExtArgs>
        fields: Prisma.departmentdomainFieldRefs
        operations: {
          findUnique: {
            args: Prisma.departmentdomainFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentdomainPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.departmentdomainFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentdomainPayload>
          }
          findFirst: {
            args: Prisma.departmentdomainFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentdomainPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.departmentdomainFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentdomainPayload>
          }
          findMany: {
            args: Prisma.departmentdomainFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentdomainPayload>[]
          }
          create: {
            args: Prisma.departmentdomainCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentdomainPayload>
          }
          createMany: {
            args: Prisma.departmentdomainCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.departmentdomainCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentdomainPayload>[]
          }
          delete: {
            args: Prisma.departmentdomainDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentdomainPayload>
          }
          update: {
            args: Prisma.departmentdomainUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentdomainPayload>
          }
          deleteMany: {
            args: Prisma.departmentdomainDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.departmentdomainUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.departmentdomainUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentdomainPayload>[]
          }
          upsert: {
            args: Prisma.departmentdomainUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentdomainPayload>
          }
          aggregate: {
            args: Prisma.DepartmentdomainAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartmentdomain>
          }
          groupBy: {
            args: Prisma.departmentdomainGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentdomainGroupByOutputType>[]
          }
          count: {
            args: Prisma.departmentdomainCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentdomainCountAggregateOutputType> | number
          }
        }
      }
      generaluser: {
        payload: Prisma.$generaluserPayload<ExtArgs>
        fields: Prisma.generaluserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.generaluserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$generaluserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.generaluserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$generaluserPayload>
          }
          findFirst: {
            args: Prisma.generaluserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$generaluserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.generaluserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$generaluserPayload>
          }
          findMany: {
            args: Prisma.generaluserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$generaluserPayload>[]
          }
          create: {
            args: Prisma.generaluserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$generaluserPayload>
          }
          createMany: {
            args: Prisma.generaluserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.generaluserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$generaluserPayload>[]
          }
          delete: {
            args: Prisma.generaluserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$generaluserPayload>
          }
          update: {
            args: Prisma.generaluserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$generaluserPayload>
          }
          deleteMany: {
            args: Prisma.generaluserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.generaluserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.generaluserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$generaluserPayload>[]
          }
          upsert: {
            args: Prisma.generaluserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$generaluserPayload>
          }
          aggregate: {
            args: Prisma.GeneraluserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGeneraluser>
          }
          groupBy: {
            args: Prisma.generaluserGroupByArgs<ExtArgs>
            result: $Utils.Optional<GeneraluserGroupByOutputType>[]
          }
          count: {
            args: Prisma.generaluserCountArgs<ExtArgs>
            result: $Utils.Optional<GeneraluserCountAggregateOutputType> | number
          }
        }
      }
      student: {
        payload: Prisma.$studentPayload<ExtArgs>
        fields: Prisma.studentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.studentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.studentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload>
          }
          findFirst: {
            args: Prisma.studentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.studentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload>
          }
          findMany: {
            args: Prisma.studentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload>[]
          }
          create: {
            args: Prisma.studentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload>
          }
          createMany: {
            args: Prisma.studentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.studentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload>[]
          }
          delete: {
            args: Prisma.studentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload>
          }
          update: {
            args: Prisma.studentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload>
          }
          deleteMany: {
            args: Prisma.studentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.studentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.studentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload>[]
          }
          upsert: {
            args: Prisma.studentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload>
          }
          aggregate: {
            args: Prisma.StudentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent>
          }
          groupBy: {
            args: Prisma.studentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentGroupByOutputType>[]
          }
          count: {
            args: Prisma.studentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentCountAggregateOutputType> | number
          }
        }
      }
      teacher: {
        payload: Prisma.$teacherPayload<ExtArgs>
        fields: Prisma.teacherFieldRefs
        operations: {
          findUnique: {
            args: Prisma.teacherFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teacherPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.teacherFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teacherPayload>
          }
          findFirst: {
            args: Prisma.teacherFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teacherPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.teacherFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teacherPayload>
          }
          findMany: {
            args: Prisma.teacherFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teacherPayload>[]
          }
          create: {
            args: Prisma.teacherCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teacherPayload>
          }
          createMany: {
            args: Prisma.teacherCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.teacherCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teacherPayload>[]
          }
          delete: {
            args: Prisma.teacherDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teacherPayload>
          }
          update: {
            args: Prisma.teacherUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teacherPayload>
          }
          deleteMany: {
            args: Prisma.teacherDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.teacherUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.teacherUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teacherPayload>[]
          }
          upsert: {
            args: Prisma.teacherUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teacherPayload>
          }
          aggregate: {
            args: Prisma.TeacherAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeacher>
          }
          groupBy: {
            args: Prisma.teacherGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeacherGroupByOutputType>[]
          }
          count: {
            args: Prisma.teacherCountArgs<ExtArgs>
            result: $Utils.Optional<TeacherCountAggregateOutputType> | number
          }
        }
      }
      reviewer: {
        payload: Prisma.$reviewerPayload<ExtArgs>
        fields: Prisma.reviewerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.reviewerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.reviewerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewerPayload>
          }
          findFirst: {
            args: Prisma.reviewerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.reviewerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewerPayload>
          }
          findMany: {
            args: Prisma.reviewerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewerPayload>[]
          }
          create: {
            args: Prisma.reviewerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewerPayload>
          }
          createMany: {
            args: Prisma.reviewerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.reviewerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewerPayload>[]
          }
          delete: {
            args: Prisma.reviewerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewerPayload>
          }
          update: {
            args: Prisma.reviewerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewerPayload>
          }
          deleteMany: {
            args: Prisma.reviewerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.reviewerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.reviewerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewerPayload>[]
          }
          upsert: {
            args: Prisma.reviewerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewerPayload>
          }
          aggregate: {
            args: Prisma.ReviewerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReviewer>
          }
          groupBy: {
            args: Prisma.reviewerGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewerGroupByOutputType>[]
          }
          count: {
            args: Prisma.reviewerCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewerCountAggregateOutputType> | number
          }
        }
      }
      team: {
        payload: Prisma.$teamPayload<ExtArgs>
        fields: Prisma.teamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.teamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.teamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamPayload>
          }
          findFirst: {
            args: Prisma.teamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.teamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamPayload>
          }
          findMany: {
            args: Prisma.teamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamPayload>[]
          }
          create: {
            args: Prisma.teamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamPayload>
          }
          createMany: {
            args: Prisma.teamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.teamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamPayload>[]
          }
          delete: {
            args: Prisma.teamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamPayload>
          }
          update: {
            args: Prisma.teamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamPayload>
          }
          deleteMany: {
            args: Prisma.teamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.teamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.teamUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamPayload>[]
          }
          upsert: {
            args: Prisma.teamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamPayload>
          }
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeam>
          }
          groupBy: {
            args: Prisma.teamGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.teamCountArgs<ExtArgs>
            result: $Utils.Optional<TeamCountAggregateOutputType> | number
          }
        }
      }
      teammember: {
        payload: Prisma.$teammemberPayload<ExtArgs>
        fields: Prisma.teammemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.teammemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teammemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.teammemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teammemberPayload>
          }
          findFirst: {
            args: Prisma.teammemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teammemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.teammemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teammemberPayload>
          }
          findMany: {
            args: Prisma.teammemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teammemberPayload>[]
          }
          create: {
            args: Prisma.teammemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teammemberPayload>
          }
          createMany: {
            args: Prisma.teammemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.teammemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teammemberPayload>[]
          }
          delete: {
            args: Prisma.teammemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teammemberPayload>
          }
          update: {
            args: Prisma.teammemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teammemberPayload>
          }
          deleteMany: {
            args: Prisma.teammemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.teammemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.teammemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teammemberPayload>[]
          }
          upsert: {
            args: Prisma.teammemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teammemberPayload>
          }
          aggregate: {
            args: Prisma.TeammemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeammember>
          }
          groupBy: {
            args: Prisma.teammemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeammemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.teammemberCountArgs<ExtArgs>
            result: $Utils.Optional<TeammemberCountAggregateOutputType> | number
          }
        }
      }
      teamapplication: {
        payload: Prisma.$teamapplicationPayload<ExtArgs>
        fields: Prisma.teamapplicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.teamapplicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamapplicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.teamapplicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamapplicationPayload>
          }
          findFirst: {
            args: Prisma.teamapplicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamapplicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.teamapplicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamapplicationPayload>
          }
          findMany: {
            args: Prisma.teamapplicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamapplicationPayload>[]
          }
          create: {
            args: Prisma.teamapplicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamapplicationPayload>
          }
          createMany: {
            args: Prisma.teamapplicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.teamapplicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamapplicationPayload>[]
          }
          delete: {
            args: Prisma.teamapplicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamapplicationPayload>
          }
          update: {
            args: Prisma.teamapplicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamapplicationPayload>
          }
          deleteMany: {
            args: Prisma.teamapplicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.teamapplicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.teamapplicationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamapplicationPayload>[]
          }
          upsert: {
            args: Prisma.teamapplicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamapplicationPayload>
          }
          aggregate: {
            args: Prisma.TeamapplicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeamapplication>
          }
          groupBy: {
            args: Prisma.teamapplicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamapplicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.teamapplicationCountArgs<ExtArgs>
            result: $Utils.Optional<TeamapplicationCountAggregateOutputType> | number
          }
        }
      }
      teamcomment: {
        payload: Prisma.$teamcommentPayload<ExtArgs>
        fields: Prisma.teamcommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.teamcommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamcommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.teamcommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamcommentPayload>
          }
          findFirst: {
            args: Prisma.teamcommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamcommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.teamcommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamcommentPayload>
          }
          findMany: {
            args: Prisma.teamcommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamcommentPayload>[]
          }
          create: {
            args: Prisma.teamcommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamcommentPayload>
          }
          createMany: {
            args: Prisma.teamcommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.teamcommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamcommentPayload>[]
          }
          delete: {
            args: Prisma.teamcommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamcommentPayload>
          }
          update: {
            args: Prisma.teamcommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamcommentPayload>
          }
          deleteMany: {
            args: Prisma.teamcommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.teamcommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.teamcommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamcommentPayload>[]
          }
          upsert: {
            args: Prisma.teamcommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamcommentPayload>
          }
          aggregate: {
            args: Prisma.TeamcommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeamcomment>
          }
          groupBy: {
            args: Prisma.teamcommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamcommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.teamcommentCountArgs<ExtArgs>
            result: $Utils.Optional<TeamcommentCountAggregateOutputType> | number
          }
        }
      }
      paper: {
        payload: Prisma.$paperPayload<ExtArgs>
        fields: Prisma.paperFieldRefs
        operations: {
          findUnique: {
            args: Prisma.paperFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paperPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.paperFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paperPayload>
          }
          findFirst: {
            args: Prisma.paperFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paperPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.paperFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paperPayload>
          }
          findMany: {
            args: Prisma.paperFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paperPayload>[]
          }
          create: {
            args: Prisma.paperCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paperPayload>
          }
          createMany: {
            args: Prisma.paperCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.paperCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paperPayload>[]
          }
          delete: {
            args: Prisma.paperDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paperPayload>
          }
          update: {
            args: Prisma.paperUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paperPayload>
          }
          deleteMany: {
            args: Prisma.paperDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.paperUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.paperUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paperPayload>[]
          }
          upsert: {
            args: Prisma.paperUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paperPayload>
          }
          aggregate: {
            args: Prisma.PaperAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaper>
          }
          groupBy: {
            args: Prisma.paperGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaperGroupByOutputType>[]
          }
          count: {
            args: Prisma.paperCountArgs<ExtArgs>
            result: $Utils.Optional<PaperCountAggregateOutputType> | number
          }
        }
      }
      proposal: {
        payload: Prisma.$proposalPayload<ExtArgs>
        fields: Prisma.proposalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.proposalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proposalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.proposalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proposalPayload>
          }
          findFirst: {
            args: Prisma.proposalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proposalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.proposalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proposalPayload>
          }
          findMany: {
            args: Prisma.proposalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proposalPayload>[]
          }
          create: {
            args: Prisma.proposalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proposalPayload>
          }
          createMany: {
            args: Prisma.proposalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.proposalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proposalPayload>[]
          }
          delete: {
            args: Prisma.proposalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proposalPayload>
          }
          update: {
            args: Prisma.proposalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proposalPayload>
          }
          deleteMany: {
            args: Prisma.proposalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.proposalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.proposalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proposalPayload>[]
          }
          upsert: {
            args: Prisma.proposalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proposalPayload>
          }
          aggregate: {
            args: Prisma.ProposalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProposal>
          }
          groupBy: {
            args: Prisma.proposalGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProposalGroupByOutputType>[]
          }
          count: {
            args: Prisma.proposalCountArgs<ExtArgs>
            result: $Utils.Optional<ProposalCountAggregateOutputType> | number
          }
        }
      }
      review: {
        payload: Prisma.$reviewPayload<ExtArgs>
        fields: Prisma.reviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.reviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.reviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewPayload>
          }
          findFirst: {
            args: Prisma.reviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.reviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewPayload>
          }
          findMany: {
            args: Prisma.reviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewPayload>[]
          }
          create: {
            args: Prisma.reviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewPayload>
          }
          createMany: {
            args: Prisma.reviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.reviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewPayload>[]
          }
          delete: {
            args: Prisma.reviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewPayload>
          }
          update: {
            args: Prisma.reviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewPayload>
          }
          deleteMany: {
            args: Prisma.reviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.reviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.reviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewPayload>[]
          }
          upsert: {
            args: Prisma.reviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.reviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.reviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      reviewerassignment: {
        payload: Prisma.$reviewerassignmentPayload<ExtArgs>
        fields: Prisma.reviewerassignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.reviewerassignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewerassignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.reviewerassignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewerassignmentPayload>
          }
          findFirst: {
            args: Prisma.reviewerassignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewerassignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.reviewerassignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewerassignmentPayload>
          }
          findMany: {
            args: Prisma.reviewerassignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewerassignmentPayload>[]
          }
          create: {
            args: Prisma.reviewerassignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewerassignmentPayload>
          }
          createMany: {
            args: Prisma.reviewerassignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.reviewerassignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewerassignmentPayload>[]
          }
          delete: {
            args: Prisma.reviewerassignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewerassignmentPayload>
          }
          update: {
            args: Prisma.reviewerassignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewerassignmentPayload>
          }
          deleteMany: {
            args: Prisma.reviewerassignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.reviewerassignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.reviewerassignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewerassignmentPayload>[]
          }
          upsert: {
            args: Prisma.reviewerassignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewerassignmentPayload>
          }
          aggregate: {
            args: Prisma.ReviewerassignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReviewerassignment>
          }
          groupBy: {
            args: Prisma.reviewerassignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewerassignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.reviewerassignmentCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewerassignmentCountAggregateOutputType> | number
          }
        }
      }
      userdomain: {
        payload: Prisma.$userdomainPayload<ExtArgs>
        fields: Prisma.userdomainFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userdomainFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userdomainPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userdomainFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userdomainPayload>
          }
          findFirst: {
            args: Prisma.userdomainFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userdomainPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userdomainFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userdomainPayload>
          }
          findMany: {
            args: Prisma.userdomainFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userdomainPayload>[]
          }
          create: {
            args: Prisma.userdomainCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userdomainPayload>
          }
          createMany: {
            args: Prisma.userdomainCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.userdomainCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userdomainPayload>[]
          }
          delete: {
            args: Prisma.userdomainDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userdomainPayload>
          }
          update: {
            args: Prisma.userdomainUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userdomainPayload>
          }
          deleteMany: {
            args: Prisma.userdomainDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userdomainUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.userdomainUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userdomainPayload>[]
          }
          upsert: {
            args: Prisma.userdomainUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userdomainPayload>
          }
          aggregate: {
            args: Prisma.UserdomainAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserdomain>
          }
          groupBy: {
            args: Prisma.userdomainGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserdomainGroupByOutputType>[]
          }
          count: {
            args: Prisma.userdomainCountArgs<ExtArgs>
            result: $Utils.Optional<UserdomainCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: userOmit
    admin?: adminOmit
    department?: departmentOmit
    domain?: domainOmit
    departmentdomain?: departmentdomainOmit
    generaluser?: generaluserOmit
    student?: studentOmit
    teacher?: teacherOmit
    reviewer?: reviewerOmit
    team?: teamOmit
    teammember?: teammemberOmit
    teamapplication?: teamapplicationOmit
    teamcomment?: teamcommentOmit
    paper?: paperOmit
    proposal?: proposalOmit
    review?: reviewOmit
    reviewerassignment?: reviewerassignmentOmit
    userdomain?: userdomainOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    admin: number
    generaluser: number
    student: number
    teacher: number
    team: number
    teamcomment: number
    teammember: number
    userdomain: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | UserCountOutputTypeCountAdminArgs
    generaluser?: boolean | UserCountOutputTypeCountGeneraluserArgs
    student?: boolean | UserCountOutputTypeCountStudentArgs
    teacher?: boolean | UserCountOutputTypeCountTeacherArgs
    team?: boolean | UserCountOutputTypeCountTeamArgs
    teamcomment?: boolean | UserCountOutputTypeCountTeamcommentArgs
    teammember?: boolean | UserCountOutputTypeCountTeammemberArgs
    userdomain?: boolean | UserCountOutputTypeCountUserdomainArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: adminWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGeneraluserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: generaluserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStudentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: studentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teacherWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teamWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeamcommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teamcommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeammemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teammemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserdomainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userdomainWhereInput
  }


  /**
   * Count Type DepartmentCountOutputType
   */

  export type DepartmentCountOutputType = {
    departmentdomain: number
    students: number
    teachers: number
  }

  export type DepartmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    departmentdomain?: boolean | DepartmentCountOutputTypeCountDepartmentdomainArgs
    students?: boolean | DepartmentCountOutputTypeCountStudentsArgs
    teachers?: boolean | DepartmentCountOutputTypeCountTeachersArgs
  }

  // Custom InputTypes
  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCountOutputType
     */
    select?: DepartmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountDepartmentdomainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: departmentdomainWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: studentWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountTeachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teacherWhereInput
  }


  /**
   * Count Type DomainCountOutputType
   */

  export type DomainCountOutputType = {
    departmentdomain: number
    team: number
    userdomain: number
  }

  export type DomainCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    departmentdomain?: boolean | DomainCountOutputTypeCountDepartmentdomainArgs
    team?: boolean | DomainCountOutputTypeCountTeamArgs
    userdomain?: boolean | DomainCountOutputTypeCountUserdomainArgs
  }

  // Custom InputTypes
  /**
   * DomainCountOutputType without action
   */
  export type DomainCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainCountOutputType
     */
    select?: DomainCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DomainCountOutputType without action
   */
  export type DomainCountOutputTypeCountDepartmentdomainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: departmentdomainWhereInput
  }

  /**
   * DomainCountOutputType without action
   */
  export type DomainCountOutputTypeCountTeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teamWhereInput
  }

  /**
   * DomainCountOutputType without action
   */
  export type DomainCountOutputTypeCountUserdomainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userdomainWhereInput
  }


  /**
   * Count Type StudentCountOutputType
   */

  export type StudentCountOutputType = {
    teamapplication: number
  }

  export type StudentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teamapplication?: boolean | StudentCountOutputTypeCountTeamapplicationArgs
  }

  // Custom InputTypes
  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCountOutputType
     */
    select?: StudentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountTeamapplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teamapplicationWhereInput
  }


  /**
   * Count Type TeacherCountOutputType
   */

  export type TeacherCountOutputType = {
    paper: number
    proposal: number
  }

  export type TeacherCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paper?: boolean | TeacherCountOutputTypeCountPaperArgs
    proposal?: boolean | TeacherCountOutputTypeCountProposalArgs
  }

  // Custom InputTypes
  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherCountOutputType
     */
    select?: TeacherCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountPaperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paperWhereInput
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountProposalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: proposalWhereInput
  }


  /**
   * Count Type ReviewerCountOutputType
   */

  export type ReviewerCountOutputType = {
    review: number
    reviewerassignment: number
  }

  export type ReviewerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ReviewerCountOutputTypeCountReviewArgs
    reviewerassignment?: boolean | ReviewerCountOutputTypeCountReviewerassignmentArgs
  }

  // Custom InputTypes
  /**
   * ReviewerCountOutputType without action
   */
  export type ReviewerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewerCountOutputType
     */
    select?: ReviewerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReviewerCountOutputType without action
   */
  export type ReviewerCountOutputTypeCountReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reviewWhereInput
  }

  /**
   * ReviewerCountOutputType without action
   */
  export type ReviewerCountOutputTypeCountReviewerassignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reviewerassignmentWhereInput
  }


  /**
   * Count Type TeamCountOutputType
   */

  export type TeamCountOutputType = {
    paper: number
    proposal: number
    teamapplication: number
    teamcomment: number
    teammember: number
  }

  export type TeamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paper?: boolean | TeamCountOutputTypeCountPaperArgs
    proposal?: boolean | TeamCountOutputTypeCountProposalArgs
    teamapplication?: boolean | TeamCountOutputTypeCountTeamapplicationArgs
    teamcomment?: boolean | TeamCountOutputTypeCountTeamcommentArgs
    teammember?: boolean | TeamCountOutputTypeCountTeammemberArgs
  }

  // Custom InputTypes
  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     */
    select?: TeamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountPaperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paperWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountProposalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: proposalWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountTeamapplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teamapplicationWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountTeamcommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teamcommentWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountTeammemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teammemberWhereInput
  }


  /**
   * Count Type PaperCountOutputType
   */

  export type PaperCountOutputType = {
    review: number
    reviewerassignment: number
  }

  export type PaperCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | PaperCountOutputTypeCountReviewArgs
    reviewerassignment?: boolean | PaperCountOutputTypeCountReviewerassignmentArgs
  }

  // Custom InputTypes
  /**
   * PaperCountOutputType without action
   */
  export type PaperCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaperCountOutputType
     */
    select?: PaperCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaperCountOutputType without action
   */
  export type PaperCountOutputTypeCountReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reviewWhereInput
  }

  /**
   * PaperCountOutputType without action
   */
  export type PaperCountOutputTypeCountReviewerassignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reviewerassignmentWhereInput
  }


  /**
   * Count Type ProposalCountOutputType
   */

  export type ProposalCountOutputType = {
    review: number
    reviewerassignment: number
  }

  export type ProposalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ProposalCountOutputTypeCountReviewArgs
    reviewerassignment?: boolean | ProposalCountOutputTypeCountReviewerassignmentArgs
  }

  // Custom InputTypes
  /**
   * ProposalCountOutputType without action
   */
  export type ProposalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalCountOutputType
     */
    select?: ProposalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProposalCountOutputType without action
   */
  export type ProposalCountOutputTypeCountReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reviewWhereInput
  }

  /**
   * ProposalCountOutputType without action
   */
  export type ProposalCountOutputTypeCountReviewerassignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reviewerassignmentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model user
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    user_id: number | null
  }

  export type UserSumAggregateOutputType = {
    user_id: number | null
  }

  export type UserMinAggregateOutputType = {
    user_id: number | null
    name: string | null
    email: string | null
    password: string | null
    profile_image: string | null
    role: $Enums.Role | null
    isVerified: boolean | null
    isMainAdmin: boolean | null
    verifyToken: string | null
    created_at: Date | null
  }

  export type UserMaxAggregateOutputType = {
    user_id: number | null
    name: string | null
    email: string | null
    password: string | null
    profile_image: string | null
    role: $Enums.Role | null
    isVerified: boolean | null
    isMainAdmin: boolean | null
    verifyToken: string | null
    created_at: Date | null
  }

  export type UserCountAggregateOutputType = {
    user_id: number
    name: number
    email: number
    password: number
    profile_image: number
    role: number
    isVerified: number
    isMainAdmin: number
    verifyToken: number
    created_at: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    user_id?: true
  }

  export type UserSumAggregateInputType = {
    user_id?: true
  }

  export type UserMinAggregateInputType = {
    user_id?: true
    name?: true
    email?: true
    password?: true
    profile_image?: true
    role?: true
    isVerified?: true
    isMainAdmin?: true
    verifyToken?: true
    created_at?: true
  }

  export type UserMaxAggregateInputType = {
    user_id?: true
    name?: true
    email?: true
    password?: true
    profile_image?: true
    role?: true
    isVerified?: true
    isMainAdmin?: true
    verifyToken?: true
    created_at?: true
  }

  export type UserCountAggregateInputType = {
    user_id?: true
    name?: true
    email?: true
    password?: true
    profile_image?: true
    role?: true
    isVerified?: true
    isMainAdmin?: true
    verifyToken?: true
    created_at?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
    orderBy?: userOrderByWithAggregationInput | userOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    user_id: number
    name: string | null
    email: string | null
    password: string | null
    profile_image: string | null
    role: $Enums.Role | null
    isVerified: boolean
    isMainAdmin: boolean
    verifyToken: string | null
    created_at: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    profile_image?: boolean
    role?: boolean
    isVerified?: boolean
    isMainAdmin?: boolean
    verifyToken?: boolean
    created_at?: boolean
    admin?: boolean | user$adminArgs<ExtArgs>
    generaluser?: boolean | user$generaluserArgs<ExtArgs>
    student?: boolean | user$studentArgs<ExtArgs>
    teacher?: boolean | user$teacherArgs<ExtArgs>
    team?: boolean | user$teamArgs<ExtArgs>
    teamcomment?: boolean | user$teamcommentArgs<ExtArgs>
    teammember?: boolean | user$teammemberArgs<ExtArgs>
    userdomain?: boolean | user$userdomainArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type userSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    profile_image?: boolean
    role?: boolean
    isVerified?: boolean
    isMainAdmin?: boolean
    verifyToken?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["user"]>

  export type userSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    profile_image?: boolean
    role?: boolean
    isVerified?: boolean
    isMainAdmin?: boolean
    verifyToken?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["user"]>

  export type userSelectScalar = {
    user_id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    profile_image?: boolean
    role?: boolean
    isVerified?: boolean
    isMainAdmin?: boolean
    verifyToken?: boolean
    created_at?: boolean
  }

  export type userOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_id" | "name" | "email" | "password" | "profile_image" | "role" | "isVerified" | "isMainAdmin" | "verifyToken" | "created_at", ExtArgs["result"]["user"]>
  export type userInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | user$adminArgs<ExtArgs>
    generaluser?: boolean | user$generaluserArgs<ExtArgs>
    student?: boolean | user$studentArgs<ExtArgs>
    teacher?: boolean | user$teacherArgs<ExtArgs>
    team?: boolean | user$teamArgs<ExtArgs>
    teamcomment?: boolean | user$teamcommentArgs<ExtArgs>
    teammember?: boolean | user$teammemberArgs<ExtArgs>
    userdomain?: boolean | user$userdomainArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type userIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type userIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user"
    objects: {
      admin: Prisma.$adminPayload<ExtArgs>[]
      generaluser: Prisma.$generaluserPayload<ExtArgs>[]
      student: Prisma.$studentPayload<ExtArgs>[]
      teacher: Prisma.$teacherPayload<ExtArgs>[]
      team: Prisma.$teamPayload<ExtArgs>[]
      teamcomment: Prisma.$teamcommentPayload<ExtArgs>[]
      teammember: Prisma.$teammemberPayload<ExtArgs>[]
      userdomain: Prisma.$userdomainPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: number
      name: string | null
      email: string | null
      password: string | null
      profile_image: string | null
      role: $Enums.Role | null
      isVerified: boolean
      isMainAdmin: boolean
      verifyToken: string | null
      created_at: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type userGetPayload<S extends boolean | null | undefined | userDefaultArgs> = $Result.GetResult<Prisma.$userPayload, S>

  type userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user'], meta: { name: 'user' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userFindUniqueArgs>(args: SelectSubset<T, userFindUniqueArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs>(args: SelectSubset<T, userFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userFindFirstArgs>(args?: SelectSubset<T, userFindFirstArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userFindFirstOrThrowArgs>(args?: SelectSubset<T, userFindFirstOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const userWithUser_idOnly = await prisma.user.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends userFindManyArgs>(args?: SelectSubset<T, userFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends userCreateArgs>(args: SelectSubset<T, userCreateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {userCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userCreateManyArgs>(args?: SelectSubset<T, userCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {userCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `user_id`
     * const userWithUser_idOnly = await prisma.user.createManyAndReturn({
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends userCreateManyAndReturnArgs>(args?: SelectSubset<T, userCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends userDeleteArgs>(args: SelectSubset<T, userDeleteArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userUpdateArgs>(args: SelectSubset<T, userUpdateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userDeleteManyArgs>(args?: SelectSubset<T, userDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userUpdateManyArgs>(args: SelectSubset<T, userUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {userUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `user_id`
     * const userWithUser_idOnly = await prisma.user.updateManyAndReturn({
     *   select: { user_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends userUpdateManyAndReturnArgs>(args: SelectSubset<T, userUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends userUpsertArgs>(args: SelectSubset<T, userUpsertArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userGroupByArgs['orderBy'] }
        : { orderBy?: userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user model
   */
  readonly fields: userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends user$adminArgs<ExtArgs> = {}>(args?: Subset<T, user$adminArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    generaluser<T extends user$generaluserArgs<ExtArgs> = {}>(args?: Subset<T, user$generaluserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$generaluserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    student<T extends user$studentArgs<ExtArgs> = {}>(args?: Subset<T, user$studentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teacher<T extends user$teacherArgs<ExtArgs> = {}>(args?: Subset<T, user$teacherArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teacherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    team<T extends user$teamArgs<ExtArgs> = {}>(args?: Subset<T, user$teamArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teamcomment<T extends user$teamcommentArgs<ExtArgs> = {}>(args?: Subset<T, user$teamcommentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teamcommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teammember<T extends user$teammemberArgs<ExtArgs> = {}>(args?: Subset<T, user$teammemberArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teammemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userdomain<T extends user$userdomainArgs<ExtArgs> = {}>(args?: Subset<T, user$userdomainArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userdomainPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user model
   */
  interface userFieldRefs {
    readonly user_id: FieldRef<"user", 'Int'>
    readonly name: FieldRef<"user", 'String'>
    readonly email: FieldRef<"user", 'String'>
    readonly password: FieldRef<"user", 'String'>
    readonly profile_image: FieldRef<"user", 'String'>
    readonly role: FieldRef<"user", 'Role'>
    readonly isVerified: FieldRef<"user", 'Boolean'>
    readonly isMainAdmin: FieldRef<"user", 'Boolean'>
    readonly verifyToken: FieldRef<"user", 'String'>
    readonly created_at: FieldRef<"user", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user findUnique
   */
  export type userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findFirst
   */
  export type userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findMany
   */
  export type userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user create
   */
  export type userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to create a user.
     */
    data?: XOR<userCreateInput, userUncheckedCreateInput>
  }

  /**
   * user createMany
   */
  export type userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user createManyAndReturn
   */
  export type userCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user update
   */
  export type userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }

  /**
   * user updateMany
   */
  export type userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * user updateManyAndReturn
   */
  export type userUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * user upsert
   */
  export type userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }

  /**
   * user delete
   */
  export type userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }

  /**
   * user deleteMany
   */
  export type userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * user.admin
   */
  export type user$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    where?: adminWhereInput
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    cursor?: adminWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * user.generaluser
   */
  export type user$generaluserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generaluser
     */
    select?: generaluserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the generaluser
     */
    omit?: generaluserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: generaluserInclude<ExtArgs> | null
    where?: generaluserWhereInput
    orderBy?: generaluserOrderByWithRelationInput | generaluserOrderByWithRelationInput[]
    cursor?: generaluserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GeneraluserScalarFieldEnum | GeneraluserScalarFieldEnum[]
  }

  /**
   * user.student
   */
  export type user$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    where?: studentWhereInput
    orderBy?: studentOrderByWithRelationInput | studentOrderByWithRelationInput[]
    cursor?: studentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * user.teacher
   */
  export type user$teacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher
     */
    select?: teacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher
     */
    omit?: teacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacherInclude<ExtArgs> | null
    where?: teacherWhereInput
    orderBy?: teacherOrderByWithRelationInput | teacherOrderByWithRelationInput[]
    cursor?: teacherWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * user.team
   */
  export type user$teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the team
     */
    omit?: teamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamInclude<ExtArgs> | null
    where?: teamWhereInput
    orderBy?: teamOrderByWithRelationInput | teamOrderByWithRelationInput[]
    cursor?: teamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * user.teamcomment
   */
  export type user$teamcommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teamcomment
     */
    select?: teamcommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teamcomment
     */
    omit?: teamcommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamcommentInclude<ExtArgs> | null
    where?: teamcommentWhereInput
    orderBy?: teamcommentOrderByWithRelationInput | teamcommentOrderByWithRelationInput[]
    cursor?: teamcommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamcommentScalarFieldEnum | TeamcommentScalarFieldEnum[]
  }

  /**
   * user.teammember
   */
  export type user$teammemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teammember
     */
    select?: teammemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teammember
     */
    omit?: teammemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teammemberInclude<ExtArgs> | null
    where?: teammemberWhereInput
    orderBy?: teammemberOrderByWithRelationInput | teammemberOrderByWithRelationInput[]
    cursor?: teammemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeammemberScalarFieldEnum | TeammemberScalarFieldEnum[]
  }

  /**
   * user.userdomain
   */
  export type user$userdomainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userdomain
     */
    select?: userdomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userdomain
     */
    omit?: userdomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userdomainInclude<ExtArgs> | null
    where?: userdomainWhereInput
    orderBy?: userdomainOrderByWithRelationInput | userdomainOrderByWithRelationInput[]
    cursor?: userdomainWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserdomainScalarFieldEnum | UserdomainScalarFieldEnum[]
  }

  /**
   * user without action
   */
  export type userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
  }


  /**
   * Model admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminAvgAggregateOutputType = {
    admin_id: number | null
    user_id: number | null
  }

  export type AdminSumAggregateOutputType = {
    admin_id: number | null
    user_id: number | null
  }

  export type AdminMinAggregateOutputType = {
    admin_id: number | null
    user_id: number | null
  }

  export type AdminMaxAggregateOutputType = {
    admin_id: number | null
    user_id: number | null
  }

  export type AdminCountAggregateOutputType = {
    admin_id: number
    user_id: number
    _all: number
  }


  export type AdminAvgAggregateInputType = {
    admin_id?: true
    user_id?: true
  }

  export type AdminSumAggregateInputType = {
    admin_id?: true
    user_id?: true
  }

  export type AdminMinAggregateInputType = {
    admin_id?: true
    user_id?: true
  }

  export type AdminMaxAggregateInputType = {
    admin_id?: true
    user_id?: true
  }

  export type AdminCountAggregateInputType = {
    admin_id?: true
    user_id?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admin to aggregate.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type adminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: adminWhereInput
    orderBy?: adminOrderByWithAggregationInput | adminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: adminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _avg?: AdminAvgAggregateInputType
    _sum?: AdminSumAggregateInputType
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    admin_id: number
    user_id: number | null
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends adminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type adminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    admin_id?: boolean
    user_id?: boolean
    user?: boolean | admin$userArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type adminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    admin_id?: boolean
    user_id?: boolean
    user?: boolean | admin$userArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type adminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    admin_id?: boolean
    user_id?: boolean
    user?: boolean | admin$userArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type adminSelectScalar = {
    admin_id?: boolean
    user_id?: boolean
  }

  export type adminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"admin_id" | "user_id", ExtArgs["result"]["admin"]>
  export type adminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | admin$userArgs<ExtArgs>
  }
  export type adminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | admin$userArgs<ExtArgs>
  }
  export type adminIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | admin$userArgs<ExtArgs>
  }

  export type $adminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "admin"
    objects: {
      user: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      admin_id: number
      user_id: number | null
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type adminGetPayload<S extends boolean | null | undefined | adminDefaultArgs> = $Result.GetResult<Prisma.$adminPayload, S>

  type adminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<adminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface adminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['admin'], meta: { name: 'admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {adminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends adminFindUniqueArgs>(args: SelectSubset<T, adminFindUniqueArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {adminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends adminFindUniqueOrThrowArgs>(args: SelectSubset<T, adminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends adminFindFirstArgs>(args?: SelectSubset<T, adminFindFirstArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends adminFindFirstOrThrowArgs>(args?: SelectSubset<T, adminFindFirstOrThrowArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `admin_id`
     * const adminWithAdmin_idOnly = await prisma.admin.findMany({ select: { admin_id: true } })
     * 
     */
    findMany<T extends adminFindManyArgs>(args?: SelectSubset<T, adminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin.
     * @param {adminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends adminCreateArgs>(args: SelectSubset<T, adminCreateArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admins.
     * @param {adminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends adminCreateManyArgs>(args?: SelectSubset<T, adminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {adminCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `admin_id`
     * const adminWithAdmin_idOnly = await prisma.admin.createManyAndReturn({
     *   select: { admin_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends adminCreateManyAndReturnArgs>(args?: SelectSubset<T, adminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Admin.
     * @param {adminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends adminDeleteArgs>(args: SelectSubset<T, adminDeleteArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin.
     * @param {adminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends adminUpdateArgs>(args: SelectSubset<T, adminUpdateArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admins.
     * @param {adminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends adminDeleteManyArgs>(args?: SelectSubset<T, adminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends adminUpdateManyArgs>(args: SelectSubset<T, adminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins and returns the data updated in the database.
     * @param {adminUpdateManyAndReturnArgs} args - Arguments to update many Admins.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admins and only return the `admin_id`
     * const adminWithAdmin_idOnly = await prisma.admin.updateManyAndReturn({
     *   select: { admin_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends adminUpdateManyAndReturnArgs>(args: SelectSubset<T, adminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Admin.
     * @param {adminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends adminUpsertArgs>(args: SelectSubset<T, adminUpsertArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends adminCountArgs>(
      args?: Subset<T, adminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends adminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: adminGroupByArgs['orderBy'] }
        : { orderBy?: adminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, adminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the admin model
   */
  readonly fields: adminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__adminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends admin$userArgs<ExtArgs> = {}>(args?: Subset<T, admin$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the admin model
   */
  interface adminFieldRefs {
    readonly admin_id: FieldRef<"admin", 'Int'>
    readonly user_id: FieldRef<"admin", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * admin findUnique
   */
  export type adminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where: adminWhereUniqueInput
  }

  /**
   * admin findUniqueOrThrow
   */
  export type adminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where: adminWhereUniqueInput
  }

  /**
   * admin findFirst
   */
  export type adminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admins.
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * admin findFirstOrThrow
   */
  export type adminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admins.
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * admin findMany
   */
  export type adminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admins to fetch.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing admins.
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * admin create
   */
  export type adminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * The data needed to create a admin.
     */
    data?: XOR<adminCreateInput, adminUncheckedCreateInput>
  }

  /**
   * admin createMany
   */
  export type adminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many admins.
     */
    data: adminCreateManyInput | adminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * admin createManyAndReturn
   */
  export type adminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * The data used to create many admins.
     */
    data: adminCreateManyInput | adminCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * admin update
   */
  export type adminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * The data needed to update a admin.
     */
    data: XOR<adminUpdateInput, adminUncheckedUpdateInput>
    /**
     * Choose, which admin to update.
     */
    where: adminWhereUniqueInput
  }

  /**
   * admin updateMany
   */
  export type adminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update admins.
     */
    data: XOR<adminUpdateManyMutationInput, adminUncheckedUpdateManyInput>
    /**
     * Filter which admins to update
     */
    where?: adminWhereInput
    /**
     * Limit how many admins to update.
     */
    limit?: number
  }

  /**
   * admin updateManyAndReturn
   */
  export type adminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * The data used to update admins.
     */
    data: XOR<adminUpdateManyMutationInput, adminUncheckedUpdateManyInput>
    /**
     * Filter which admins to update
     */
    where?: adminWhereInput
    /**
     * Limit how many admins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * admin upsert
   */
  export type adminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * The filter to search for the admin to update in case it exists.
     */
    where: adminWhereUniqueInput
    /**
     * In case the admin found by the `where` argument doesn't exist, create a new admin with this data.
     */
    create: XOR<adminCreateInput, adminUncheckedCreateInput>
    /**
     * In case the admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<adminUpdateInput, adminUncheckedUpdateInput>
  }

  /**
   * admin delete
   */
  export type adminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter which admin to delete.
     */
    where: adminWhereUniqueInput
  }

  /**
   * admin deleteMany
   */
  export type adminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admins to delete
     */
    where?: adminWhereInput
    /**
     * Limit how many admins to delete.
     */
    limit?: number
  }

  /**
   * admin.user
   */
  export type admin$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * admin without action
   */
  export type adminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
  }


  /**
   * Model department
   */

  export type AggregateDepartment = {
    _count: DepartmentCountAggregateOutputType | null
    _avg: DepartmentAvgAggregateOutputType | null
    _sum: DepartmentSumAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  export type DepartmentAvgAggregateOutputType = {
    department_id: number | null
  }

  export type DepartmentSumAggregateOutputType = {
    department_id: number | null
  }

  export type DepartmentMinAggregateOutputType = {
    department_id: number | null
    department_name: string | null
  }

  export type DepartmentMaxAggregateOutputType = {
    department_id: number | null
    department_name: string | null
  }

  export type DepartmentCountAggregateOutputType = {
    department_id: number
    department_name: number
    _all: number
  }


  export type DepartmentAvgAggregateInputType = {
    department_id?: true
  }

  export type DepartmentSumAggregateInputType = {
    department_id?: true
  }

  export type DepartmentMinAggregateInputType = {
    department_id?: true
    department_name?: true
  }

  export type DepartmentMaxAggregateInputType = {
    department_id?: true
    department_name?: true
  }

  export type DepartmentCountAggregateInputType = {
    department_id?: true
    department_name?: true
    _all?: true
  }

  export type DepartmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which department to aggregate.
     */
    where?: departmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of departments to fetch.
     */
    orderBy?: departmentOrderByWithRelationInput | departmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: departmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned departments
    **/
    _count?: true | DepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepartmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepartmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentMaxAggregateInputType
  }

  export type GetDepartmentAggregateType<T extends DepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartment[P]>
      : GetScalarType<T[P], AggregateDepartment[P]>
  }




  export type departmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: departmentWhereInput
    orderBy?: departmentOrderByWithAggregationInput | departmentOrderByWithAggregationInput[]
    by: DepartmentScalarFieldEnum[] | DepartmentScalarFieldEnum
    having?: departmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentCountAggregateInputType | true
    _avg?: DepartmentAvgAggregateInputType
    _sum?: DepartmentSumAggregateInputType
    _min?: DepartmentMinAggregateInputType
    _max?: DepartmentMaxAggregateInputType
  }

  export type DepartmentGroupByOutputType = {
    department_id: number
    department_name: string | null
    _count: DepartmentCountAggregateOutputType | null
    _avg: DepartmentAvgAggregateOutputType | null
    _sum: DepartmentSumAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  type GetDepartmentGroupByPayload<T extends departmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
        }
      >
    >


  export type departmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    department_id?: boolean
    department_name?: boolean
    departmentdomain?: boolean | department$departmentdomainArgs<ExtArgs>
    students?: boolean | department$studentsArgs<ExtArgs>
    teachers?: boolean | department$teachersArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type departmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    department_id?: boolean
    department_name?: boolean
  }, ExtArgs["result"]["department"]>

  export type departmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    department_id?: boolean
    department_name?: boolean
  }, ExtArgs["result"]["department"]>

  export type departmentSelectScalar = {
    department_id?: boolean
    department_name?: boolean
  }

  export type departmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"department_id" | "department_name", ExtArgs["result"]["department"]>
  export type departmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    departmentdomain?: boolean | department$departmentdomainArgs<ExtArgs>
    students?: boolean | department$studentsArgs<ExtArgs>
    teachers?: boolean | department$teachersArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type departmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type departmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $departmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "department"
    objects: {
      departmentdomain: Prisma.$departmentdomainPayload<ExtArgs>[]
      students: Prisma.$studentPayload<ExtArgs>[]
      teachers: Prisma.$teacherPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      department_id: number
      department_name: string | null
    }, ExtArgs["result"]["department"]>
    composites: {}
  }

  type departmentGetPayload<S extends boolean | null | undefined | departmentDefaultArgs> = $Result.GetResult<Prisma.$departmentPayload, S>

  type departmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<departmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepartmentCountAggregateInputType | true
    }

  export interface departmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['department'], meta: { name: 'department' } }
    /**
     * Find zero or one Department that matches the filter.
     * @param {departmentFindUniqueArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends departmentFindUniqueArgs>(args: SelectSubset<T, departmentFindUniqueArgs<ExtArgs>>): Prisma__departmentClient<$Result.GetResult<Prisma.$departmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Department that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {departmentFindUniqueOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends departmentFindUniqueOrThrowArgs>(args: SelectSubset<T, departmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__departmentClient<$Result.GetResult<Prisma.$departmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentFindFirstArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends departmentFindFirstArgs>(args?: SelectSubset<T, departmentFindFirstArgs<ExtArgs>>): Prisma__departmentClient<$Result.GetResult<Prisma.$departmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentFindFirstOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends departmentFindFirstOrThrowArgs>(args?: SelectSubset<T, departmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__departmentClient<$Result.GetResult<Prisma.$departmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.department.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.department.findMany({ take: 10 })
     * 
     * // Only select the `department_id`
     * const departmentWithDepartment_idOnly = await prisma.department.findMany({ select: { department_id: true } })
     * 
     */
    findMany<T extends departmentFindManyArgs>(args?: SelectSubset<T, departmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$departmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Department.
     * @param {departmentCreateArgs} args - Arguments to create a Department.
     * @example
     * // Create one Department
     * const Department = await prisma.department.create({
     *   data: {
     *     // ... data to create a Department
     *   }
     * })
     * 
     */
    create<T extends departmentCreateArgs>(args: SelectSubset<T, departmentCreateArgs<ExtArgs>>): Prisma__departmentClient<$Result.GetResult<Prisma.$departmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Departments.
     * @param {departmentCreateManyArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends departmentCreateManyArgs>(args?: SelectSubset<T, departmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Departments and returns the data saved in the database.
     * @param {departmentCreateManyAndReturnArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Departments and only return the `department_id`
     * const departmentWithDepartment_idOnly = await prisma.department.createManyAndReturn({
     *   select: { department_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends departmentCreateManyAndReturnArgs>(args?: SelectSubset<T, departmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$departmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Department.
     * @param {departmentDeleteArgs} args - Arguments to delete one Department.
     * @example
     * // Delete one Department
     * const Department = await prisma.department.delete({
     *   where: {
     *     // ... filter to delete one Department
     *   }
     * })
     * 
     */
    delete<T extends departmentDeleteArgs>(args: SelectSubset<T, departmentDeleteArgs<ExtArgs>>): Prisma__departmentClient<$Result.GetResult<Prisma.$departmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Department.
     * @param {departmentUpdateArgs} args - Arguments to update one Department.
     * @example
     * // Update one Department
     * const department = await prisma.department.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends departmentUpdateArgs>(args: SelectSubset<T, departmentUpdateArgs<ExtArgs>>): Prisma__departmentClient<$Result.GetResult<Prisma.$departmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Departments.
     * @param {departmentDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.department.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends departmentDeleteManyArgs>(args?: SelectSubset<T, departmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends departmentUpdateManyArgs>(args: SelectSubset<T, departmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments and returns the data updated in the database.
     * @param {departmentUpdateManyAndReturnArgs} args - Arguments to update many Departments.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Departments and only return the `department_id`
     * const departmentWithDepartment_idOnly = await prisma.department.updateManyAndReturn({
     *   select: { department_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends departmentUpdateManyAndReturnArgs>(args: SelectSubset<T, departmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$departmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Department.
     * @param {departmentUpsertArgs} args - Arguments to update or create a Department.
     * @example
     * // Update or create a Department
     * const department = await prisma.department.upsert({
     *   create: {
     *     // ... data to create a Department
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Department we want to update
     *   }
     * })
     */
    upsert<T extends departmentUpsertArgs>(args: SelectSubset<T, departmentUpsertArgs<ExtArgs>>): Prisma__departmentClient<$Result.GetResult<Prisma.$departmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.department.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends departmentCountArgs>(
      args?: Subset<T, departmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentAggregateArgs>(args: Subset<T, DepartmentAggregateArgs>): Prisma.PrismaPromise<GetDepartmentAggregateType<T>>

    /**
     * Group by Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends departmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: departmentGroupByArgs['orderBy'] }
        : { orderBy?: departmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, departmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the department model
   */
  readonly fields: departmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for department.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__departmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    departmentdomain<T extends department$departmentdomainArgs<ExtArgs> = {}>(args?: Subset<T, department$departmentdomainArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$departmentdomainPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    students<T extends department$studentsArgs<ExtArgs> = {}>(args?: Subset<T, department$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teachers<T extends department$teachersArgs<ExtArgs> = {}>(args?: Subset<T, department$teachersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teacherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the department model
   */
  interface departmentFieldRefs {
    readonly department_id: FieldRef<"department", 'Int'>
    readonly department_name: FieldRef<"department", 'String'>
  }
    

  // Custom InputTypes
  /**
   * department findUnique
   */
  export type departmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the department
     */
    omit?: departmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentInclude<ExtArgs> | null
    /**
     * Filter, which department to fetch.
     */
    where: departmentWhereUniqueInput
  }

  /**
   * department findUniqueOrThrow
   */
  export type departmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the department
     */
    omit?: departmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentInclude<ExtArgs> | null
    /**
     * Filter, which department to fetch.
     */
    where: departmentWhereUniqueInput
  }

  /**
   * department findFirst
   */
  export type departmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the department
     */
    omit?: departmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentInclude<ExtArgs> | null
    /**
     * Filter, which department to fetch.
     */
    where?: departmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of departments to fetch.
     */
    orderBy?: departmentOrderByWithRelationInput | departmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for departments.
     */
    cursor?: departmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * department findFirstOrThrow
   */
  export type departmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the department
     */
    omit?: departmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentInclude<ExtArgs> | null
    /**
     * Filter, which department to fetch.
     */
    where?: departmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of departments to fetch.
     */
    orderBy?: departmentOrderByWithRelationInput | departmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for departments.
     */
    cursor?: departmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * department findMany
   */
  export type departmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the department
     */
    omit?: departmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentInclude<ExtArgs> | null
    /**
     * Filter, which departments to fetch.
     */
    where?: departmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of departments to fetch.
     */
    orderBy?: departmentOrderByWithRelationInput | departmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing departments.
     */
    cursor?: departmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` departments.
     */
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * department create
   */
  export type departmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the department
     */
    omit?: departmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentInclude<ExtArgs> | null
    /**
     * The data needed to create a department.
     */
    data?: XOR<departmentCreateInput, departmentUncheckedCreateInput>
  }

  /**
   * department createMany
   */
  export type departmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many departments.
     */
    data: departmentCreateManyInput | departmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * department createManyAndReturn
   */
  export type departmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the department
     */
    omit?: departmentOmit<ExtArgs> | null
    /**
     * The data used to create many departments.
     */
    data: departmentCreateManyInput | departmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * department update
   */
  export type departmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the department
     */
    omit?: departmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentInclude<ExtArgs> | null
    /**
     * The data needed to update a department.
     */
    data: XOR<departmentUpdateInput, departmentUncheckedUpdateInput>
    /**
     * Choose, which department to update.
     */
    where: departmentWhereUniqueInput
  }

  /**
   * department updateMany
   */
  export type departmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update departments.
     */
    data: XOR<departmentUpdateManyMutationInput, departmentUncheckedUpdateManyInput>
    /**
     * Filter which departments to update
     */
    where?: departmentWhereInput
    /**
     * Limit how many departments to update.
     */
    limit?: number
  }

  /**
   * department updateManyAndReturn
   */
  export type departmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the department
     */
    omit?: departmentOmit<ExtArgs> | null
    /**
     * The data used to update departments.
     */
    data: XOR<departmentUpdateManyMutationInput, departmentUncheckedUpdateManyInput>
    /**
     * Filter which departments to update
     */
    where?: departmentWhereInput
    /**
     * Limit how many departments to update.
     */
    limit?: number
  }

  /**
   * department upsert
   */
  export type departmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the department
     */
    omit?: departmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentInclude<ExtArgs> | null
    /**
     * The filter to search for the department to update in case it exists.
     */
    where: departmentWhereUniqueInput
    /**
     * In case the department found by the `where` argument doesn't exist, create a new department with this data.
     */
    create: XOR<departmentCreateInput, departmentUncheckedCreateInput>
    /**
     * In case the department was found with the provided `where` argument, update it with this data.
     */
    update: XOR<departmentUpdateInput, departmentUncheckedUpdateInput>
  }

  /**
   * department delete
   */
  export type departmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the department
     */
    omit?: departmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentInclude<ExtArgs> | null
    /**
     * Filter which department to delete.
     */
    where: departmentWhereUniqueInput
  }

  /**
   * department deleteMany
   */
  export type departmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which departments to delete
     */
    where?: departmentWhereInput
    /**
     * Limit how many departments to delete.
     */
    limit?: number
  }

  /**
   * department.departmentdomain
   */
  export type department$departmentdomainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departmentdomain
     */
    select?: departmentdomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the departmentdomain
     */
    omit?: departmentdomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentdomainInclude<ExtArgs> | null
    where?: departmentdomainWhereInput
    orderBy?: departmentdomainOrderByWithRelationInput | departmentdomainOrderByWithRelationInput[]
    cursor?: departmentdomainWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentdomainScalarFieldEnum | DepartmentdomainScalarFieldEnum[]
  }

  /**
   * department.students
   */
  export type department$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    where?: studentWhereInput
    orderBy?: studentOrderByWithRelationInput | studentOrderByWithRelationInput[]
    cursor?: studentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * department.teachers
   */
  export type department$teachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher
     */
    select?: teacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher
     */
    omit?: teacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacherInclude<ExtArgs> | null
    where?: teacherWhereInput
    orderBy?: teacherOrderByWithRelationInput | teacherOrderByWithRelationInput[]
    cursor?: teacherWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * department without action
   */
  export type departmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the department
     */
    omit?: departmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentInclude<ExtArgs> | null
  }


  /**
   * Model domain
   */

  export type AggregateDomain = {
    _count: DomainCountAggregateOutputType | null
    _avg: DomainAvgAggregateOutputType | null
    _sum: DomainSumAggregateOutputType | null
    _min: DomainMinAggregateOutputType | null
    _max: DomainMaxAggregateOutputType | null
  }

  export type DomainAvgAggregateOutputType = {
    domain_id: number | null
  }

  export type DomainSumAggregateOutputType = {
    domain_id: number | null
  }

  export type DomainMinAggregateOutputType = {
    domain_id: number | null
    domain_name: string | null
  }

  export type DomainMaxAggregateOutputType = {
    domain_id: number | null
    domain_name: string | null
  }

  export type DomainCountAggregateOutputType = {
    domain_id: number
    domain_name: number
    _all: number
  }


  export type DomainAvgAggregateInputType = {
    domain_id?: true
  }

  export type DomainSumAggregateInputType = {
    domain_id?: true
  }

  export type DomainMinAggregateInputType = {
    domain_id?: true
    domain_name?: true
  }

  export type DomainMaxAggregateInputType = {
    domain_id?: true
    domain_name?: true
  }

  export type DomainCountAggregateInputType = {
    domain_id?: true
    domain_name?: true
    _all?: true
  }

  export type DomainAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which domain to aggregate.
     */
    where?: domainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of domains to fetch.
     */
    orderBy?: domainOrderByWithRelationInput | domainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: domainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` domains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` domains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned domains
    **/
    _count?: true | DomainCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DomainAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DomainSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DomainMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DomainMaxAggregateInputType
  }

  export type GetDomainAggregateType<T extends DomainAggregateArgs> = {
        [P in keyof T & keyof AggregateDomain]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDomain[P]>
      : GetScalarType<T[P], AggregateDomain[P]>
  }




  export type domainGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: domainWhereInput
    orderBy?: domainOrderByWithAggregationInput | domainOrderByWithAggregationInput[]
    by: DomainScalarFieldEnum[] | DomainScalarFieldEnum
    having?: domainScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DomainCountAggregateInputType | true
    _avg?: DomainAvgAggregateInputType
    _sum?: DomainSumAggregateInputType
    _min?: DomainMinAggregateInputType
    _max?: DomainMaxAggregateInputType
  }

  export type DomainGroupByOutputType = {
    domain_id: number
    domain_name: string | null
    _count: DomainCountAggregateOutputType | null
    _avg: DomainAvgAggregateOutputType | null
    _sum: DomainSumAggregateOutputType | null
    _min: DomainMinAggregateOutputType | null
    _max: DomainMaxAggregateOutputType | null
  }

  type GetDomainGroupByPayload<T extends domainGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DomainGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DomainGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DomainGroupByOutputType[P]>
            : GetScalarType<T[P], DomainGroupByOutputType[P]>
        }
      >
    >


  export type domainSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    domain_id?: boolean
    domain_name?: boolean
    departmentdomain?: boolean | domain$departmentdomainArgs<ExtArgs>
    team?: boolean | domain$teamArgs<ExtArgs>
    userdomain?: boolean | domain$userdomainArgs<ExtArgs>
    _count?: boolean | DomainCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["domain"]>

  export type domainSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    domain_id?: boolean
    domain_name?: boolean
  }, ExtArgs["result"]["domain"]>

  export type domainSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    domain_id?: boolean
    domain_name?: boolean
  }, ExtArgs["result"]["domain"]>

  export type domainSelectScalar = {
    domain_id?: boolean
    domain_name?: boolean
  }

  export type domainOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"domain_id" | "domain_name", ExtArgs["result"]["domain"]>
  export type domainInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    departmentdomain?: boolean | domain$departmentdomainArgs<ExtArgs>
    team?: boolean | domain$teamArgs<ExtArgs>
    userdomain?: boolean | domain$userdomainArgs<ExtArgs>
    _count?: boolean | DomainCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type domainIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type domainIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $domainPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "domain"
    objects: {
      departmentdomain: Prisma.$departmentdomainPayload<ExtArgs>[]
      team: Prisma.$teamPayload<ExtArgs>[]
      userdomain: Prisma.$userdomainPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      domain_id: number
      domain_name: string | null
    }, ExtArgs["result"]["domain"]>
    composites: {}
  }

  type domainGetPayload<S extends boolean | null | undefined | domainDefaultArgs> = $Result.GetResult<Prisma.$domainPayload, S>

  type domainCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<domainFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DomainCountAggregateInputType | true
    }

  export interface domainDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['domain'], meta: { name: 'domain' } }
    /**
     * Find zero or one Domain that matches the filter.
     * @param {domainFindUniqueArgs} args - Arguments to find a Domain
     * @example
     * // Get one Domain
     * const domain = await prisma.domain.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends domainFindUniqueArgs>(args: SelectSubset<T, domainFindUniqueArgs<ExtArgs>>): Prisma__domainClient<$Result.GetResult<Prisma.$domainPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Domain that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {domainFindUniqueOrThrowArgs} args - Arguments to find a Domain
     * @example
     * // Get one Domain
     * const domain = await prisma.domain.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends domainFindUniqueOrThrowArgs>(args: SelectSubset<T, domainFindUniqueOrThrowArgs<ExtArgs>>): Prisma__domainClient<$Result.GetResult<Prisma.$domainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Domain that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {domainFindFirstArgs} args - Arguments to find a Domain
     * @example
     * // Get one Domain
     * const domain = await prisma.domain.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends domainFindFirstArgs>(args?: SelectSubset<T, domainFindFirstArgs<ExtArgs>>): Prisma__domainClient<$Result.GetResult<Prisma.$domainPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Domain that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {domainFindFirstOrThrowArgs} args - Arguments to find a Domain
     * @example
     * // Get one Domain
     * const domain = await prisma.domain.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends domainFindFirstOrThrowArgs>(args?: SelectSubset<T, domainFindFirstOrThrowArgs<ExtArgs>>): Prisma__domainClient<$Result.GetResult<Prisma.$domainPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Domains that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {domainFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Domains
     * const domains = await prisma.domain.findMany()
     * 
     * // Get first 10 Domains
     * const domains = await prisma.domain.findMany({ take: 10 })
     * 
     * // Only select the `domain_id`
     * const domainWithDomain_idOnly = await prisma.domain.findMany({ select: { domain_id: true } })
     * 
     */
    findMany<T extends domainFindManyArgs>(args?: SelectSubset<T, domainFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$domainPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Domain.
     * @param {domainCreateArgs} args - Arguments to create a Domain.
     * @example
     * // Create one Domain
     * const Domain = await prisma.domain.create({
     *   data: {
     *     // ... data to create a Domain
     *   }
     * })
     * 
     */
    create<T extends domainCreateArgs>(args: SelectSubset<T, domainCreateArgs<ExtArgs>>): Prisma__domainClient<$Result.GetResult<Prisma.$domainPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Domains.
     * @param {domainCreateManyArgs} args - Arguments to create many Domains.
     * @example
     * // Create many Domains
     * const domain = await prisma.domain.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends domainCreateManyArgs>(args?: SelectSubset<T, domainCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Domains and returns the data saved in the database.
     * @param {domainCreateManyAndReturnArgs} args - Arguments to create many Domains.
     * @example
     * // Create many Domains
     * const domain = await prisma.domain.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Domains and only return the `domain_id`
     * const domainWithDomain_idOnly = await prisma.domain.createManyAndReturn({
     *   select: { domain_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends domainCreateManyAndReturnArgs>(args?: SelectSubset<T, domainCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$domainPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Domain.
     * @param {domainDeleteArgs} args - Arguments to delete one Domain.
     * @example
     * // Delete one Domain
     * const Domain = await prisma.domain.delete({
     *   where: {
     *     // ... filter to delete one Domain
     *   }
     * })
     * 
     */
    delete<T extends domainDeleteArgs>(args: SelectSubset<T, domainDeleteArgs<ExtArgs>>): Prisma__domainClient<$Result.GetResult<Prisma.$domainPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Domain.
     * @param {domainUpdateArgs} args - Arguments to update one Domain.
     * @example
     * // Update one Domain
     * const domain = await prisma.domain.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends domainUpdateArgs>(args: SelectSubset<T, domainUpdateArgs<ExtArgs>>): Prisma__domainClient<$Result.GetResult<Prisma.$domainPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Domains.
     * @param {domainDeleteManyArgs} args - Arguments to filter Domains to delete.
     * @example
     * // Delete a few Domains
     * const { count } = await prisma.domain.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends domainDeleteManyArgs>(args?: SelectSubset<T, domainDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Domains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {domainUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Domains
     * const domain = await prisma.domain.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends domainUpdateManyArgs>(args: SelectSubset<T, domainUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Domains and returns the data updated in the database.
     * @param {domainUpdateManyAndReturnArgs} args - Arguments to update many Domains.
     * @example
     * // Update many Domains
     * const domain = await prisma.domain.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Domains and only return the `domain_id`
     * const domainWithDomain_idOnly = await prisma.domain.updateManyAndReturn({
     *   select: { domain_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends domainUpdateManyAndReturnArgs>(args: SelectSubset<T, domainUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$domainPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Domain.
     * @param {domainUpsertArgs} args - Arguments to update or create a Domain.
     * @example
     * // Update or create a Domain
     * const domain = await prisma.domain.upsert({
     *   create: {
     *     // ... data to create a Domain
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Domain we want to update
     *   }
     * })
     */
    upsert<T extends domainUpsertArgs>(args: SelectSubset<T, domainUpsertArgs<ExtArgs>>): Prisma__domainClient<$Result.GetResult<Prisma.$domainPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Domains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {domainCountArgs} args - Arguments to filter Domains to count.
     * @example
     * // Count the number of Domains
     * const count = await prisma.domain.count({
     *   where: {
     *     // ... the filter for the Domains we want to count
     *   }
     * })
    **/
    count<T extends domainCountArgs>(
      args?: Subset<T, domainCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DomainCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Domain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DomainAggregateArgs>(args: Subset<T, DomainAggregateArgs>): Prisma.PrismaPromise<GetDomainAggregateType<T>>

    /**
     * Group by Domain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {domainGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends domainGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: domainGroupByArgs['orderBy'] }
        : { orderBy?: domainGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, domainGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDomainGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the domain model
   */
  readonly fields: domainFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for domain.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__domainClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    departmentdomain<T extends domain$departmentdomainArgs<ExtArgs> = {}>(args?: Subset<T, domain$departmentdomainArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$departmentdomainPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    team<T extends domain$teamArgs<ExtArgs> = {}>(args?: Subset<T, domain$teamArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userdomain<T extends domain$userdomainArgs<ExtArgs> = {}>(args?: Subset<T, domain$userdomainArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userdomainPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the domain model
   */
  interface domainFieldRefs {
    readonly domain_id: FieldRef<"domain", 'Int'>
    readonly domain_name: FieldRef<"domain", 'String'>
  }
    

  // Custom InputTypes
  /**
   * domain findUnique
   */
  export type domainFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the domain
     */
    select?: domainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the domain
     */
    omit?: domainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: domainInclude<ExtArgs> | null
    /**
     * Filter, which domain to fetch.
     */
    where: domainWhereUniqueInput
  }

  /**
   * domain findUniqueOrThrow
   */
  export type domainFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the domain
     */
    select?: domainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the domain
     */
    omit?: domainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: domainInclude<ExtArgs> | null
    /**
     * Filter, which domain to fetch.
     */
    where: domainWhereUniqueInput
  }

  /**
   * domain findFirst
   */
  export type domainFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the domain
     */
    select?: domainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the domain
     */
    omit?: domainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: domainInclude<ExtArgs> | null
    /**
     * Filter, which domain to fetch.
     */
    where?: domainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of domains to fetch.
     */
    orderBy?: domainOrderByWithRelationInput | domainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for domains.
     */
    cursor?: domainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` domains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` domains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of domains.
     */
    distinct?: DomainScalarFieldEnum | DomainScalarFieldEnum[]
  }

  /**
   * domain findFirstOrThrow
   */
  export type domainFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the domain
     */
    select?: domainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the domain
     */
    omit?: domainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: domainInclude<ExtArgs> | null
    /**
     * Filter, which domain to fetch.
     */
    where?: domainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of domains to fetch.
     */
    orderBy?: domainOrderByWithRelationInput | domainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for domains.
     */
    cursor?: domainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` domains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` domains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of domains.
     */
    distinct?: DomainScalarFieldEnum | DomainScalarFieldEnum[]
  }

  /**
   * domain findMany
   */
  export type domainFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the domain
     */
    select?: domainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the domain
     */
    omit?: domainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: domainInclude<ExtArgs> | null
    /**
     * Filter, which domains to fetch.
     */
    where?: domainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of domains to fetch.
     */
    orderBy?: domainOrderByWithRelationInput | domainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing domains.
     */
    cursor?: domainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` domains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` domains.
     */
    skip?: number
    distinct?: DomainScalarFieldEnum | DomainScalarFieldEnum[]
  }

  /**
   * domain create
   */
  export type domainCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the domain
     */
    select?: domainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the domain
     */
    omit?: domainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: domainInclude<ExtArgs> | null
    /**
     * The data needed to create a domain.
     */
    data?: XOR<domainCreateInput, domainUncheckedCreateInput>
  }

  /**
   * domain createMany
   */
  export type domainCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many domains.
     */
    data: domainCreateManyInput | domainCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * domain createManyAndReturn
   */
  export type domainCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the domain
     */
    select?: domainSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the domain
     */
    omit?: domainOmit<ExtArgs> | null
    /**
     * The data used to create many domains.
     */
    data: domainCreateManyInput | domainCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * domain update
   */
  export type domainUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the domain
     */
    select?: domainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the domain
     */
    omit?: domainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: domainInclude<ExtArgs> | null
    /**
     * The data needed to update a domain.
     */
    data: XOR<domainUpdateInput, domainUncheckedUpdateInput>
    /**
     * Choose, which domain to update.
     */
    where: domainWhereUniqueInput
  }

  /**
   * domain updateMany
   */
  export type domainUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update domains.
     */
    data: XOR<domainUpdateManyMutationInput, domainUncheckedUpdateManyInput>
    /**
     * Filter which domains to update
     */
    where?: domainWhereInput
    /**
     * Limit how many domains to update.
     */
    limit?: number
  }

  /**
   * domain updateManyAndReturn
   */
  export type domainUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the domain
     */
    select?: domainSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the domain
     */
    omit?: domainOmit<ExtArgs> | null
    /**
     * The data used to update domains.
     */
    data: XOR<domainUpdateManyMutationInput, domainUncheckedUpdateManyInput>
    /**
     * Filter which domains to update
     */
    where?: domainWhereInput
    /**
     * Limit how many domains to update.
     */
    limit?: number
  }

  /**
   * domain upsert
   */
  export type domainUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the domain
     */
    select?: domainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the domain
     */
    omit?: domainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: domainInclude<ExtArgs> | null
    /**
     * The filter to search for the domain to update in case it exists.
     */
    where: domainWhereUniqueInput
    /**
     * In case the domain found by the `where` argument doesn't exist, create a new domain with this data.
     */
    create: XOR<domainCreateInput, domainUncheckedCreateInput>
    /**
     * In case the domain was found with the provided `where` argument, update it with this data.
     */
    update: XOR<domainUpdateInput, domainUncheckedUpdateInput>
  }

  /**
   * domain delete
   */
  export type domainDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the domain
     */
    select?: domainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the domain
     */
    omit?: domainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: domainInclude<ExtArgs> | null
    /**
     * Filter which domain to delete.
     */
    where: domainWhereUniqueInput
  }

  /**
   * domain deleteMany
   */
  export type domainDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which domains to delete
     */
    where?: domainWhereInput
    /**
     * Limit how many domains to delete.
     */
    limit?: number
  }

  /**
   * domain.departmentdomain
   */
  export type domain$departmentdomainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departmentdomain
     */
    select?: departmentdomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the departmentdomain
     */
    omit?: departmentdomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentdomainInclude<ExtArgs> | null
    where?: departmentdomainWhereInput
    orderBy?: departmentdomainOrderByWithRelationInput | departmentdomainOrderByWithRelationInput[]
    cursor?: departmentdomainWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentdomainScalarFieldEnum | DepartmentdomainScalarFieldEnum[]
  }

  /**
   * domain.team
   */
  export type domain$teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the team
     */
    omit?: teamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamInclude<ExtArgs> | null
    where?: teamWhereInput
    orderBy?: teamOrderByWithRelationInput | teamOrderByWithRelationInput[]
    cursor?: teamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * domain.userdomain
   */
  export type domain$userdomainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userdomain
     */
    select?: userdomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userdomain
     */
    omit?: userdomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userdomainInclude<ExtArgs> | null
    where?: userdomainWhereInput
    orderBy?: userdomainOrderByWithRelationInput | userdomainOrderByWithRelationInput[]
    cursor?: userdomainWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserdomainScalarFieldEnum | UserdomainScalarFieldEnum[]
  }

  /**
   * domain without action
   */
  export type domainDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the domain
     */
    select?: domainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the domain
     */
    omit?: domainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: domainInclude<ExtArgs> | null
  }


  /**
   * Model departmentdomain
   */

  export type AggregateDepartmentdomain = {
    _count: DepartmentdomainCountAggregateOutputType | null
    _avg: DepartmentdomainAvgAggregateOutputType | null
    _sum: DepartmentdomainSumAggregateOutputType | null
    _min: DepartmentdomainMinAggregateOutputType | null
    _max: DepartmentdomainMaxAggregateOutputType | null
  }

  export type DepartmentdomainAvgAggregateOutputType = {
    department_id: number | null
    domain_id: number | null
  }

  export type DepartmentdomainSumAggregateOutputType = {
    department_id: number | null
    domain_id: number | null
  }

  export type DepartmentdomainMinAggregateOutputType = {
    department_id: number | null
    domain_id: number | null
  }

  export type DepartmentdomainMaxAggregateOutputType = {
    department_id: number | null
    domain_id: number | null
  }

  export type DepartmentdomainCountAggregateOutputType = {
    department_id: number
    domain_id: number
    _all: number
  }


  export type DepartmentdomainAvgAggregateInputType = {
    department_id?: true
    domain_id?: true
  }

  export type DepartmentdomainSumAggregateInputType = {
    department_id?: true
    domain_id?: true
  }

  export type DepartmentdomainMinAggregateInputType = {
    department_id?: true
    domain_id?: true
  }

  export type DepartmentdomainMaxAggregateInputType = {
    department_id?: true
    domain_id?: true
  }

  export type DepartmentdomainCountAggregateInputType = {
    department_id?: true
    domain_id?: true
    _all?: true
  }

  export type DepartmentdomainAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which departmentdomain to aggregate.
     */
    where?: departmentdomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of departmentdomains to fetch.
     */
    orderBy?: departmentdomainOrderByWithRelationInput | departmentdomainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: departmentdomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` departmentdomains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` departmentdomains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned departmentdomains
    **/
    _count?: true | DepartmentdomainCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepartmentdomainAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepartmentdomainSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentdomainMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentdomainMaxAggregateInputType
  }

  export type GetDepartmentdomainAggregateType<T extends DepartmentdomainAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartmentdomain]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartmentdomain[P]>
      : GetScalarType<T[P], AggregateDepartmentdomain[P]>
  }




  export type departmentdomainGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: departmentdomainWhereInput
    orderBy?: departmentdomainOrderByWithAggregationInput | departmentdomainOrderByWithAggregationInput[]
    by: DepartmentdomainScalarFieldEnum[] | DepartmentdomainScalarFieldEnum
    having?: departmentdomainScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentdomainCountAggregateInputType | true
    _avg?: DepartmentdomainAvgAggregateInputType
    _sum?: DepartmentdomainSumAggregateInputType
    _min?: DepartmentdomainMinAggregateInputType
    _max?: DepartmentdomainMaxAggregateInputType
  }

  export type DepartmentdomainGroupByOutputType = {
    department_id: number
    domain_id: number
    _count: DepartmentdomainCountAggregateOutputType | null
    _avg: DepartmentdomainAvgAggregateOutputType | null
    _sum: DepartmentdomainSumAggregateOutputType | null
    _min: DepartmentdomainMinAggregateOutputType | null
    _max: DepartmentdomainMaxAggregateOutputType | null
  }

  type GetDepartmentdomainGroupByPayload<T extends departmentdomainGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentdomainGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentdomainGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentdomainGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentdomainGroupByOutputType[P]>
        }
      >
    >


  export type departmentdomainSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    department_id?: boolean
    domain_id?: boolean
    department?: boolean | departmentDefaultArgs<ExtArgs>
    domain?: boolean | domainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["departmentdomain"]>

  export type departmentdomainSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    department_id?: boolean
    domain_id?: boolean
    department?: boolean | departmentDefaultArgs<ExtArgs>
    domain?: boolean | domainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["departmentdomain"]>

  export type departmentdomainSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    department_id?: boolean
    domain_id?: boolean
    department?: boolean | departmentDefaultArgs<ExtArgs>
    domain?: boolean | domainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["departmentdomain"]>

  export type departmentdomainSelectScalar = {
    department_id?: boolean
    domain_id?: boolean
  }

  export type departmentdomainOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"department_id" | "domain_id", ExtArgs["result"]["departmentdomain"]>
  export type departmentdomainInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | departmentDefaultArgs<ExtArgs>
    domain?: boolean | domainDefaultArgs<ExtArgs>
  }
  export type departmentdomainIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | departmentDefaultArgs<ExtArgs>
    domain?: boolean | domainDefaultArgs<ExtArgs>
  }
  export type departmentdomainIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | departmentDefaultArgs<ExtArgs>
    domain?: boolean | domainDefaultArgs<ExtArgs>
  }

  export type $departmentdomainPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "departmentdomain"
    objects: {
      department: Prisma.$departmentPayload<ExtArgs>
      domain: Prisma.$domainPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      department_id: number
      domain_id: number
    }, ExtArgs["result"]["departmentdomain"]>
    composites: {}
  }

  type departmentdomainGetPayload<S extends boolean | null | undefined | departmentdomainDefaultArgs> = $Result.GetResult<Prisma.$departmentdomainPayload, S>

  type departmentdomainCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<departmentdomainFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepartmentdomainCountAggregateInputType | true
    }

  export interface departmentdomainDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['departmentdomain'], meta: { name: 'departmentdomain' } }
    /**
     * Find zero or one Departmentdomain that matches the filter.
     * @param {departmentdomainFindUniqueArgs} args - Arguments to find a Departmentdomain
     * @example
     * // Get one Departmentdomain
     * const departmentdomain = await prisma.departmentdomain.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends departmentdomainFindUniqueArgs>(args: SelectSubset<T, departmentdomainFindUniqueArgs<ExtArgs>>): Prisma__departmentdomainClient<$Result.GetResult<Prisma.$departmentdomainPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Departmentdomain that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {departmentdomainFindUniqueOrThrowArgs} args - Arguments to find a Departmentdomain
     * @example
     * // Get one Departmentdomain
     * const departmentdomain = await prisma.departmentdomain.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends departmentdomainFindUniqueOrThrowArgs>(args: SelectSubset<T, departmentdomainFindUniqueOrThrowArgs<ExtArgs>>): Prisma__departmentdomainClient<$Result.GetResult<Prisma.$departmentdomainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Departmentdomain that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentdomainFindFirstArgs} args - Arguments to find a Departmentdomain
     * @example
     * // Get one Departmentdomain
     * const departmentdomain = await prisma.departmentdomain.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends departmentdomainFindFirstArgs>(args?: SelectSubset<T, departmentdomainFindFirstArgs<ExtArgs>>): Prisma__departmentdomainClient<$Result.GetResult<Prisma.$departmentdomainPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Departmentdomain that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentdomainFindFirstOrThrowArgs} args - Arguments to find a Departmentdomain
     * @example
     * // Get one Departmentdomain
     * const departmentdomain = await prisma.departmentdomain.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends departmentdomainFindFirstOrThrowArgs>(args?: SelectSubset<T, departmentdomainFindFirstOrThrowArgs<ExtArgs>>): Prisma__departmentdomainClient<$Result.GetResult<Prisma.$departmentdomainPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Departmentdomains that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentdomainFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departmentdomains
     * const departmentdomains = await prisma.departmentdomain.findMany()
     * 
     * // Get first 10 Departmentdomains
     * const departmentdomains = await prisma.departmentdomain.findMany({ take: 10 })
     * 
     * // Only select the `department_id`
     * const departmentdomainWithDepartment_idOnly = await prisma.departmentdomain.findMany({ select: { department_id: true } })
     * 
     */
    findMany<T extends departmentdomainFindManyArgs>(args?: SelectSubset<T, departmentdomainFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$departmentdomainPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Departmentdomain.
     * @param {departmentdomainCreateArgs} args - Arguments to create a Departmentdomain.
     * @example
     * // Create one Departmentdomain
     * const Departmentdomain = await prisma.departmentdomain.create({
     *   data: {
     *     // ... data to create a Departmentdomain
     *   }
     * })
     * 
     */
    create<T extends departmentdomainCreateArgs>(args: SelectSubset<T, departmentdomainCreateArgs<ExtArgs>>): Prisma__departmentdomainClient<$Result.GetResult<Prisma.$departmentdomainPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Departmentdomains.
     * @param {departmentdomainCreateManyArgs} args - Arguments to create many Departmentdomains.
     * @example
     * // Create many Departmentdomains
     * const departmentdomain = await prisma.departmentdomain.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends departmentdomainCreateManyArgs>(args?: SelectSubset<T, departmentdomainCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Departmentdomains and returns the data saved in the database.
     * @param {departmentdomainCreateManyAndReturnArgs} args - Arguments to create many Departmentdomains.
     * @example
     * // Create many Departmentdomains
     * const departmentdomain = await prisma.departmentdomain.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Departmentdomains and only return the `department_id`
     * const departmentdomainWithDepartment_idOnly = await prisma.departmentdomain.createManyAndReturn({
     *   select: { department_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends departmentdomainCreateManyAndReturnArgs>(args?: SelectSubset<T, departmentdomainCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$departmentdomainPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Departmentdomain.
     * @param {departmentdomainDeleteArgs} args - Arguments to delete one Departmentdomain.
     * @example
     * // Delete one Departmentdomain
     * const Departmentdomain = await prisma.departmentdomain.delete({
     *   where: {
     *     // ... filter to delete one Departmentdomain
     *   }
     * })
     * 
     */
    delete<T extends departmentdomainDeleteArgs>(args: SelectSubset<T, departmentdomainDeleteArgs<ExtArgs>>): Prisma__departmentdomainClient<$Result.GetResult<Prisma.$departmentdomainPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Departmentdomain.
     * @param {departmentdomainUpdateArgs} args - Arguments to update one Departmentdomain.
     * @example
     * // Update one Departmentdomain
     * const departmentdomain = await prisma.departmentdomain.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends departmentdomainUpdateArgs>(args: SelectSubset<T, departmentdomainUpdateArgs<ExtArgs>>): Prisma__departmentdomainClient<$Result.GetResult<Prisma.$departmentdomainPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Departmentdomains.
     * @param {departmentdomainDeleteManyArgs} args - Arguments to filter Departmentdomains to delete.
     * @example
     * // Delete a few Departmentdomains
     * const { count } = await prisma.departmentdomain.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends departmentdomainDeleteManyArgs>(args?: SelectSubset<T, departmentdomainDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departmentdomains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentdomainUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departmentdomains
     * const departmentdomain = await prisma.departmentdomain.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends departmentdomainUpdateManyArgs>(args: SelectSubset<T, departmentdomainUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departmentdomains and returns the data updated in the database.
     * @param {departmentdomainUpdateManyAndReturnArgs} args - Arguments to update many Departmentdomains.
     * @example
     * // Update many Departmentdomains
     * const departmentdomain = await prisma.departmentdomain.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Departmentdomains and only return the `department_id`
     * const departmentdomainWithDepartment_idOnly = await prisma.departmentdomain.updateManyAndReturn({
     *   select: { department_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends departmentdomainUpdateManyAndReturnArgs>(args: SelectSubset<T, departmentdomainUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$departmentdomainPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Departmentdomain.
     * @param {departmentdomainUpsertArgs} args - Arguments to update or create a Departmentdomain.
     * @example
     * // Update or create a Departmentdomain
     * const departmentdomain = await prisma.departmentdomain.upsert({
     *   create: {
     *     // ... data to create a Departmentdomain
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Departmentdomain we want to update
     *   }
     * })
     */
    upsert<T extends departmentdomainUpsertArgs>(args: SelectSubset<T, departmentdomainUpsertArgs<ExtArgs>>): Prisma__departmentdomainClient<$Result.GetResult<Prisma.$departmentdomainPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Departmentdomains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentdomainCountArgs} args - Arguments to filter Departmentdomains to count.
     * @example
     * // Count the number of Departmentdomains
     * const count = await prisma.departmentdomain.count({
     *   where: {
     *     // ... the filter for the Departmentdomains we want to count
     *   }
     * })
    **/
    count<T extends departmentdomainCountArgs>(
      args?: Subset<T, departmentdomainCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentdomainCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Departmentdomain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentdomainAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentdomainAggregateArgs>(args: Subset<T, DepartmentdomainAggregateArgs>): Prisma.PrismaPromise<GetDepartmentdomainAggregateType<T>>

    /**
     * Group by Departmentdomain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentdomainGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends departmentdomainGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: departmentdomainGroupByArgs['orderBy'] }
        : { orderBy?: departmentdomainGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, departmentdomainGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentdomainGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the departmentdomain model
   */
  readonly fields: departmentdomainFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for departmentdomain.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__departmentdomainClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    department<T extends departmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, departmentDefaultArgs<ExtArgs>>): Prisma__departmentClient<$Result.GetResult<Prisma.$departmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    domain<T extends domainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, domainDefaultArgs<ExtArgs>>): Prisma__domainClient<$Result.GetResult<Prisma.$domainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the departmentdomain model
   */
  interface departmentdomainFieldRefs {
    readonly department_id: FieldRef<"departmentdomain", 'Int'>
    readonly domain_id: FieldRef<"departmentdomain", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * departmentdomain findUnique
   */
  export type departmentdomainFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departmentdomain
     */
    select?: departmentdomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the departmentdomain
     */
    omit?: departmentdomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentdomainInclude<ExtArgs> | null
    /**
     * Filter, which departmentdomain to fetch.
     */
    where: departmentdomainWhereUniqueInput
  }

  /**
   * departmentdomain findUniqueOrThrow
   */
  export type departmentdomainFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departmentdomain
     */
    select?: departmentdomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the departmentdomain
     */
    omit?: departmentdomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentdomainInclude<ExtArgs> | null
    /**
     * Filter, which departmentdomain to fetch.
     */
    where: departmentdomainWhereUniqueInput
  }

  /**
   * departmentdomain findFirst
   */
  export type departmentdomainFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departmentdomain
     */
    select?: departmentdomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the departmentdomain
     */
    omit?: departmentdomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentdomainInclude<ExtArgs> | null
    /**
     * Filter, which departmentdomain to fetch.
     */
    where?: departmentdomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of departmentdomains to fetch.
     */
    orderBy?: departmentdomainOrderByWithRelationInput | departmentdomainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for departmentdomains.
     */
    cursor?: departmentdomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` departmentdomains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` departmentdomains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of departmentdomains.
     */
    distinct?: DepartmentdomainScalarFieldEnum | DepartmentdomainScalarFieldEnum[]
  }

  /**
   * departmentdomain findFirstOrThrow
   */
  export type departmentdomainFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departmentdomain
     */
    select?: departmentdomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the departmentdomain
     */
    omit?: departmentdomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentdomainInclude<ExtArgs> | null
    /**
     * Filter, which departmentdomain to fetch.
     */
    where?: departmentdomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of departmentdomains to fetch.
     */
    orderBy?: departmentdomainOrderByWithRelationInput | departmentdomainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for departmentdomains.
     */
    cursor?: departmentdomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` departmentdomains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` departmentdomains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of departmentdomains.
     */
    distinct?: DepartmentdomainScalarFieldEnum | DepartmentdomainScalarFieldEnum[]
  }

  /**
   * departmentdomain findMany
   */
  export type departmentdomainFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departmentdomain
     */
    select?: departmentdomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the departmentdomain
     */
    omit?: departmentdomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentdomainInclude<ExtArgs> | null
    /**
     * Filter, which departmentdomains to fetch.
     */
    where?: departmentdomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of departmentdomains to fetch.
     */
    orderBy?: departmentdomainOrderByWithRelationInput | departmentdomainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing departmentdomains.
     */
    cursor?: departmentdomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` departmentdomains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` departmentdomains.
     */
    skip?: number
    distinct?: DepartmentdomainScalarFieldEnum | DepartmentdomainScalarFieldEnum[]
  }

  /**
   * departmentdomain create
   */
  export type departmentdomainCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departmentdomain
     */
    select?: departmentdomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the departmentdomain
     */
    omit?: departmentdomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentdomainInclude<ExtArgs> | null
    /**
     * The data needed to create a departmentdomain.
     */
    data: XOR<departmentdomainCreateInput, departmentdomainUncheckedCreateInput>
  }

  /**
   * departmentdomain createMany
   */
  export type departmentdomainCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many departmentdomains.
     */
    data: departmentdomainCreateManyInput | departmentdomainCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * departmentdomain createManyAndReturn
   */
  export type departmentdomainCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departmentdomain
     */
    select?: departmentdomainSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the departmentdomain
     */
    omit?: departmentdomainOmit<ExtArgs> | null
    /**
     * The data used to create many departmentdomains.
     */
    data: departmentdomainCreateManyInput | departmentdomainCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentdomainIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * departmentdomain update
   */
  export type departmentdomainUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departmentdomain
     */
    select?: departmentdomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the departmentdomain
     */
    omit?: departmentdomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentdomainInclude<ExtArgs> | null
    /**
     * The data needed to update a departmentdomain.
     */
    data: XOR<departmentdomainUpdateInput, departmentdomainUncheckedUpdateInput>
    /**
     * Choose, which departmentdomain to update.
     */
    where: departmentdomainWhereUniqueInput
  }

  /**
   * departmentdomain updateMany
   */
  export type departmentdomainUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update departmentdomains.
     */
    data: XOR<departmentdomainUpdateManyMutationInput, departmentdomainUncheckedUpdateManyInput>
    /**
     * Filter which departmentdomains to update
     */
    where?: departmentdomainWhereInput
    /**
     * Limit how many departmentdomains to update.
     */
    limit?: number
  }

  /**
   * departmentdomain updateManyAndReturn
   */
  export type departmentdomainUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departmentdomain
     */
    select?: departmentdomainSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the departmentdomain
     */
    omit?: departmentdomainOmit<ExtArgs> | null
    /**
     * The data used to update departmentdomains.
     */
    data: XOR<departmentdomainUpdateManyMutationInput, departmentdomainUncheckedUpdateManyInput>
    /**
     * Filter which departmentdomains to update
     */
    where?: departmentdomainWhereInput
    /**
     * Limit how many departmentdomains to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentdomainIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * departmentdomain upsert
   */
  export type departmentdomainUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departmentdomain
     */
    select?: departmentdomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the departmentdomain
     */
    omit?: departmentdomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentdomainInclude<ExtArgs> | null
    /**
     * The filter to search for the departmentdomain to update in case it exists.
     */
    where: departmentdomainWhereUniqueInput
    /**
     * In case the departmentdomain found by the `where` argument doesn't exist, create a new departmentdomain with this data.
     */
    create: XOR<departmentdomainCreateInput, departmentdomainUncheckedCreateInput>
    /**
     * In case the departmentdomain was found with the provided `where` argument, update it with this data.
     */
    update: XOR<departmentdomainUpdateInput, departmentdomainUncheckedUpdateInput>
  }

  /**
   * departmentdomain delete
   */
  export type departmentdomainDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departmentdomain
     */
    select?: departmentdomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the departmentdomain
     */
    omit?: departmentdomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentdomainInclude<ExtArgs> | null
    /**
     * Filter which departmentdomain to delete.
     */
    where: departmentdomainWhereUniqueInput
  }

  /**
   * departmentdomain deleteMany
   */
  export type departmentdomainDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which departmentdomains to delete
     */
    where?: departmentdomainWhereInput
    /**
     * Limit how many departmentdomains to delete.
     */
    limit?: number
  }

  /**
   * departmentdomain without action
   */
  export type departmentdomainDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departmentdomain
     */
    select?: departmentdomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the departmentdomain
     */
    omit?: departmentdomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentdomainInclude<ExtArgs> | null
  }


  /**
   * Model generaluser
   */

  export type AggregateGeneraluser = {
    _count: GeneraluserCountAggregateOutputType | null
    _avg: GeneraluserAvgAggregateOutputType | null
    _sum: GeneraluserSumAggregateOutputType | null
    _min: GeneraluserMinAggregateOutputType | null
    _max: GeneraluserMaxAggregateOutputType | null
  }

  export type GeneraluserAvgAggregateOutputType = {
    generaluser_id: number | null
    user_id: number | null
  }

  export type GeneraluserSumAggregateOutputType = {
    generaluser_id: number | null
    user_id: number | null
  }

  export type GeneraluserMinAggregateOutputType = {
    generaluser_id: number | null
    user_id: number | null
  }

  export type GeneraluserMaxAggregateOutputType = {
    generaluser_id: number | null
    user_id: number | null
  }

  export type GeneraluserCountAggregateOutputType = {
    generaluser_id: number
    user_id: number
    _all: number
  }


  export type GeneraluserAvgAggregateInputType = {
    generaluser_id?: true
    user_id?: true
  }

  export type GeneraluserSumAggregateInputType = {
    generaluser_id?: true
    user_id?: true
  }

  export type GeneraluserMinAggregateInputType = {
    generaluser_id?: true
    user_id?: true
  }

  export type GeneraluserMaxAggregateInputType = {
    generaluser_id?: true
    user_id?: true
  }

  export type GeneraluserCountAggregateInputType = {
    generaluser_id?: true
    user_id?: true
    _all?: true
  }

  export type GeneraluserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which generaluser to aggregate.
     */
    where?: generaluserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of generalusers to fetch.
     */
    orderBy?: generaluserOrderByWithRelationInput | generaluserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: generaluserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` generalusers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` generalusers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned generalusers
    **/
    _count?: true | GeneraluserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GeneraluserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GeneraluserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GeneraluserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GeneraluserMaxAggregateInputType
  }

  export type GetGeneraluserAggregateType<T extends GeneraluserAggregateArgs> = {
        [P in keyof T & keyof AggregateGeneraluser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGeneraluser[P]>
      : GetScalarType<T[P], AggregateGeneraluser[P]>
  }




  export type generaluserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: generaluserWhereInput
    orderBy?: generaluserOrderByWithAggregationInput | generaluserOrderByWithAggregationInput[]
    by: GeneraluserScalarFieldEnum[] | GeneraluserScalarFieldEnum
    having?: generaluserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GeneraluserCountAggregateInputType | true
    _avg?: GeneraluserAvgAggregateInputType
    _sum?: GeneraluserSumAggregateInputType
    _min?: GeneraluserMinAggregateInputType
    _max?: GeneraluserMaxAggregateInputType
  }

  export type GeneraluserGroupByOutputType = {
    generaluser_id: number
    user_id: number | null
    _count: GeneraluserCountAggregateOutputType | null
    _avg: GeneraluserAvgAggregateOutputType | null
    _sum: GeneraluserSumAggregateOutputType | null
    _min: GeneraluserMinAggregateOutputType | null
    _max: GeneraluserMaxAggregateOutputType | null
  }

  type GetGeneraluserGroupByPayload<T extends generaluserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GeneraluserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GeneraluserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GeneraluserGroupByOutputType[P]>
            : GetScalarType<T[P], GeneraluserGroupByOutputType[P]>
        }
      >
    >


  export type generaluserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    generaluser_id?: boolean
    user_id?: boolean
    user?: boolean | generaluser$userArgs<ExtArgs>
  }, ExtArgs["result"]["generaluser"]>

  export type generaluserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    generaluser_id?: boolean
    user_id?: boolean
    user?: boolean | generaluser$userArgs<ExtArgs>
  }, ExtArgs["result"]["generaluser"]>

  export type generaluserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    generaluser_id?: boolean
    user_id?: boolean
    user?: boolean | generaluser$userArgs<ExtArgs>
  }, ExtArgs["result"]["generaluser"]>

  export type generaluserSelectScalar = {
    generaluser_id?: boolean
    user_id?: boolean
  }

  export type generaluserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"generaluser_id" | "user_id", ExtArgs["result"]["generaluser"]>
  export type generaluserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | generaluser$userArgs<ExtArgs>
  }
  export type generaluserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | generaluser$userArgs<ExtArgs>
  }
  export type generaluserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | generaluser$userArgs<ExtArgs>
  }

  export type $generaluserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "generaluser"
    objects: {
      user: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      generaluser_id: number
      user_id: number | null
    }, ExtArgs["result"]["generaluser"]>
    composites: {}
  }

  type generaluserGetPayload<S extends boolean | null | undefined | generaluserDefaultArgs> = $Result.GetResult<Prisma.$generaluserPayload, S>

  type generaluserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<generaluserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GeneraluserCountAggregateInputType | true
    }

  export interface generaluserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['generaluser'], meta: { name: 'generaluser' } }
    /**
     * Find zero or one Generaluser that matches the filter.
     * @param {generaluserFindUniqueArgs} args - Arguments to find a Generaluser
     * @example
     * // Get one Generaluser
     * const generaluser = await prisma.generaluser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends generaluserFindUniqueArgs>(args: SelectSubset<T, generaluserFindUniqueArgs<ExtArgs>>): Prisma__generaluserClient<$Result.GetResult<Prisma.$generaluserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Generaluser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {generaluserFindUniqueOrThrowArgs} args - Arguments to find a Generaluser
     * @example
     * // Get one Generaluser
     * const generaluser = await prisma.generaluser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends generaluserFindUniqueOrThrowArgs>(args: SelectSubset<T, generaluserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__generaluserClient<$Result.GetResult<Prisma.$generaluserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Generaluser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {generaluserFindFirstArgs} args - Arguments to find a Generaluser
     * @example
     * // Get one Generaluser
     * const generaluser = await prisma.generaluser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends generaluserFindFirstArgs>(args?: SelectSubset<T, generaluserFindFirstArgs<ExtArgs>>): Prisma__generaluserClient<$Result.GetResult<Prisma.$generaluserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Generaluser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {generaluserFindFirstOrThrowArgs} args - Arguments to find a Generaluser
     * @example
     * // Get one Generaluser
     * const generaluser = await prisma.generaluser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends generaluserFindFirstOrThrowArgs>(args?: SelectSubset<T, generaluserFindFirstOrThrowArgs<ExtArgs>>): Prisma__generaluserClient<$Result.GetResult<Prisma.$generaluserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Generalusers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {generaluserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Generalusers
     * const generalusers = await prisma.generaluser.findMany()
     * 
     * // Get first 10 Generalusers
     * const generalusers = await prisma.generaluser.findMany({ take: 10 })
     * 
     * // Only select the `generaluser_id`
     * const generaluserWithGeneraluser_idOnly = await prisma.generaluser.findMany({ select: { generaluser_id: true } })
     * 
     */
    findMany<T extends generaluserFindManyArgs>(args?: SelectSubset<T, generaluserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$generaluserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Generaluser.
     * @param {generaluserCreateArgs} args - Arguments to create a Generaluser.
     * @example
     * // Create one Generaluser
     * const Generaluser = await prisma.generaluser.create({
     *   data: {
     *     // ... data to create a Generaluser
     *   }
     * })
     * 
     */
    create<T extends generaluserCreateArgs>(args: SelectSubset<T, generaluserCreateArgs<ExtArgs>>): Prisma__generaluserClient<$Result.GetResult<Prisma.$generaluserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Generalusers.
     * @param {generaluserCreateManyArgs} args - Arguments to create many Generalusers.
     * @example
     * // Create many Generalusers
     * const generaluser = await prisma.generaluser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends generaluserCreateManyArgs>(args?: SelectSubset<T, generaluserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Generalusers and returns the data saved in the database.
     * @param {generaluserCreateManyAndReturnArgs} args - Arguments to create many Generalusers.
     * @example
     * // Create many Generalusers
     * const generaluser = await prisma.generaluser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Generalusers and only return the `generaluser_id`
     * const generaluserWithGeneraluser_idOnly = await prisma.generaluser.createManyAndReturn({
     *   select: { generaluser_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends generaluserCreateManyAndReturnArgs>(args?: SelectSubset<T, generaluserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$generaluserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Generaluser.
     * @param {generaluserDeleteArgs} args - Arguments to delete one Generaluser.
     * @example
     * // Delete one Generaluser
     * const Generaluser = await prisma.generaluser.delete({
     *   where: {
     *     // ... filter to delete one Generaluser
     *   }
     * })
     * 
     */
    delete<T extends generaluserDeleteArgs>(args: SelectSubset<T, generaluserDeleteArgs<ExtArgs>>): Prisma__generaluserClient<$Result.GetResult<Prisma.$generaluserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Generaluser.
     * @param {generaluserUpdateArgs} args - Arguments to update one Generaluser.
     * @example
     * // Update one Generaluser
     * const generaluser = await prisma.generaluser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends generaluserUpdateArgs>(args: SelectSubset<T, generaluserUpdateArgs<ExtArgs>>): Prisma__generaluserClient<$Result.GetResult<Prisma.$generaluserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Generalusers.
     * @param {generaluserDeleteManyArgs} args - Arguments to filter Generalusers to delete.
     * @example
     * // Delete a few Generalusers
     * const { count } = await prisma.generaluser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends generaluserDeleteManyArgs>(args?: SelectSubset<T, generaluserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Generalusers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {generaluserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Generalusers
     * const generaluser = await prisma.generaluser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends generaluserUpdateManyArgs>(args: SelectSubset<T, generaluserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Generalusers and returns the data updated in the database.
     * @param {generaluserUpdateManyAndReturnArgs} args - Arguments to update many Generalusers.
     * @example
     * // Update many Generalusers
     * const generaluser = await prisma.generaluser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Generalusers and only return the `generaluser_id`
     * const generaluserWithGeneraluser_idOnly = await prisma.generaluser.updateManyAndReturn({
     *   select: { generaluser_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends generaluserUpdateManyAndReturnArgs>(args: SelectSubset<T, generaluserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$generaluserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Generaluser.
     * @param {generaluserUpsertArgs} args - Arguments to update or create a Generaluser.
     * @example
     * // Update or create a Generaluser
     * const generaluser = await prisma.generaluser.upsert({
     *   create: {
     *     // ... data to create a Generaluser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Generaluser we want to update
     *   }
     * })
     */
    upsert<T extends generaluserUpsertArgs>(args: SelectSubset<T, generaluserUpsertArgs<ExtArgs>>): Prisma__generaluserClient<$Result.GetResult<Prisma.$generaluserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Generalusers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {generaluserCountArgs} args - Arguments to filter Generalusers to count.
     * @example
     * // Count the number of Generalusers
     * const count = await prisma.generaluser.count({
     *   where: {
     *     // ... the filter for the Generalusers we want to count
     *   }
     * })
    **/
    count<T extends generaluserCountArgs>(
      args?: Subset<T, generaluserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GeneraluserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Generaluser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneraluserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GeneraluserAggregateArgs>(args: Subset<T, GeneraluserAggregateArgs>): Prisma.PrismaPromise<GetGeneraluserAggregateType<T>>

    /**
     * Group by Generaluser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {generaluserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends generaluserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: generaluserGroupByArgs['orderBy'] }
        : { orderBy?: generaluserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, generaluserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGeneraluserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the generaluser model
   */
  readonly fields: generaluserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for generaluser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__generaluserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends generaluser$userArgs<ExtArgs> = {}>(args?: Subset<T, generaluser$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the generaluser model
   */
  interface generaluserFieldRefs {
    readonly generaluser_id: FieldRef<"generaluser", 'Int'>
    readonly user_id: FieldRef<"generaluser", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * generaluser findUnique
   */
  export type generaluserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generaluser
     */
    select?: generaluserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the generaluser
     */
    omit?: generaluserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: generaluserInclude<ExtArgs> | null
    /**
     * Filter, which generaluser to fetch.
     */
    where: generaluserWhereUniqueInput
  }

  /**
   * generaluser findUniqueOrThrow
   */
  export type generaluserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generaluser
     */
    select?: generaluserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the generaluser
     */
    omit?: generaluserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: generaluserInclude<ExtArgs> | null
    /**
     * Filter, which generaluser to fetch.
     */
    where: generaluserWhereUniqueInput
  }

  /**
   * generaluser findFirst
   */
  export type generaluserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generaluser
     */
    select?: generaluserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the generaluser
     */
    omit?: generaluserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: generaluserInclude<ExtArgs> | null
    /**
     * Filter, which generaluser to fetch.
     */
    where?: generaluserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of generalusers to fetch.
     */
    orderBy?: generaluserOrderByWithRelationInput | generaluserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for generalusers.
     */
    cursor?: generaluserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` generalusers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` generalusers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of generalusers.
     */
    distinct?: GeneraluserScalarFieldEnum | GeneraluserScalarFieldEnum[]
  }

  /**
   * generaluser findFirstOrThrow
   */
  export type generaluserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generaluser
     */
    select?: generaluserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the generaluser
     */
    omit?: generaluserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: generaluserInclude<ExtArgs> | null
    /**
     * Filter, which generaluser to fetch.
     */
    where?: generaluserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of generalusers to fetch.
     */
    orderBy?: generaluserOrderByWithRelationInput | generaluserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for generalusers.
     */
    cursor?: generaluserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` generalusers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` generalusers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of generalusers.
     */
    distinct?: GeneraluserScalarFieldEnum | GeneraluserScalarFieldEnum[]
  }

  /**
   * generaluser findMany
   */
  export type generaluserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generaluser
     */
    select?: generaluserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the generaluser
     */
    omit?: generaluserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: generaluserInclude<ExtArgs> | null
    /**
     * Filter, which generalusers to fetch.
     */
    where?: generaluserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of generalusers to fetch.
     */
    orderBy?: generaluserOrderByWithRelationInput | generaluserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing generalusers.
     */
    cursor?: generaluserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` generalusers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` generalusers.
     */
    skip?: number
    distinct?: GeneraluserScalarFieldEnum | GeneraluserScalarFieldEnum[]
  }

  /**
   * generaluser create
   */
  export type generaluserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generaluser
     */
    select?: generaluserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the generaluser
     */
    omit?: generaluserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: generaluserInclude<ExtArgs> | null
    /**
     * The data needed to create a generaluser.
     */
    data?: XOR<generaluserCreateInput, generaluserUncheckedCreateInput>
  }

  /**
   * generaluser createMany
   */
  export type generaluserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many generalusers.
     */
    data: generaluserCreateManyInput | generaluserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * generaluser createManyAndReturn
   */
  export type generaluserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generaluser
     */
    select?: generaluserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the generaluser
     */
    omit?: generaluserOmit<ExtArgs> | null
    /**
     * The data used to create many generalusers.
     */
    data: generaluserCreateManyInput | generaluserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: generaluserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * generaluser update
   */
  export type generaluserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generaluser
     */
    select?: generaluserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the generaluser
     */
    omit?: generaluserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: generaluserInclude<ExtArgs> | null
    /**
     * The data needed to update a generaluser.
     */
    data: XOR<generaluserUpdateInput, generaluserUncheckedUpdateInput>
    /**
     * Choose, which generaluser to update.
     */
    where: generaluserWhereUniqueInput
  }

  /**
   * generaluser updateMany
   */
  export type generaluserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update generalusers.
     */
    data: XOR<generaluserUpdateManyMutationInput, generaluserUncheckedUpdateManyInput>
    /**
     * Filter which generalusers to update
     */
    where?: generaluserWhereInput
    /**
     * Limit how many generalusers to update.
     */
    limit?: number
  }

  /**
   * generaluser updateManyAndReturn
   */
  export type generaluserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generaluser
     */
    select?: generaluserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the generaluser
     */
    omit?: generaluserOmit<ExtArgs> | null
    /**
     * The data used to update generalusers.
     */
    data: XOR<generaluserUpdateManyMutationInput, generaluserUncheckedUpdateManyInput>
    /**
     * Filter which generalusers to update
     */
    where?: generaluserWhereInput
    /**
     * Limit how many generalusers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: generaluserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * generaluser upsert
   */
  export type generaluserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generaluser
     */
    select?: generaluserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the generaluser
     */
    omit?: generaluserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: generaluserInclude<ExtArgs> | null
    /**
     * The filter to search for the generaluser to update in case it exists.
     */
    where: generaluserWhereUniqueInput
    /**
     * In case the generaluser found by the `where` argument doesn't exist, create a new generaluser with this data.
     */
    create: XOR<generaluserCreateInput, generaluserUncheckedCreateInput>
    /**
     * In case the generaluser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<generaluserUpdateInput, generaluserUncheckedUpdateInput>
  }

  /**
   * generaluser delete
   */
  export type generaluserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generaluser
     */
    select?: generaluserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the generaluser
     */
    omit?: generaluserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: generaluserInclude<ExtArgs> | null
    /**
     * Filter which generaluser to delete.
     */
    where: generaluserWhereUniqueInput
  }

  /**
   * generaluser deleteMany
   */
  export type generaluserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which generalusers to delete
     */
    where?: generaluserWhereInput
    /**
     * Limit how many generalusers to delete.
     */
    limit?: number
  }

  /**
   * generaluser.user
   */
  export type generaluser$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * generaluser without action
   */
  export type generaluserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generaluser
     */
    select?: generaluserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the generaluser
     */
    omit?: generaluserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: generaluserInclude<ExtArgs> | null
  }


  /**
   * Model student
   */

  export type AggregateStudent = {
    _count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  export type StudentAvgAggregateOutputType = {
    student_id: number | null
    department_id: number | null
    user_id: number | null
  }

  export type StudentSumAggregateOutputType = {
    student_id: number | null
    department_id: number | null
    user_id: number | null
  }

  export type StudentMinAggregateOutputType = {
    student_id: number | null
    roll_number: string | null
    department_id: number | null
    user_id: number | null
  }

  export type StudentMaxAggregateOutputType = {
    student_id: number | null
    roll_number: string | null
    department_id: number | null
    user_id: number | null
  }

  export type StudentCountAggregateOutputType = {
    student_id: number
    roll_number: number
    department_id: number
    user_id: number
    _all: number
  }


  export type StudentAvgAggregateInputType = {
    student_id?: true
    department_id?: true
    user_id?: true
  }

  export type StudentSumAggregateInputType = {
    student_id?: true
    department_id?: true
    user_id?: true
  }

  export type StudentMinAggregateInputType = {
    student_id?: true
    roll_number?: true
    department_id?: true
    user_id?: true
  }

  export type StudentMaxAggregateInputType = {
    student_id?: true
    roll_number?: true
    department_id?: true
    user_id?: true
  }

  export type StudentCountAggregateInputType = {
    student_id?: true
    roll_number?: true
    department_id?: true
    user_id?: true
    _all?: true
  }

  export type StudentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which student to aggregate.
     */
    where?: studentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     */
    orderBy?: studentOrderByWithRelationInput | studentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: studentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned students
    **/
    _count?: true | StudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMaxAggregateInputType
  }

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>
  }




  export type studentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: studentWhereInput
    orderBy?: studentOrderByWithAggregationInput | studentOrderByWithAggregationInput[]
    by: StudentScalarFieldEnum[] | StudentScalarFieldEnum
    having?: studentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCountAggregateInputType | true
    _avg?: StudentAvgAggregateInputType
    _sum?: StudentSumAggregateInputType
    _min?: StudentMinAggregateInputType
    _max?: StudentMaxAggregateInputType
  }

  export type StudentGroupByOutputType = {
    student_id: number
    roll_number: string | null
    department_id: number | null
    user_id: number | null
    _count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  type GetStudentGroupByPayload<T extends studentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentGroupByOutputType[P]>
        }
      >
    >


  export type studentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    student_id?: boolean
    roll_number?: boolean
    department_id?: boolean
    user_id?: boolean
    department?: boolean | student$departmentArgs<ExtArgs>
    user?: boolean | student$userArgs<ExtArgs>
    teamapplication?: boolean | student$teamapplicationArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type studentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    student_id?: boolean
    roll_number?: boolean
    department_id?: boolean
    user_id?: boolean
    department?: boolean | student$departmentArgs<ExtArgs>
    user?: boolean | student$userArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type studentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    student_id?: boolean
    roll_number?: boolean
    department_id?: boolean
    user_id?: boolean
    department?: boolean | student$departmentArgs<ExtArgs>
    user?: boolean | student$userArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type studentSelectScalar = {
    student_id?: boolean
    roll_number?: boolean
    department_id?: boolean
    user_id?: boolean
  }

  export type studentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"student_id" | "roll_number" | "department_id" | "user_id", ExtArgs["result"]["student"]>
  export type studentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | student$departmentArgs<ExtArgs>
    user?: boolean | student$userArgs<ExtArgs>
    teamapplication?: boolean | student$teamapplicationArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type studentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | student$departmentArgs<ExtArgs>
    user?: boolean | student$userArgs<ExtArgs>
  }
  export type studentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | student$departmentArgs<ExtArgs>
    user?: boolean | student$userArgs<ExtArgs>
  }

  export type $studentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "student"
    objects: {
      department: Prisma.$departmentPayload<ExtArgs> | null
      user: Prisma.$userPayload<ExtArgs> | null
      teamapplication: Prisma.$teamapplicationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      student_id: number
      roll_number: string | null
      department_id: number | null
      user_id: number | null
    }, ExtArgs["result"]["student"]>
    composites: {}
  }

  type studentGetPayload<S extends boolean | null | undefined | studentDefaultArgs> = $Result.GetResult<Prisma.$studentPayload, S>

  type studentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<studentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentCountAggregateInputType | true
    }

  export interface studentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['student'], meta: { name: 'student' } }
    /**
     * Find zero or one Student that matches the filter.
     * @param {studentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends studentFindUniqueArgs>(args: SelectSubset<T, studentFindUniqueArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Student that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {studentFindUniqueOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends studentFindUniqueOrThrowArgs>(args: SelectSubset<T, studentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends studentFindFirstArgs>(args?: SelectSubset<T, studentFindFirstArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentFindFirstOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends studentFindFirstOrThrowArgs>(args?: SelectSubset<T, studentFindFirstOrThrowArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     * 
     * // Only select the `student_id`
     * const studentWithStudent_idOnly = await prisma.student.findMany({ select: { student_id: true } })
     * 
     */
    findMany<T extends studentFindManyArgs>(args?: SelectSubset<T, studentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Student.
     * @param {studentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     * 
     */
    create<T extends studentCreateArgs>(args: SelectSubset<T, studentCreateArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Students.
     * @param {studentCreateManyArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends studentCreateManyArgs>(args?: SelectSubset<T, studentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Students and returns the data saved in the database.
     * @param {studentCreateManyAndReturnArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Students and only return the `student_id`
     * const studentWithStudent_idOnly = await prisma.student.createManyAndReturn({
     *   select: { student_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends studentCreateManyAndReturnArgs>(args?: SelectSubset<T, studentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Student.
     * @param {studentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     * 
     */
    delete<T extends studentDeleteArgs>(args: SelectSubset<T, studentDeleteArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Student.
     * @param {studentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends studentUpdateArgs>(args: SelectSubset<T, studentUpdateArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Students.
     * @param {studentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends studentDeleteManyArgs>(args?: SelectSubset<T, studentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends studentUpdateManyArgs>(args: SelectSubset<T, studentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students and returns the data updated in the database.
     * @param {studentUpdateManyAndReturnArgs} args - Arguments to update many Students.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Students and only return the `student_id`
     * const studentWithStudent_idOnly = await prisma.student.updateManyAndReturn({
     *   select: { student_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends studentUpdateManyAndReturnArgs>(args: SelectSubset<T, studentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Student.
     * @param {studentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
     */
    upsert<T extends studentUpsertArgs>(args: SelectSubset<T, studentUpsertArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends studentCountArgs>(
      args?: Subset<T, studentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAggregateArgs>(args: Subset<T, StudentAggregateArgs>): Prisma.PrismaPromise<GetStudentAggregateType<T>>

    /**
     * Group by Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends studentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: studentGroupByArgs['orderBy'] }
        : { orderBy?: studentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, studentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the student model
   */
  readonly fields: studentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__studentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    department<T extends student$departmentArgs<ExtArgs> = {}>(args?: Subset<T, student$departmentArgs<ExtArgs>>): Prisma__departmentClient<$Result.GetResult<Prisma.$departmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends student$userArgs<ExtArgs> = {}>(args?: Subset<T, student$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    teamapplication<T extends student$teamapplicationArgs<ExtArgs> = {}>(args?: Subset<T, student$teamapplicationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teamapplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the student model
   */
  interface studentFieldRefs {
    readonly student_id: FieldRef<"student", 'Int'>
    readonly roll_number: FieldRef<"student", 'String'>
    readonly department_id: FieldRef<"student", 'Int'>
    readonly user_id: FieldRef<"student", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * student findUnique
   */
  export type studentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    /**
     * Filter, which student to fetch.
     */
    where: studentWhereUniqueInput
  }

  /**
   * student findUniqueOrThrow
   */
  export type studentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    /**
     * Filter, which student to fetch.
     */
    where: studentWhereUniqueInput
  }

  /**
   * student findFirst
   */
  export type studentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    /**
     * Filter, which student to fetch.
     */
    where?: studentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     */
    orderBy?: studentOrderByWithRelationInput | studentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for students.
     */
    cursor?: studentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * student findFirstOrThrow
   */
  export type studentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    /**
     * Filter, which student to fetch.
     */
    where?: studentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     */
    orderBy?: studentOrderByWithRelationInput | studentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for students.
     */
    cursor?: studentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * student findMany
   */
  export type studentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    /**
     * Filter, which students to fetch.
     */
    where?: studentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     */
    orderBy?: studentOrderByWithRelationInput | studentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing students.
     */
    cursor?: studentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     */
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * student create
   */
  export type studentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    /**
     * The data needed to create a student.
     */
    data?: XOR<studentCreateInput, studentUncheckedCreateInput>
  }

  /**
   * student createMany
   */
  export type studentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many students.
     */
    data: studentCreateManyInput | studentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * student createManyAndReturn
   */
  export type studentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * The data used to create many students.
     */
    data: studentCreateManyInput | studentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * student update
   */
  export type studentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    /**
     * The data needed to update a student.
     */
    data: XOR<studentUpdateInput, studentUncheckedUpdateInput>
    /**
     * Choose, which student to update.
     */
    where: studentWhereUniqueInput
  }

  /**
   * student updateMany
   */
  export type studentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update students.
     */
    data: XOR<studentUpdateManyMutationInput, studentUncheckedUpdateManyInput>
    /**
     * Filter which students to update
     */
    where?: studentWhereInput
    /**
     * Limit how many students to update.
     */
    limit?: number
  }

  /**
   * student updateManyAndReturn
   */
  export type studentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * The data used to update students.
     */
    data: XOR<studentUpdateManyMutationInput, studentUncheckedUpdateManyInput>
    /**
     * Filter which students to update
     */
    where?: studentWhereInput
    /**
     * Limit how many students to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * student upsert
   */
  export type studentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    /**
     * The filter to search for the student to update in case it exists.
     */
    where: studentWhereUniqueInput
    /**
     * In case the student found by the `where` argument doesn't exist, create a new student with this data.
     */
    create: XOR<studentCreateInput, studentUncheckedCreateInput>
    /**
     * In case the student was found with the provided `where` argument, update it with this data.
     */
    update: XOR<studentUpdateInput, studentUncheckedUpdateInput>
  }

  /**
   * student delete
   */
  export type studentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    /**
     * Filter which student to delete.
     */
    where: studentWhereUniqueInput
  }

  /**
   * student deleteMany
   */
  export type studentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which students to delete
     */
    where?: studentWhereInput
    /**
     * Limit how many students to delete.
     */
    limit?: number
  }

  /**
   * student.department
   */
  export type student$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the department
     */
    omit?: departmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentInclude<ExtArgs> | null
    where?: departmentWhereInput
  }

  /**
   * student.user
   */
  export type student$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * student.teamapplication
   */
  export type student$teamapplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teamapplication
     */
    select?: teamapplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teamapplication
     */
    omit?: teamapplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamapplicationInclude<ExtArgs> | null
    where?: teamapplicationWhereInput
    orderBy?: teamapplicationOrderByWithRelationInput | teamapplicationOrderByWithRelationInput[]
    cursor?: teamapplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamapplicationScalarFieldEnum | TeamapplicationScalarFieldEnum[]
  }

  /**
   * student without action
   */
  export type studentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
  }


  /**
   * Model teacher
   */

  export type AggregateTeacher = {
    _count: TeacherCountAggregateOutputType | null
    _avg: TeacherAvgAggregateOutputType | null
    _sum: TeacherSumAggregateOutputType | null
    _min: TeacherMinAggregateOutputType | null
    _max: TeacherMaxAggregateOutputType | null
  }

  export type TeacherAvgAggregateOutputType = {
    teacher_id: number | null
    department_id: number | null
    user_id: number | null
  }

  export type TeacherSumAggregateOutputType = {
    teacher_id: number | null
    department_id: number | null
    user_id: number | null
  }

  export type TeacherMinAggregateOutputType = {
    teacher_id: number | null
    designation: string | null
    department_id: number | null
    user_id: number | null
    isReviewer: boolean | null
  }

  export type TeacherMaxAggregateOutputType = {
    teacher_id: number | null
    designation: string | null
    department_id: number | null
    user_id: number | null
    isReviewer: boolean | null
  }

  export type TeacherCountAggregateOutputType = {
    teacher_id: number
    designation: number
    department_id: number
    user_id: number
    isReviewer: number
    _all: number
  }


  export type TeacherAvgAggregateInputType = {
    teacher_id?: true
    department_id?: true
    user_id?: true
  }

  export type TeacherSumAggregateInputType = {
    teacher_id?: true
    department_id?: true
    user_id?: true
  }

  export type TeacherMinAggregateInputType = {
    teacher_id?: true
    designation?: true
    department_id?: true
    user_id?: true
    isReviewer?: true
  }

  export type TeacherMaxAggregateInputType = {
    teacher_id?: true
    designation?: true
    department_id?: true
    user_id?: true
    isReviewer?: true
  }

  export type TeacherCountAggregateInputType = {
    teacher_id?: true
    designation?: true
    department_id?: true
    user_id?: true
    isReviewer?: true
    _all?: true
  }

  export type TeacherAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which teacher to aggregate.
     */
    where?: teacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teachers to fetch.
     */
    orderBy?: teacherOrderByWithRelationInput | teacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: teacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned teachers
    **/
    _count?: true | TeacherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeacherAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeacherSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeacherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeacherMaxAggregateInputType
  }

  export type GetTeacherAggregateType<T extends TeacherAggregateArgs> = {
        [P in keyof T & keyof AggregateTeacher]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeacher[P]>
      : GetScalarType<T[P], AggregateTeacher[P]>
  }




  export type teacherGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teacherWhereInput
    orderBy?: teacherOrderByWithAggregationInput | teacherOrderByWithAggregationInput[]
    by: TeacherScalarFieldEnum[] | TeacherScalarFieldEnum
    having?: teacherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeacherCountAggregateInputType | true
    _avg?: TeacherAvgAggregateInputType
    _sum?: TeacherSumAggregateInputType
    _min?: TeacherMinAggregateInputType
    _max?: TeacherMaxAggregateInputType
  }

  export type TeacherGroupByOutputType = {
    teacher_id: number
    designation: string | null
    department_id: number | null
    user_id: number | null
    isReviewer: boolean
    _count: TeacherCountAggregateOutputType | null
    _avg: TeacherAvgAggregateOutputType | null
    _sum: TeacherSumAggregateOutputType | null
    _min: TeacherMinAggregateOutputType | null
    _max: TeacherMaxAggregateOutputType | null
  }

  type GetTeacherGroupByPayload<T extends teacherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeacherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeacherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeacherGroupByOutputType[P]>
            : GetScalarType<T[P], TeacherGroupByOutputType[P]>
        }
      >
    >


  export type teacherSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    teacher_id?: boolean
    designation?: boolean
    department_id?: boolean
    user_id?: boolean
    isReviewer?: boolean
    paper?: boolean | teacher$paperArgs<ExtArgs>
    proposal?: boolean | teacher$proposalArgs<ExtArgs>
    reviewer?: boolean | teacher$reviewerArgs<ExtArgs>
    department?: boolean | teacher$departmentArgs<ExtArgs>
    user?: boolean | teacher$userArgs<ExtArgs>
    _count?: boolean | TeacherCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacher"]>

  export type teacherSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    teacher_id?: boolean
    designation?: boolean
    department_id?: boolean
    user_id?: boolean
    isReviewer?: boolean
    department?: boolean | teacher$departmentArgs<ExtArgs>
    user?: boolean | teacher$userArgs<ExtArgs>
  }, ExtArgs["result"]["teacher"]>

  export type teacherSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    teacher_id?: boolean
    designation?: boolean
    department_id?: boolean
    user_id?: boolean
    isReviewer?: boolean
    department?: boolean | teacher$departmentArgs<ExtArgs>
    user?: boolean | teacher$userArgs<ExtArgs>
  }, ExtArgs["result"]["teacher"]>

  export type teacherSelectScalar = {
    teacher_id?: boolean
    designation?: boolean
    department_id?: boolean
    user_id?: boolean
    isReviewer?: boolean
  }

  export type teacherOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"teacher_id" | "designation" | "department_id" | "user_id" | "isReviewer", ExtArgs["result"]["teacher"]>
  export type teacherInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paper?: boolean | teacher$paperArgs<ExtArgs>
    proposal?: boolean | teacher$proposalArgs<ExtArgs>
    reviewer?: boolean | teacher$reviewerArgs<ExtArgs>
    department?: boolean | teacher$departmentArgs<ExtArgs>
    user?: boolean | teacher$userArgs<ExtArgs>
    _count?: boolean | TeacherCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type teacherIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | teacher$departmentArgs<ExtArgs>
    user?: boolean | teacher$userArgs<ExtArgs>
  }
  export type teacherIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | teacher$departmentArgs<ExtArgs>
    user?: boolean | teacher$userArgs<ExtArgs>
  }

  export type $teacherPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "teacher"
    objects: {
      paper: Prisma.$paperPayload<ExtArgs>[]
      proposal: Prisma.$proposalPayload<ExtArgs>[]
      reviewer: Prisma.$reviewerPayload<ExtArgs> | null
      department: Prisma.$departmentPayload<ExtArgs> | null
      user: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      teacher_id: number
      designation: string | null
      department_id: number | null
      user_id: number | null
      isReviewer: boolean
    }, ExtArgs["result"]["teacher"]>
    composites: {}
  }

  type teacherGetPayload<S extends boolean | null | undefined | teacherDefaultArgs> = $Result.GetResult<Prisma.$teacherPayload, S>

  type teacherCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<teacherFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeacherCountAggregateInputType | true
    }

  export interface teacherDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['teacher'], meta: { name: 'teacher' } }
    /**
     * Find zero or one Teacher that matches the filter.
     * @param {teacherFindUniqueArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends teacherFindUniqueArgs>(args: SelectSubset<T, teacherFindUniqueArgs<ExtArgs>>): Prisma__teacherClient<$Result.GetResult<Prisma.$teacherPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Teacher that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {teacherFindUniqueOrThrowArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends teacherFindUniqueOrThrowArgs>(args: SelectSubset<T, teacherFindUniqueOrThrowArgs<ExtArgs>>): Prisma__teacherClient<$Result.GetResult<Prisma.$teacherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Teacher that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teacherFindFirstArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends teacherFindFirstArgs>(args?: SelectSubset<T, teacherFindFirstArgs<ExtArgs>>): Prisma__teacherClient<$Result.GetResult<Prisma.$teacherPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Teacher that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teacherFindFirstOrThrowArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends teacherFindFirstOrThrowArgs>(args?: SelectSubset<T, teacherFindFirstOrThrowArgs<ExtArgs>>): Prisma__teacherClient<$Result.GetResult<Prisma.$teacherPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teachers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teacherFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teachers
     * const teachers = await prisma.teacher.findMany()
     * 
     * // Get first 10 Teachers
     * const teachers = await prisma.teacher.findMany({ take: 10 })
     * 
     * // Only select the `teacher_id`
     * const teacherWithTeacher_idOnly = await prisma.teacher.findMany({ select: { teacher_id: true } })
     * 
     */
    findMany<T extends teacherFindManyArgs>(args?: SelectSubset<T, teacherFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teacherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Teacher.
     * @param {teacherCreateArgs} args - Arguments to create a Teacher.
     * @example
     * // Create one Teacher
     * const Teacher = await prisma.teacher.create({
     *   data: {
     *     // ... data to create a Teacher
     *   }
     * })
     * 
     */
    create<T extends teacherCreateArgs>(args: SelectSubset<T, teacherCreateArgs<ExtArgs>>): Prisma__teacherClient<$Result.GetResult<Prisma.$teacherPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teachers.
     * @param {teacherCreateManyArgs} args - Arguments to create many Teachers.
     * @example
     * // Create many Teachers
     * const teacher = await prisma.teacher.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends teacherCreateManyArgs>(args?: SelectSubset<T, teacherCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teachers and returns the data saved in the database.
     * @param {teacherCreateManyAndReturnArgs} args - Arguments to create many Teachers.
     * @example
     * // Create many Teachers
     * const teacher = await prisma.teacher.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teachers and only return the `teacher_id`
     * const teacherWithTeacher_idOnly = await prisma.teacher.createManyAndReturn({
     *   select: { teacher_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends teacherCreateManyAndReturnArgs>(args?: SelectSubset<T, teacherCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teacherPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Teacher.
     * @param {teacherDeleteArgs} args - Arguments to delete one Teacher.
     * @example
     * // Delete one Teacher
     * const Teacher = await prisma.teacher.delete({
     *   where: {
     *     // ... filter to delete one Teacher
     *   }
     * })
     * 
     */
    delete<T extends teacherDeleteArgs>(args: SelectSubset<T, teacherDeleteArgs<ExtArgs>>): Prisma__teacherClient<$Result.GetResult<Prisma.$teacherPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Teacher.
     * @param {teacherUpdateArgs} args - Arguments to update one Teacher.
     * @example
     * // Update one Teacher
     * const teacher = await prisma.teacher.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends teacherUpdateArgs>(args: SelectSubset<T, teacherUpdateArgs<ExtArgs>>): Prisma__teacherClient<$Result.GetResult<Prisma.$teacherPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teachers.
     * @param {teacherDeleteManyArgs} args - Arguments to filter Teachers to delete.
     * @example
     * // Delete a few Teachers
     * const { count } = await prisma.teacher.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends teacherDeleteManyArgs>(args?: SelectSubset<T, teacherDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teacherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teachers
     * const teacher = await prisma.teacher.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends teacherUpdateManyArgs>(args: SelectSubset<T, teacherUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teachers and returns the data updated in the database.
     * @param {teacherUpdateManyAndReturnArgs} args - Arguments to update many Teachers.
     * @example
     * // Update many Teachers
     * const teacher = await prisma.teacher.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Teachers and only return the `teacher_id`
     * const teacherWithTeacher_idOnly = await prisma.teacher.updateManyAndReturn({
     *   select: { teacher_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends teacherUpdateManyAndReturnArgs>(args: SelectSubset<T, teacherUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teacherPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Teacher.
     * @param {teacherUpsertArgs} args - Arguments to update or create a Teacher.
     * @example
     * // Update or create a Teacher
     * const teacher = await prisma.teacher.upsert({
     *   create: {
     *     // ... data to create a Teacher
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Teacher we want to update
     *   }
     * })
     */
    upsert<T extends teacherUpsertArgs>(args: SelectSubset<T, teacherUpsertArgs<ExtArgs>>): Prisma__teacherClient<$Result.GetResult<Prisma.$teacherPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teacherCountArgs} args - Arguments to filter Teachers to count.
     * @example
     * // Count the number of Teachers
     * const count = await prisma.teacher.count({
     *   where: {
     *     // ... the filter for the Teachers we want to count
     *   }
     * })
    **/
    count<T extends teacherCountArgs>(
      args?: Subset<T, teacherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeacherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Teacher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeacherAggregateArgs>(args: Subset<T, TeacherAggregateArgs>): Prisma.PrismaPromise<GetTeacherAggregateType<T>>

    /**
     * Group by Teacher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teacherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends teacherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: teacherGroupByArgs['orderBy'] }
        : { orderBy?: teacherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, teacherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeacherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the teacher model
   */
  readonly fields: teacherFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for teacher.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__teacherClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    paper<T extends teacher$paperArgs<ExtArgs> = {}>(args?: Subset<T, teacher$paperArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paperPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    proposal<T extends teacher$proposalArgs<ExtArgs> = {}>(args?: Subset<T, teacher$proposalArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$proposalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviewer<T extends teacher$reviewerArgs<ExtArgs> = {}>(args?: Subset<T, teacher$reviewerArgs<ExtArgs>>): Prisma__reviewerClient<$Result.GetResult<Prisma.$reviewerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    department<T extends teacher$departmentArgs<ExtArgs> = {}>(args?: Subset<T, teacher$departmentArgs<ExtArgs>>): Prisma__departmentClient<$Result.GetResult<Prisma.$departmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends teacher$userArgs<ExtArgs> = {}>(args?: Subset<T, teacher$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the teacher model
   */
  interface teacherFieldRefs {
    readonly teacher_id: FieldRef<"teacher", 'Int'>
    readonly designation: FieldRef<"teacher", 'String'>
    readonly department_id: FieldRef<"teacher", 'Int'>
    readonly user_id: FieldRef<"teacher", 'Int'>
    readonly isReviewer: FieldRef<"teacher", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * teacher findUnique
   */
  export type teacherFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher
     */
    select?: teacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher
     */
    omit?: teacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacherInclude<ExtArgs> | null
    /**
     * Filter, which teacher to fetch.
     */
    where: teacherWhereUniqueInput
  }

  /**
   * teacher findUniqueOrThrow
   */
  export type teacherFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher
     */
    select?: teacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher
     */
    omit?: teacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacherInclude<ExtArgs> | null
    /**
     * Filter, which teacher to fetch.
     */
    where: teacherWhereUniqueInput
  }

  /**
   * teacher findFirst
   */
  export type teacherFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher
     */
    select?: teacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher
     */
    omit?: teacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacherInclude<ExtArgs> | null
    /**
     * Filter, which teacher to fetch.
     */
    where?: teacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teachers to fetch.
     */
    orderBy?: teacherOrderByWithRelationInput | teacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for teachers.
     */
    cursor?: teacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of teachers.
     */
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * teacher findFirstOrThrow
   */
  export type teacherFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher
     */
    select?: teacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher
     */
    omit?: teacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacherInclude<ExtArgs> | null
    /**
     * Filter, which teacher to fetch.
     */
    where?: teacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teachers to fetch.
     */
    orderBy?: teacherOrderByWithRelationInput | teacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for teachers.
     */
    cursor?: teacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of teachers.
     */
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * teacher findMany
   */
  export type teacherFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher
     */
    select?: teacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher
     */
    omit?: teacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacherInclude<ExtArgs> | null
    /**
     * Filter, which teachers to fetch.
     */
    where?: teacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teachers to fetch.
     */
    orderBy?: teacherOrderByWithRelationInput | teacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing teachers.
     */
    cursor?: teacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teachers.
     */
    skip?: number
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * teacher create
   */
  export type teacherCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher
     */
    select?: teacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher
     */
    omit?: teacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacherInclude<ExtArgs> | null
    /**
     * The data needed to create a teacher.
     */
    data?: XOR<teacherCreateInput, teacherUncheckedCreateInput>
  }

  /**
   * teacher createMany
   */
  export type teacherCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many teachers.
     */
    data: teacherCreateManyInput | teacherCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * teacher createManyAndReturn
   */
  export type teacherCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher
     */
    select?: teacherSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the teacher
     */
    omit?: teacherOmit<ExtArgs> | null
    /**
     * The data used to create many teachers.
     */
    data: teacherCreateManyInput | teacherCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacherIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * teacher update
   */
  export type teacherUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher
     */
    select?: teacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher
     */
    omit?: teacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacherInclude<ExtArgs> | null
    /**
     * The data needed to update a teacher.
     */
    data: XOR<teacherUpdateInput, teacherUncheckedUpdateInput>
    /**
     * Choose, which teacher to update.
     */
    where: teacherWhereUniqueInput
  }

  /**
   * teacher updateMany
   */
  export type teacherUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update teachers.
     */
    data: XOR<teacherUpdateManyMutationInput, teacherUncheckedUpdateManyInput>
    /**
     * Filter which teachers to update
     */
    where?: teacherWhereInput
    /**
     * Limit how many teachers to update.
     */
    limit?: number
  }

  /**
   * teacher updateManyAndReturn
   */
  export type teacherUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher
     */
    select?: teacherSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the teacher
     */
    omit?: teacherOmit<ExtArgs> | null
    /**
     * The data used to update teachers.
     */
    data: XOR<teacherUpdateManyMutationInput, teacherUncheckedUpdateManyInput>
    /**
     * Filter which teachers to update
     */
    where?: teacherWhereInput
    /**
     * Limit how many teachers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacherIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * teacher upsert
   */
  export type teacherUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher
     */
    select?: teacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher
     */
    omit?: teacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacherInclude<ExtArgs> | null
    /**
     * The filter to search for the teacher to update in case it exists.
     */
    where: teacherWhereUniqueInput
    /**
     * In case the teacher found by the `where` argument doesn't exist, create a new teacher with this data.
     */
    create: XOR<teacherCreateInput, teacherUncheckedCreateInput>
    /**
     * In case the teacher was found with the provided `where` argument, update it with this data.
     */
    update: XOR<teacherUpdateInput, teacherUncheckedUpdateInput>
  }

  /**
   * teacher delete
   */
  export type teacherDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher
     */
    select?: teacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher
     */
    omit?: teacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacherInclude<ExtArgs> | null
    /**
     * Filter which teacher to delete.
     */
    where: teacherWhereUniqueInput
  }

  /**
   * teacher deleteMany
   */
  export type teacherDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which teachers to delete
     */
    where?: teacherWhereInput
    /**
     * Limit how many teachers to delete.
     */
    limit?: number
  }

  /**
   * teacher.paper
   */
  export type teacher$paperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paper
     */
    select?: paperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paper
     */
    omit?: paperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paperInclude<ExtArgs> | null
    where?: paperWhereInput
    orderBy?: paperOrderByWithRelationInput | paperOrderByWithRelationInput[]
    cursor?: paperWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaperScalarFieldEnum | PaperScalarFieldEnum[]
  }

  /**
   * teacher.proposal
   */
  export type teacher$proposalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proposal
     */
    select?: proposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proposal
     */
    omit?: proposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proposalInclude<ExtArgs> | null
    where?: proposalWhereInput
    orderBy?: proposalOrderByWithRelationInput | proposalOrderByWithRelationInput[]
    cursor?: proposalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProposalScalarFieldEnum | ProposalScalarFieldEnum[]
  }

  /**
   * teacher.reviewer
   */
  export type teacher$reviewerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewer
     */
    select?: reviewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewer
     */
    omit?: reviewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewerInclude<ExtArgs> | null
    where?: reviewerWhereInput
  }

  /**
   * teacher.department
   */
  export type teacher$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the department
     */
    omit?: departmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentInclude<ExtArgs> | null
    where?: departmentWhereInput
  }

  /**
   * teacher.user
   */
  export type teacher$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * teacher without action
   */
  export type teacherDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher
     */
    select?: teacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher
     */
    omit?: teacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacherInclude<ExtArgs> | null
  }


  /**
   * Model reviewer
   */

  export type AggregateReviewer = {
    _count: ReviewerCountAggregateOutputType | null
    _avg: ReviewerAvgAggregateOutputType | null
    _sum: ReviewerSumAggregateOutputType | null
    _min: ReviewerMinAggregateOutputType | null
    _max: ReviewerMaxAggregateOutputType | null
  }

  export type ReviewerAvgAggregateOutputType = {
    reviewer_id: number | null
    teacher_id: number | null
  }

  export type ReviewerSumAggregateOutputType = {
    reviewer_id: number | null
    teacher_id: number | null
  }

  export type ReviewerMinAggregateOutputType = {
    reviewer_id: number | null
    teacher_id: number | null
    status: $Enums.ReviewerStatus | null
  }

  export type ReviewerMaxAggregateOutputType = {
    reviewer_id: number | null
    teacher_id: number | null
    status: $Enums.ReviewerStatus | null
  }

  export type ReviewerCountAggregateOutputType = {
    reviewer_id: number
    teacher_id: number
    status: number
    _all: number
  }


  export type ReviewerAvgAggregateInputType = {
    reviewer_id?: true
    teacher_id?: true
  }

  export type ReviewerSumAggregateInputType = {
    reviewer_id?: true
    teacher_id?: true
  }

  export type ReviewerMinAggregateInputType = {
    reviewer_id?: true
    teacher_id?: true
    status?: true
  }

  export type ReviewerMaxAggregateInputType = {
    reviewer_id?: true
    teacher_id?: true
    status?: true
  }

  export type ReviewerCountAggregateInputType = {
    reviewer_id?: true
    teacher_id?: true
    status?: true
    _all?: true
  }

  export type ReviewerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reviewer to aggregate.
     */
    where?: reviewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviewers to fetch.
     */
    orderBy?: reviewerOrderByWithRelationInput | reviewerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: reviewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviewers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviewers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reviewers
    **/
    _count?: true | ReviewerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewerMaxAggregateInputType
  }

  export type GetReviewerAggregateType<T extends ReviewerAggregateArgs> = {
        [P in keyof T & keyof AggregateReviewer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReviewer[P]>
      : GetScalarType<T[P], AggregateReviewer[P]>
  }




  export type reviewerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reviewerWhereInput
    orderBy?: reviewerOrderByWithAggregationInput | reviewerOrderByWithAggregationInput[]
    by: ReviewerScalarFieldEnum[] | ReviewerScalarFieldEnum
    having?: reviewerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewerCountAggregateInputType | true
    _avg?: ReviewerAvgAggregateInputType
    _sum?: ReviewerSumAggregateInputType
    _min?: ReviewerMinAggregateInputType
    _max?: ReviewerMaxAggregateInputType
  }

  export type ReviewerGroupByOutputType = {
    reviewer_id: number
    teacher_id: number | null
    status: $Enums.ReviewerStatus | null
    _count: ReviewerCountAggregateOutputType | null
    _avg: ReviewerAvgAggregateOutputType | null
    _sum: ReviewerSumAggregateOutputType | null
    _min: ReviewerMinAggregateOutputType | null
    _max: ReviewerMaxAggregateOutputType | null
  }

  type GetReviewerGroupByPayload<T extends reviewerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewerGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewerGroupByOutputType[P]>
        }
      >
    >


  export type reviewerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    reviewer_id?: boolean
    teacher_id?: boolean
    status?: boolean
    review?: boolean | reviewer$reviewArgs<ExtArgs>
    teacher?: boolean | reviewer$teacherArgs<ExtArgs>
    reviewerassignment?: boolean | reviewer$reviewerassignmentArgs<ExtArgs>
    _count?: boolean | ReviewerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewer"]>

  export type reviewerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    reviewer_id?: boolean
    teacher_id?: boolean
    status?: boolean
    teacher?: boolean | reviewer$teacherArgs<ExtArgs>
  }, ExtArgs["result"]["reviewer"]>

  export type reviewerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    reviewer_id?: boolean
    teacher_id?: boolean
    status?: boolean
    teacher?: boolean | reviewer$teacherArgs<ExtArgs>
  }, ExtArgs["result"]["reviewer"]>

  export type reviewerSelectScalar = {
    reviewer_id?: boolean
    teacher_id?: boolean
    status?: boolean
  }

  export type reviewerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"reviewer_id" | "teacher_id" | "status", ExtArgs["result"]["reviewer"]>
  export type reviewerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | reviewer$reviewArgs<ExtArgs>
    teacher?: boolean | reviewer$teacherArgs<ExtArgs>
    reviewerassignment?: boolean | reviewer$reviewerassignmentArgs<ExtArgs>
    _count?: boolean | ReviewerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type reviewerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | reviewer$teacherArgs<ExtArgs>
  }
  export type reviewerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | reviewer$teacherArgs<ExtArgs>
  }

  export type $reviewerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "reviewer"
    objects: {
      review: Prisma.$reviewPayload<ExtArgs>[]
      teacher: Prisma.$teacherPayload<ExtArgs> | null
      reviewerassignment: Prisma.$reviewerassignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      reviewer_id: number
      teacher_id: number | null
      status: $Enums.ReviewerStatus | null
    }, ExtArgs["result"]["reviewer"]>
    composites: {}
  }

  type reviewerGetPayload<S extends boolean | null | undefined | reviewerDefaultArgs> = $Result.GetResult<Prisma.$reviewerPayload, S>

  type reviewerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<reviewerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewerCountAggregateInputType | true
    }

  export interface reviewerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['reviewer'], meta: { name: 'reviewer' } }
    /**
     * Find zero or one Reviewer that matches the filter.
     * @param {reviewerFindUniqueArgs} args - Arguments to find a Reviewer
     * @example
     * // Get one Reviewer
     * const reviewer = await prisma.reviewer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends reviewerFindUniqueArgs>(args: SelectSubset<T, reviewerFindUniqueArgs<ExtArgs>>): Prisma__reviewerClient<$Result.GetResult<Prisma.$reviewerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Reviewer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {reviewerFindUniqueOrThrowArgs} args - Arguments to find a Reviewer
     * @example
     * // Get one Reviewer
     * const reviewer = await prisma.reviewer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends reviewerFindUniqueOrThrowArgs>(args: SelectSubset<T, reviewerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__reviewerClient<$Result.GetResult<Prisma.$reviewerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reviewer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewerFindFirstArgs} args - Arguments to find a Reviewer
     * @example
     * // Get one Reviewer
     * const reviewer = await prisma.reviewer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends reviewerFindFirstArgs>(args?: SelectSubset<T, reviewerFindFirstArgs<ExtArgs>>): Prisma__reviewerClient<$Result.GetResult<Prisma.$reviewerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reviewer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewerFindFirstOrThrowArgs} args - Arguments to find a Reviewer
     * @example
     * // Get one Reviewer
     * const reviewer = await prisma.reviewer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends reviewerFindFirstOrThrowArgs>(args?: SelectSubset<T, reviewerFindFirstOrThrowArgs<ExtArgs>>): Prisma__reviewerClient<$Result.GetResult<Prisma.$reviewerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reviewers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviewers
     * const reviewers = await prisma.reviewer.findMany()
     * 
     * // Get first 10 Reviewers
     * const reviewers = await prisma.reviewer.findMany({ take: 10 })
     * 
     * // Only select the `reviewer_id`
     * const reviewerWithReviewer_idOnly = await prisma.reviewer.findMany({ select: { reviewer_id: true } })
     * 
     */
    findMany<T extends reviewerFindManyArgs>(args?: SelectSubset<T, reviewerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Reviewer.
     * @param {reviewerCreateArgs} args - Arguments to create a Reviewer.
     * @example
     * // Create one Reviewer
     * const Reviewer = await prisma.reviewer.create({
     *   data: {
     *     // ... data to create a Reviewer
     *   }
     * })
     * 
     */
    create<T extends reviewerCreateArgs>(args: SelectSubset<T, reviewerCreateArgs<ExtArgs>>): Prisma__reviewerClient<$Result.GetResult<Prisma.$reviewerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reviewers.
     * @param {reviewerCreateManyArgs} args - Arguments to create many Reviewers.
     * @example
     * // Create many Reviewers
     * const reviewer = await prisma.reviewer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends reviewerCreateManyArgs>(args?: SelectSubset<T, reviewerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviewers and returns the data saved in the database.
     * @param {reviewerCreateManyAndReturnArgs} args - Arguments to create many Reviewers.
     * @example
     * // Create many Reviewers
     * const reviewer = await prisma.reviewer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviewers and only return the `reviewer_id`
     * const reviewerWithReviewer_idOnly = await prisma.reviewer.createManyAndReturn({
     *   select: { reviewer_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends reviewerCreateManyAndReturnArgs>(args?: SelectSubset<T, reviewerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Reviewer.
     * @param {reviewerDeleteArgs} args - Arguments to delete one Reviewer.
     * @example
     * // Delete one Reviewer
     * const Reviewer = await prisma.reviewer.delete({
     *   where: {
     *     // ... filter to delete one Reviewer
     *   }
     * })
     * 
     */
    delete<T extends reviewerDeleteArgs>(args: SelectSubset<T, reviewerDeleteArgs<ExtArgs>>): Prisma__reviewerClient<$Result.GetResult<Prisma.$reviewerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Reviewer.
     * @param {reviewerUpdateArgs} args - Arguments to update one Reviewer.
     * @example
     * // Update one Reviewer
     * const reviewer = await prisma.reviewer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends reviewerUpdateArgs>(args: SelectSubset<T, reviewerUpdateArgs<ExtArgs>>): Prisma__reviewerClient<$Result.GetResult<Prisma.$reviewerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reviewers.
     * @param {reviewerDeleteManyArgs} args - Arguments to filter Reviewers to delete.
     * @example
     * // Delete a few Reviewers
     * const { count } = await prisma.reviewer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends reviewerDeleteManyArgs>(args?: SelectSubset<T, reviewerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviewers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviewers
     * const reviewer = await prisma.reviewer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends reviewerUpdateManyArgs>(args: SelectSubset<T, reviewerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviewers and returns the data updated in the database.
     * @param {reviewerUpdateManyAndReturnArgs} args - Arguments to update many Reviewers.
     * @example
     * // Update many Reviewers
     * const reviewer = await prisma.reviewer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reviewers and only return the `reviewer_id`
     * const reviewerWithReviewer_idOnly = await prisma.reviewer.updateManyAndReturn({
     *   select: { reviewer_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends reviewerUpdateManyAndReturnArgs>(args: SelectSubset<T, reviewerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Reviewer.
     * @param {reviewerUpsertArgs} args - Arguments to update or create a Reviewer.
     * @example
     * // Update or create a Reviewer
     * const reviewer = await prisma.reviewer.upsert({
     *   create: {
     *     // ... data to create a Reviewer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reviewer we want to update
     *   }
     * })
     */
    upsert<T extends reviewerUpsertArgs>(args: SelectSubset<T, reviewerUpsertArgs<ExtArgs>>): Prisma__reviewerClient<$Result.GetResult<Prisma.$reviewerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reviewers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewerCountArgs} args - Arguments to filter Reviewers to count.
     * @example
     * // Count the number of Reviewers
     * const count = await prisma.reviewer.count({
     *   where: {
     *     // ... the filter for the Reviewers we want to count
     *   }
     * })
    **/
    count<T extends reviewerCountArgs>(
      args?: Subset<T, reviewerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reviewer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewerAggregateArgs>(args: Subset<T, ReviewerAggregateArgs>): Prisma.PrismaPromise<GetReviewerAggregateType<T>>

    /**
     * Group by Reviewer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends reviewerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: reviewerGroupByArgs['orderBy'] }
        : { orderBy?: reviewerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, reviewerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the reviewer model
   */
  readonly fields: reviewerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for reviewer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__reviewerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    review<T extends reviewer$reviewArgs<ExtArgs> = {}>(args?: Subset<T, reviewer$reviewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teacher<T extends reviewer$teacherArgs<ExtArgs> = {}>(args?: Subset<T, reviewer$teacherArgs<ExtArgs>>): Prisma__teacherClient<$Result.GetResult<Prisma.$teacherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    reviewerassignment<T extends reviewer$reviewerassignmentArgs<ExtArgs> = {}>(args?: Subset<T, reviewer$reviewerassignmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewerassignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the reviewer model
   */
  interface reviewerFieldRefs {
    readonly reviewer_id: FieldRef<"reviewer", 'Int'>
    readonly teacher_id: FieldRef<"reviewer", 'Int'>
    readonly status: FieldRef<"reviewer", 'ReviewerStatus'>
  }
    

  // Custom InputTypes
  /**
   * reviewer findUnique
   */
  export type reviewerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewer
     */
    select?: reviewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewer
     */
    omit?: reviewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewerInclude<ExtArgs> | null
    /**
     * Filter, which reviewer to fetch.
     */
    where: reviewerWhereUniqueInput
  }

  /**
   * reviewer findUniqueOrThrow
   */
  export type reviewerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewer
     */
    select?: reviewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewer
     */
    omit?: reviewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewerInclude<ExtArgs> | null
    /**
     * Filter, which reviewer to fetch.
     */
    where: reviewerWhereUniqueInput
  }

  /**
   * reviewer findFirst
   */
  export type reviewerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewer
     */
    select?: reviewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewer
     */
    omit?: reviewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewerInclude<ExtArgs> | null
    /**
     * Filter, which reviewer to fetch.
     */
    where?: reviewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviewers to fetch.
     */
    orderBy?: reviewerOrderByWithRelationInput | reviewerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reviewers.
     */
    cursor?: reviewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviewers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviewers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reviewers.
     */
    distinct?: ReviewerScalarFieldEnum | ReviewerScalarFieldEnum[]
  }

  /**
   * reviewer findFirstOrThrow
   */
  export type reviewerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewer
     */
    select?: reviewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewer
     */
    omit?: reviewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewerInclude<ExtArgs> | null
    /**
     * Filter, which reviewer to fetch.
     */
    where?: reviewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviewers to fetch.
     */
    orderBy?: reviewerOrderByWithRelationInput | reviewerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reviewers.
     */
    cursor?: reviewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviewers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviewers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reviewers.
     */
    distinct?: ReviewerScalarFieldEnum | ReviewerScalarFieldEnum[]
  }

  /**
   * reviewer findMany
   */
  export type reviewerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewer
     */
    select?: reviewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewer
     */
    omit?: reviewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewerInclude<ExtArgs> | null
    /**
     * Filter, which reviewers to fetch.
     */
    where?: reviewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviewers to fetch.
     */
    orderBy?: reviewerOrderByWithRelationInput | reviewerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reviewers.
     */
    cursor?: reviewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviewers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviewers.
     */
    skip?: number
    distinct?: ReviewerScalarFieldEnum | ReviewerScalarFieldEnum[]
  }

  /**
   * reviewer create
   */
  export type reviewerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewer
     */
    select?: reviewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewer
     */
    omit?: reviewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewerInclude<ExtArgs> | null
    /**
     * The data needed to create a reviewer.
     */
    data?: XOR<reviewerCreateInput, reviewerUncheckedCreateInput>
  }

  /**
   * reviewer createMany
   */
  export type reviewerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many reviewers.
     */
    data: reviewerCreateManyInput | reviewerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * reviewer createManyAndReturn
   */
  export type reviewerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewer
     */
    select?: reviewerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the reviewer
     */
    omit?: reviewerOmit<ExtArgs> | null
    /**
     * The data used to create many reviewers.
     */
    data: reviewerCreateManyInput | reviewerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * reviewer update
   */
  export type reviewerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewer
     */
    select?: reviewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewer
     */
    omit?: reviewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewerInclude<ExtArgs> | null
    /**
     * The data needed to update a reviewer.
     */
    data: XOR<reviewerUpdateInput, reviewerUncheckedUpdateInput>
    /**
     * Choose, which reviewer to update.
     */
    where: reviewerWhereUniqueInput
  }

  /**
   * reviewer updateMany
   */
  export type reviewerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update reviewers.
     */
    data: XOR<reviewerUpdateManyMutationInput, reviewerUncheckedUpdateManyInput>
    /**
     * Filter which reviewers to update
     */
    where?: reviewerWhereInput
    /**
     * Limit how many reviewers to update.
     */
    limit?: number
  }

  /**
   * reviewer updateManyAndReturn
   */
  export type reviewerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewer
     */
    select?: reviewerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the reviewer
     */
    omit?: reviewerOmit<ExtArgs> | null
    /**
     * The data used to update reviewers.
     */
    data: XOR<reviewerUpdateManyMutationInput, reviewerUncheckedUpdateManyInput>
    /**
     * Filter which reviewers to update
     */
    where?: reviewerWhereInput
    /**
     * Limit how many reviewers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * reviewer upsert
   */
  export type reviewerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewer
     */
    select?: reviewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewer
     */
    omit?: reviewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewerInclude<ExtArgs> | null
    /**
     * The filter to search for the reviewer to update in case it exists.
     */
    where: reviewerWhereUniqueInput
    /**
     * In case the reviewer found by the `where` argument doesn't exist, create a new reviewer with this data.
     */
    create: XOR<reviewerCreateInput, reviewerUncheckedCreateInput>
    /**
     * In case the reviewer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<reviewerUpdateInput, reviewerUncheckedUpdateInput>
  }

  /**
   * reviewer delete
   */
  export type reviewerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewer
     */
    select?: reviewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewer
     */
    omit?: reviewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewerInclude<ExtArgs> | null
    /**
     * Filter which reviewer to delete.
     */
    where: reviewerWhereUniqueInput
  }

  /**
   * reviewer deleteMany
   */
  export type reviewerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reviewers to delete
     */
    where?: reviewerWhereInput
    /**
     * Limit how many reviewers to delete.
     */
    limit?: number
  }

  /**
   * reviewer.review
   */
  export type reviewer$reviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review
     */
    select?: reviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the review
     */
    omit?: reviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewInclude<ExtArgs> | null
    where?: reviewWhereInput
    orderBy?: reviewOrderByWithRelationInput | reviewOrderByWithRelationInput[]
    cursor?: reviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * reviewer.teacher
   */
  export type reviewer$teacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher
     */
    select?: teacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher
     */
    omit?: teacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacherInclude<ExtArgs> | null
    where?: teacherWhereInput
  }

  /**
   * reviewer.reviewerassignment
   */
  export type reviewer$reviewerassignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewerassignment
     */
    select?: reviewerassignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewerassignment
     */
    omit?: reviewerassignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewerassignmentInclude<ExtArgs> | null
    where?: reviewerassignmentWhereInput
    orderBy?: reviewerassignmentOrderByWithRelationInput | reviewerassignmentOrderByWithRelationInput[]
    cursor?: reviewerassignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewerassignmentScalarFieldEnum | ReviewerassignmentScalarFieldEnum[]
  }

  /**
   * reviewer without action
   */
  export type reviewerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewer
     */
    select?: reviewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewer
     */
    omit?: reviewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewerInclude<ExtArgs> | null
  }


  /**
   * Model team
   */

  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamAvgAggregateOutputType = {
    team_id: number | null
    domain_id: number | null
    max_members: number | null
    created_by_user_id: number | null
  }

  export type TeamSumAggregateOutputType = {
    team_id: number | null
    domain_id: number | null
    max_members: number | null
    created_by_user_id: number | null
  }

  export type TeamMinAggregateOutputType = {
    team_id: number | null
    team_name: string | null
    team_description: string | null
    domain_id: number | null
    status: $Enums.TeamStatus | null
    visibility: $Enums.TeamVisibility | null
    max_members: number | null
    isHiring: boolean | null
    created_at: Date | null
    created_by_user_id: number | null
  }

  export type TeamMaxAggregateOutputType = {
    team_id: number | null
    team_name: string | null
    team_description: string | null
    domain_id: number | null
    status: $Enums.TeamStatus | null
    visibility: $Enums.TeamVisibility | null
    max_members: number | null
    isHiring: boolean | null
    created_at: Date | null
    created_by_user_id: number | null
  }

  export type TeamCountAggregateOutputType = {
    team_id: number
    team_name: number
    team_description: number
    domain_id: number
    status: number
    visibility: number
    max_members: number
    isHiring: number
    created_at: number
    created_by_user_id: number
    _all: number
  }


  export type TeamAvgAggregateInputType = {
    team_id?: true
    domain_id?: true
    max_members?: true
    created_by_user_id?: true
  }

  export type TeamSumAggregateInputType = {
    team_id?: true
    domain_id?: true
    max_members?: true
    created_by_user_id?: true
  }

  export type TeamMinAggregateInputType = {
    team_id?: true
    team_name?: true
    team_description?: true
    domain_id?: true
    status?: true
    visibility?: true
    max_members?: true
    isHiring?: true
    created_at?: true
    created_by_user_id?: true
  }

  export type TeamMaxAggregateInputType = {
    team_id?: true
    team_name?: true
    team_description?: true
    domain_id?: true
    status?: true
    visibility?: true
    max_members?: true
    isHiring?: true
    created_at?: true
    created_by_user_id?: true
  }

  export type TeamCountAggregateInputType = {
    team_id?: true
    team_name?: true
    team_description?: true
    domain_id?: true
    status?: true
    visibility?: true
    max_members?: true
    isHiring?: true
    created_at?: true
    created_by_user_id?: true
    _all?: true
  }

  export type TeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which team to aggregate.
     */
    where?: teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teams to fetch.
     */
    orderBy?: teamOrderByWithRelationInput | teamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type teamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teamWhereInput
    orderBy?: teamOrderByWithAggregationInput | teamOrderByWithAggregationInput[]
    by: TeamScalarFieldEnum[] | TeamScalarFieldEnum
    having?: teamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _avg?: TeamAvgAggregateInputType
    _sum?: TeamSumAggregateInputType
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }

  export type TeamGroupByOutputType = {
    team_id: number
    team_name: string | null
    team_description: string | null
    domain_id: number | null
    status: $Enums.TeamStatus | null
    visibility: $Enums.TeamVisibility | null
    max_members: number | null
    isHiring: boolean | null
    created_at: Date
    created_by_user_id: number | null
    _count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends teamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type teamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    team_id?: boolean
    team_name?: boolean
    team_description?: boolean
    domain_id?: boolean
    status?: boolean
    visibility?: boolean
    max_members?: boolean
    isHiring?: boolean
    created_at?: boolean
    created_by_user_id?: boolean
    paper?: boolean | team$paperArgs<ExtArgs>
    proposal?: boolean | team$proposalArgs<ExtArgs>
    created_by_user?: boolean | team$created_by_userArgs<ExtArgs>
    domain?: boolean | team$domainArgs<ExtArgs>
    teamapplication?: boolean | team$teamapplicationArgs<ExtArgs>
    teamcomment?: boolean | team$teamcommentArgs<ExtArgs>
    teammember?: boolean | team$teammemberArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type teamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    team_id?: boolean
    team_name?: boolean
    team_description?: boolean
    domain_id?: boolean
    status?: boolean
    visibility?: boolean
    max_members?: boolean
    isHiring?: boolean
    created_at?: boolean
    created_by_user_id?: boolean
    created_by_user?: boolean | team$created_by_userArgs<ExtArgs>
    domain?: boolean | team$domainArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type teamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    team_id?: boolean
    team_name?: boolean
    team_description?: boolean
    domain_id?: boolean
    status?: boolean
    visibility?: boolean
    max_members?: boolean
    isHiring?: boolean
    created_at?: boolean
    created_by_user_id?: boolean
    created_by_user?: boolean | team$created_by_userArgs<ExtArgs>
    domain?: boolean | team$domainArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type teamSelectScalar = {
    team_id?: boolean
    team_name?: boolean
    team_description?: boolean
    domain_id?: boolean
    status?: boolean
    visibility?: boolean
    max_members?: boolean
    isHiring?: boolean
    created_at?: boolean
    created_by_user_id?: boolean
  }

  export type teamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"team_id" | "team_name" | "team_description" | "domain_id" | "status" | "visibility" | "max_members" | "isHiring" | "created_at" | "created_by_user_id", ExtArgs["result"]["team"]>
  export type teamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paper?: boolean | team$paperArgs<ExtArgs>
    proposal?: boolean | team$proposalArgs<ExtArgs>
    created_by_user?: boolean | team$created_by_userArgs<ExtArgs>
    domain?: boolean | team$domainArgs<ExtArgs>
    teamapplication?: boolean | team$teamapplicationArgs<ExtArgs>
    teamcomment?: boolean | team$teamcommentArgs<ExtArgs>
    teammember?: boolean | team$teammemberArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type teamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    created_by_user?: boolean | team$created_by_userArgs<ExtArgs>
    domain?: boolean | team$domainArgs<ExtArgs>
  }
  export type teamIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    created_by_user?: boolean | team$created_by_userArgs<ExtArgs>
    domain?: boolean | team$domainArgs<ExtArgs>
  }

  export type $teamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "team"
    objects: {
      paper: Prisma.$paperPayload<ExtArgs>[]
      proposal: Prisma.$proposalPayload<ExtArgs>[]
      created_by_user: Prisma.$userPayload<ExtArgs> | null
      domain: Prisma.$domainPayload<ExtArgs> | null
      teamapplication: Prisma.$teamapplicationPayload<ExtArgs>[]
      teamcomment: Prisma.$teamcommentPayload<ExtArgs>[]
      teammember: Prisma.$teammemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      team_id: number
      team_name: string | null
      team_description: string | null
      domain_id: number | null
      status: $Enums.TeamStatus | null
      visibility: $Enums.TeamVisibility | null
      max_members: number | null
      isHiring: boolean | null
      created_at: Date
      created_by_user_id: number | null
    }, ExtArgs["result"]["team"]>
    composites: {}
  }

  type teamGetPayload<S extends boolean | null | undefined | teamDefaultArgs> = $Result.GetResult<Prisma.$teamPayload, S>

  type teamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<teamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamCountAggregateInputType | true
    }

  export interface teamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['team'], meta: { name: 'team' } }
    /**
     * Find zero or one Team that matches the filter.
     * @param {teamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends teamFindUniqueArgs>(args: SelectSubset<T, teamFindUniqueArgs<ExtArgs>>): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Team that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {teamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends teamFindUniqueOrThrowArgs>(args: SelectSubset<T, teamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends teamFindFirstArgs>(args?: SelectSubset<T, teamFindFirstArgs<ExtArgs>>): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends teamFindFirstOrThrowArgs>(args?: SelectSubset<T, teamFindFirstOrThrowArgs<ExtArgs>>): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `team_id`
     * const teamWithTeam_idOnly = await prisma.team.findMany({ select: { team_id: true } })
     * 
     */
    findMany<T extends teamFindManyArgs>(args?: SelectSubset<T, teamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Team.
     * @param {teamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
     */
    create<T extends teamCreateArgs>(args: SelectSubset<T, teamCreateArgs<ExtArgs>>): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teams.
     * @param {teamCreateManyArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends teamCreateManyArgs>(args?: SelectSubset<T, teamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teams and returns the data saved in the database.
     * @param {teamCreateManyAndReturnArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teams and only return the `team_id`
     * const teamWithTeam_idOnly = await prisma.team.createManyAndReturn({
     *   select: { team_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends teamCreateManyAndReturnArgs>(args?: SelectSubset<T, teamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Team.
     * @param {teamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
     */
    delete<T extends teamDeleteArgs>(args: SelectSubset<T, teamDeleteArgs<ExtArgs>>): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Team.
     * @param {teamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends teamUpdateArgs>(args: SelectSubset<T, teamUpdateArgs<ExtArgs>>): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teams.
     * @param {teamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends teamDeleteManyArgs>(args?: SelectSubset<T, teamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends teamUpdateManyArgs>(args: SelectSubset<T, teamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams and returns the data updated in the database.
     * @param {teamUpdateManyAndReturnArgs} args - Arguments to update many Teams.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Teams and only return the `team_id`
     * const teamWithTeam_idOnly = await prisma.team.updateManyAndReturn({
     *   select: { team_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends teamUpdateManyAndReturnArgs>(args: SelectSubset<T, teamUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Team.
     * @param {teamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
     */
    upsert<T extends teamUpsertArgs>(args: SelectSubset<T, teamUpsertArgs<ExtArgs>>): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends teamCountArgs>(
      args?: Subset<T, teamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Prisma.PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends teamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: teamGroupByArgs['orderBy'] }
        : { orderBy?: teamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, teamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the team model
   */
  readonly fields: teamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__teamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    paper<T extends team$paperArgs<ExtArgs> = {}>(args?: Subset<T, team$paperArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paperPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    proposal<T extends team$proposalArgs<ExtArgs> = {}>(args?: Subset<T, team$proposalArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$proposalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    created_by_user<T extends team$created_by_userArgs<ExtArgs> = {}>(args?: Subset<T, team$created_by_userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    domain<T extends team$domainArgs<ExtArgs> = {}>(args?: Subset<T, team$domainArgs<ExtArgs>>): Prisma__domainClient<$Result.GetResult<Prisma.$domainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    teamapplication<T extends team$teamapplicationArgs<ExtArgs> = {}>(args?: Subset<T, team$teamapplicationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teamapplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teamcomment<T extends team$teamcommentArgs<ExtArgs> = {}>(args?: Subset<T, team$teamcommentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teamcommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teammember<T extends team$teammemberArgs<ExtArgs> = {}>(args?: Subset<T, team$teammemberArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teammemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the team model
   */
  interface teamFieldRefs {
    readonly team_id: FieldRef<"team", 'Int'>
    readonly team_name: FieldRef<"team", 'String'>
    readonly team_description: FieldRef<"team", 'String'>
    readonly domain_id: FieldRef<"team", 'Int'>
    readonly status: FieldRef<"team", 'TeamStatus'>
    readonly visibility: FieldRef<"team", 'TeamVisibility'>
    readonly max_members: FieldRef<"team", 'Int'>
    readonly isHiring: FieldRef<"team", 'Boolean'>
    readonly created_at: FieldRef<"team", 'DateTime'>
    readonly created_by_user_id: FieldRef<"team", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * team findUnique
   */
  export type teamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the team
     */
    omit?: teamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * Filter, which team to fetch.
     */
    where: teamWhereUniqueInput
  }

  /**
   * team findUniqueOrThrow
   */
  export type teamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the team
     */
    omit?: teamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * Filter, which team to fetch.
     */
    where: teamWhereUniqueInput
  }

  /**
   * team findFirst
   */
  export type teamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the team
     */
    omit?: teamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * Filter, which team to fetch.
     */
    where?: teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teams to fetch.
     */
    orderBy?: teamOrderByWithRelationInput | teamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for teams.
     */
    cursor?: teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * team findFirstOrThrow
   */
  export type teamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the team
     */
    omit?: teamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * Filter, which team to fetch.
     */
    where?: teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teams to fetch.
     */
    orderBy?: teamOrderByWithRelationInput | teamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for teams.
     */
    cursor?: teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * team findMany
   */
  export type teamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the team
     */
    omit?: teamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * Filter, which teams to fetch.
     */
    where?: teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teams to fetch.
     */
    orderBy?: teamOrderByWithRelationInput | teamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing teams.
     */
    cursor?: teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teams.
     */
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * team create
   */
  export type teamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the team
     */
    omit?: teamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * The data needed to create a team.
     */
    data?: XOR<teamCreateInput, teamUncheckedCreateInput>
  }

  /**
   * team createMany
   */
  export type teamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many teams.
     */
    data: teamCreateManyInput | teamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * team createManyAndReturn
   */
  export type teamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the team
     */
    omit?: teamOmit<ExtArgs> | null
    /**
     * The data used to create many teams.
     */
    data: teamCreateManyInput | teamCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * team update
   */
  export type teamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the team
     */
    omit?: teamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * The data needed to update a team.
     */
    data: XOR<teamUpdateInput, teamUncheckedUpdateInput>
    /**
     * Choose, which team to update.
     */
    where: teamWhereUniqueInput
  }

  /**
   * team updateMany
   */
  export type teamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update teams.
     */
    data: XOR<teamUpdateManyMutationInput, teamUncheckedUpdateManyInput>
    /**
     * Filter which teams to update
     */
    where?: teamWhereInput
    /**
     * Limit how many teams to update.
     */
    limit?: number
  }

  /**
   * team updateManyAndReturn
   */
  export type teamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the team
     */
    omit?: teamOmit<ExtArgs> | null
    /**
     * The data used to update teams.
     */
    data: XOR<teamUpdateManyMutationInput, teamUncheckedUpdateManyInput>
    /**
     * Filter which teams to update
     */
    where?: teamWhereInput
    /**
     * Limit how many teams to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * team upsert
   */
  export type teamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the team
     */
    omit?: teamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * The filter to search for the team to update in case it exists.
     */
    where: teamWhereUniqueInput
    /**
     * In case the team found by the `where` argument doesn't exist, create a new team with this data.
     */
    create: XOR<teamCreateInput, teamUncheckedCreateInput>
    /**
     * In case the team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<teamUpdateInput, teamUncheckedUpdateInput>
  }

  /**
   * team delete
   */
  export type teamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the team
     */
    omit?: teamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * Filter which team to delete.
     */
    where: teamWhereUniqueInput
  }

  /**
   * team deleteMany
   */
  export type teamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which teams to delete
     */
    where?: teamWhereInput
    /**
     * Limit how many teams to delete.
     */
    limit?: number
  }

  /**
   * team.paper
   */
  export type team$paperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paper
     */
    select?: paperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paper
     */
    omit?: paperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paperInclude<ExtArgs> | null
    where?: paperWhereInput
    orderBy?: paperOrderByWithRelationInput | paperOrderByWithRelationInput[]
    cursor?: paperWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaperScalarFieldEnum | PaperScalarFieldEnum[]
  }

  /**
   * team.proposal
   */
  export type team$proposalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proposal
     */
    select?: proposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proposal
     */
    omit?: proposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proposalInclude<ExtArgs> | null
    where?: proposalWhereInput
    orderBy?: proposalOrderByWithRelationInput | proposalOrderByWithRelationInput[]
    cursor?: proposalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProposalScalarFieldEnum | ProposalScalarFieldEnum[]
  }

  /**
   * team.created_by_user
   */
  export type team$created_by_userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * team.domain
   */
  export type team$domainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the domain
     */
    select?: domainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the domain
     */
    omit?: domainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: domainInclude<ExtArgs> | null
    where?: domainWhereInput
  }

  /**
   * team.teamapplication
   */
  export type team$teamapplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teamapplication
     */
    select?: teamapplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teamapplication
     */
    omit?: teamapplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamapplicationInclude<ExtArgs> | null
    where?: teamapplicationWhereInput
    orderBy?: teamapplicationOrderByWithRelationInput | teamapplicationOrderByWithRelationInput[]
    cursor?: teamapplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamapplicationScalarFieldEnum | TeamapplicationScalarFieldEnum[]
  }

  /**
   * team.teamcomment
   */
  export type team$teamcommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teamcomment
     */
    select?: teamcommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teamcomment
     */
    omit?: teamcommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamcommentInclude<ExtArgs> | null
    where?: teamcommentWhereInput
    orderBy?: teamcommentOrderByWithRelationInput | teamcommentOrderByWithRelationInput[]
    cursor?: teamcommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamcommentScalarFieldEnum | TeamcommentScalarFieldEnum[]
  }

  /**
   * team.teammember
   */
  export type team$teammemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teammember
     */
    select?: teammemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teammember
     */
    omit?: teammemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teammemberInclude<ExtArgs> | null
    where?: teammemberWhereInput
    orderBy?: teammemberOrderByWithRelationInput | teammemberOrderByWithRelationInput[]
    cursor?: teammemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeammemberScalarFieldEnum | TeammemberScalarFieldEnum[]
  }

  /**
   * team without action
   */
  export type teamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the team
     */
    omit?: teamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamInclude<ExtArgs> | null
  }


  /**
   * Model teammember
   */

  export type AggregateTeammember = {
    _count: TeammemberCountAggregateOutputType | null
    _avg: TeammemberAvgAggregateOutputType | null
    _sum: TeammemberSumAggregateOutputType | null
    _min: TeammemberMinAggregateOutputType | null
    _max: TeammemberMaxAggregateOutputType | null
  }

  export type TeammemberAvgAggregateOutputType = {
    team_id: number | null
    user_id: number | null
  }

  export type TeammemberSumAggregateOutputType = {
    team_id: number | null
    user_id: number | null
  }

  export type TeammemberMinAggregateOutputType = {
    team_id: number | null
    user_id: number | null
    role_in_team: $Enums.TeamRole | null
  }

  export type TeammemberMaxAggregateOutputType = {
    team_id: number | null
    user_id: number | null
    role_in_team: $Enums.TeamRole | null
  }

  export type TeammemberCountAggregateOutputType = {
    team_id: number
    user_id: number
    role_in_team: number
    _all: number
  }


  export type TeammemberAvgAggregateInputType = {
    team_id?: true
    user_id?: true
  }

  export type TeammemberSumAggregateInputType = {
    team_id?: true
    user_id?: true
  }

  export type TeammemberMinAggregateInputType = {
    team_id?: true
    user_id?: true
    role_in_team?: true
  }

  export type TeammemberMaxAggregateInputType = {
    team_id?: true
    user_id?: true
    role_in_team?: true
  }

  export type TeammemberCountAggregateInputType = {
    team_id?: true
    user_id?: true
    role_in_team?: true
    _all?: true
  }

  export type TeammemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which teammember to aggregate.
     */
    where?: teammemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teammembers to fetch.
     */
    orderBy?: teammemberOrderByWithRelationInput | teammemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: teammemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teammembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teammembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned teammembers
    **/
    _count?: true | TeammemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeammemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeammemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeammemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeammemberMaxAggregateInputType
  }

  export type GetTeammemberAggregateType<T extends TeammemberAggregateArgs> = {
        [P in keyof T & keyof AggregateTeammember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeammember[P]>
      : GetScalarType<T[P], AggregateTeammember[P]>
  }




  export type teammemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teammemberWhereInput
    orderBy?: teammemberOrderByWithAggregationInput | teammemberOrderByWithAggregationInput[]
    by: TeammemberScalarFieldEnum[] | TeammemberScalarFieldEnum
    having?: teammemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeammemberCountAggregateInputType | true
    _avg?: TeammemberAvgAggregateInputType
    _sum?: TeammemberSumAggregateInputType
    _min?: TeammemberMinAggregateInputType
    _max?: TeammemberMaxAggregateInputType
  }

  export type TeammemberGroupByOutputType = {
    team_id: number
    user_id: number
    role_in_team: $Enums.TeamRole | null
    _count: TeammemberCountAggregateOutputType | null
    _avg: TeammemberAvgAggregateOutputType | null
    _sum: TeammemberSumAggregateOutputType | null
    _min: TeammemberMinAggregateOutputType | null
    _max: TeammemberMaxAggregateOutputType | null
  }

  type GetTeammemberGroupByPayload<T extends teammemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeammemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeammemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeammemberGroupByOutputType[P]>
            : GetScalarType<T[P], TeammemberGroupByOutputType[P]>
        }
      >
    >


  export type teammemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    team_id?: boolean
    user_id?: boolean
    role_in_team?: boolean
    team?: boolean | teamDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teammember"]>

  export type teammemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    team_id?: boolean
    user_id?: boolean
    role_in_team?: boolean
    team?: boolean | teamDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teammember"]>

  export type teammemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    team_id?: boolean
    user_id?: boolean
    role_in_team?: boolean
    team?: boolean | teamDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teammember"]>

  export type teammemberSelectScalar = {
    team_id?: boolean
    user_id?: boolean
    role_in_team?: boolean
  }

  export type teammemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"team_id" | "user_id" | "role_in_team", ExtArgs["result"]["teammember"]>
  export type teammemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | teamDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type teammemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | teamDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type teammemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | teamDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $teammemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "teammember"
    objects: {
      team: Prisma.$teamPayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      team_id: number
      user_id: number
      role_in_team: $Enums.TeamRole | null
    }, ExtArgs["result"]["teammember"]>
    composites: {}
  }

  type teammemberGetPayload<S extends boolean | null | undefined | teammemberDefaultArgs> = $Result.GetResult<Prisma.$teammemberPayload, S>

  type teammemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<teammemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeammemberCountAggregateInputType | true
    }

  export interface teammemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['teammember'], meta: { name: 'teammember' } }
    /**
     * Find zero or one Teammember that matches the filter.
     * @param {teammemberFindUniqueArgs} args - Arguments to find a Teammember
     * @example
     * // Get one Teammember
     * const teammember = await prisma.teammember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends teammemberFindUniqueArgs>(args: SelectSubset<T, teammemberFindUniqueArgs<ExtArgs>>): Prisma__teammemberClient<$Result.GetResult<Prisma.$teammemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Teammember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {teammemberFindUniqueOrThrowArgs} args - Arguments to find a Teammember
     * @example
     * // Get one Teammember
     * const teammember = await prisma.teammember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends teammemberFindUniqueOrThrowArgs>(args: SelectSubset<T, teammemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__teammemberClient<$Result.GetResult<Prisma.$teammemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Teammember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teammemberFindFirstArgs} args - Arguments to find a Teammember
     * @example
     * // Get one Teammember
     * const teammember = await prisma.teammember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends teammemberFindFirstArgs>(args?: SelectSubset<T, teammemberFindFirstArgs<ExtArgs>>): Prisma__teammemberClient<$Result.GetResult<Prisma.$teammemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Teammember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teammemberFindFirstOrThrowArgs} args - Arguments to find a Teammember
     * @example
     * // Get one Teammember
     * const teammember = await prisma.teammember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends teammemberFindFirstOrThrowArgs>(args?: SelectSubset<T, teammemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__teammemberClient<$Result.GetResult<Prisma.$teammemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teammembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teammemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teammembers
     * const teammembers = await prisma.teammember.findMany()
     * 
     * // Get first 10 Teammembers
     * const teammembers = await prisma.teammember.findMany({ take: 10 })
     * 
     * // Only select the `team_id`
     * const teammemberWithTeam_idOnly = await prisma.teammember.findMany({ select: { team_id: true } })
     * 
     */
    findMany<T extends teammemberFindManyArgs>(args?: SelectSubset<T, teammemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teammemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Teammember.
     * @param {teammemberCreateArgs} args - Arguments to create a Teammember.
     * @example
     * // Create one Teammember
     * const Teammember = await prisma.teammember.create({
     *   data: {
     *     // ... data to create a Teammember
     *   }
     * })
     * 
     */
    create<T extends teammemberCreateArgs>(args: SelectSubset<T, teammemberCreateArgs<ExtArgs>>): Prisma__teammemberClient<$Result.GetResult<Prisma.$teammemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teammembers.
     * @param {teammemberCreateManyArgs} args - Arguments to create many Teammembers.
     * @example
     * // Create many Teammembers
     * const teammember = await prisma.teammember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends teammemberCreateManyArgs>(args?: SelectSubset<T, teammemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teammembers and returns the data saved in the database.
     * @param {teammemberCreateManyAndReturnArgs} args - Arguments to create many Teammembers.
     * @example
     * // Create many Teammembers
     * const teammember = await prisma.teammember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teammembers and only return the `team_id`
     * const teammemberWithTeam_idOnly = await prisma.teammember.createManyAndReturn({
     *   select: { team_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends teammemberCreateManyAndReturnArgs>(args?: SelectSubset<T, teammemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teammemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Teammember.
     * @param {teammemberDeleteArgs} args - Arguments to delete one Teammember.
     * @example
     * // Delete one Teammember
     * const Teammember = await prisma.teammember.delete({
     *   where: {
     *     // ... filter to delete one Teammember
     *   }
     * })
     * 
     */
    delete<T extends teammemberDeleteArgs>(args: SelectSubset<T, teammemberDeleteArgs<ExtArgs>>): Prisma__teammemberClient<$Result.GetResult<Prisma.$teammemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Teammember.
     * @param {teammemberUpdateArgs} args - Arguments to update one Teammember.
     * @example
     * // Update one Teammember
     * const teammember = await prisma.teammember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends teammemberUpdateArgs>(args: SelectSubset<T, teammemberUpdateArgs<ExtArgs>>): Prisma__teammemberClient<$Result.GetResult<Prisma.$teammemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teammembers.
     * @param {teammemberDeleteManyArgs} args - Arguments to filter Teammembers to delete.
     * @example
     * // Delete a few Teammembers
     * const { count } = await prisma.teammember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends teammemberDeleteManyArgs>(args?: SelectSubset<T, teammemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teammembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teammemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teammembers
     * const teammember = await prisma.teammember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends teammemberUpdateManyArgs>(args: SelectSubset<T, teammemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teammembers and returns the data updated in the database.
     * @param {teammemberUpdateManyAndReturnArgs} args - Arguments to update many Teammembers.
     * @example
     * // Update many Teammembers
     * const teammember = await prisma.teammember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Teammembers and only return the `team_id`
     * const teammemberWithTeam_idOnly = await prisma.teammember.updateManyAndReturn({
     *   select: { team_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends teammemberUpdateManyAndReturnArgs>(args: SelectSubset<T, teammemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teammemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Teammember.
     * @param {teammemberUpsertArgs} args - Arguments to update or create a Teammember.
     * @example
     * // Update or create a Teammember
     * const teammember = await prisma.teammember.upsert({
     *   create: {
     *     // ... data to create a Teammember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Teammember we want to update
     *   }
     * })
     */
    upsert<T extends teammemberUpsertArgs>(args: SelectSubset<T, teammemberUpsertArgs<ExtArgs>>): Prisma__teammemberClient<$Result.GetResult<Prisma.$teammemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Teammembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teammemberCountArgs} args - Arguments to filter Teammembers to count.
     * @example
     * // Count the number of Teammembers
     * const count = await prisma.teammember.count({
     *   where: {
     *     // ... the filter for the Teammembers we want to count
     *   }
     * })
    **/
    count<T extends teammemberCountArgs>(
      args?: Subset<T, teammemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeammemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Teammember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeammemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeammemberAggregateArgs>(args: Subset<T, TeammemberAggregateArgs>): Prisma.PrismaPromise<GetTeammemberAggregateType<T>>

    /**
     * Group by Teammember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teammemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends teammemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: teammemberGroupByArgs['orderBy'] }
        : { orderBy?: teammemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, teammemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeammemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the teammember model
   */
  readonly fields: teammemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for teammember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__teammemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends teamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, teamDefaultArgs<ExtArgs>>): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the teammember model
   */
  interface teammemberFieldRefs {
    readonly team_id: FieldRef<"teammember", 'Int'>
    readonly user_id: FieldRef<"teammember", 'Int'>
    readonly role_in_team: FieldRef<"teammember", 'TeamRole'>
  }
    

  // Custom InputTypes
  /**
   * teammember findUnique
   */
  export type teammemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teammember
     */
    select?: teammemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teammember
     */
    omit?: teammemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teammemberInclude<ExtArgs> | null
    /**
     * Filter, which teammember to fetch.
     */
    where: teammemberWhereUniqueInput
  }

  /**
   * teammember findUniqueOrThrow
   */
  export type teammemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teammember
     */
    select?: teammemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teammember
     */
    omit?: teammemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teammemberInclude<ExtArgs> | null
    /**
     * Filter, which teammember to fetch.
     */
    where: teammemberWhereUniqueInput
  }

  /**
   * teammember findFirst
   */
  export type teammemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teammember
     */
    select?: teammemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teammember
     */
    omit?: teammemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teammemberInclude<ExtArgs> | null
    /**
     * Filter, which teammember to fetch.
     */
    where?: teammemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teammembers to fetch.
     */
    orderBy?: teammemberOrderByWithRelationInput | teammemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for teammembers.
     */
    cursor?: teammemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teammembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teammembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of teammembers.
     */
    distinct?: TeammemberScalarFieldEnum | TeammemberScalarFieldEnum[]
  }

  /**
   * teammember findFirstOrThrow
   */
  export type teammemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teammember
     */
    select?: teammemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teammember
     */
    omit?: teammemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teammemberInclude<ExtArgs> | null
    /**
     * Filter, which teammember to fetch.
     */
    where?: teammemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teammembers to fetch.
     */
    orderBy?: teammemberOrderByWithRelationInput | teammemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for teammembers.
     */
    cursor?: teammemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teammembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teammembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of teammembers.
     */
    distinct?: TeammemberScalarFieldEnum | TeammemberScalarFieldEnum[]
  }

  /**
   * teammember findMany
   */
  export type teammemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teammember
     */
    select?: teammemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teammember
     */
    omit?: teammemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teammemberInclude<ExtArgs> | null
    /**
     * Filter, which teammembers to fetch.
     */
    where?: teammemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teammembers to fetch.
     */
    orderBy?: teammemberOrderByWithRelationInput | teammemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing teammembers.
     */
    cursor?: teammemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teammembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teammembers.
     */
    skip?: number
    distinct?: TeammemberScalarFieldEnum | TeammemberScalarFieldEnum[]
  }

  /**
   * teammember create
   */
  export type teammemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teammember
     */
    select?: teammemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teammember
     */
    omit?: teammemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teammemberInclude<ExtArgs> | null
    /**
     * The data needed to create a teammember.
     */
    data: XOR<teammemberCreateInput, teammemberUncheckedCreateInput>
  }

  /**
   * teammember createMany
   */
  export type teammemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many teammembers.
     */
    data: teammemberCreateManyInput | teammemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * teammember createManyAndReturn
   */
  export type teammemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teammember
     */
    select?: teammemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the teammember
     */
    omit?: teammemberOmit<ExtArgs> | null
    /**
     * The data used to create many teammembers.
     */
    data: teammemberCreateManyInput | teammemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teammemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * teammember update
   */
  export type teammemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teammember
     */
    select?: teammemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teammember
     */
    omit?: teammemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teammemberInclude<ExtArgs> | null
    /**
     * The data needed to update a teammember.
     */
    data: XOR<teammemberUpdateInput, teammemberUncheckedUpdateInput>
    /**
     * Choose, which teammember to update.
     */
    where: teammemberWhereUniqueInput
  }

  /**
   * teammember updateMany
   */
  export type teammemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update teammembers.
     */
    data: XOR<teammemberUpdateManyMutationInput, teammemberUncheckedUpdateManyInput>
    /**
     * Filter which teammembers to update
     */
    where?: teammemberWhereInput
    /**
     * Limit how many teammembers to update.
     */
    limit?: number
  }

  /**
   * teammember updateManyAndReturn
   */
  export type teammemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teammember
     */
    select?: teammemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the teammember
     */
    omit?: teammemberOmit<ExtArgs> | null
    /**
     * The data used to update teammembers.
     */
    data: XOR<teammemberUpdateManyMutationInput, teammemberUncheckedUpdateManyInput>
    /**
     * Filter which teammembers to update
     */
    where?: teammemberWhereInput
    /**
     * Limit how many teammembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teammemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * teammember upsert
   */
  export type teammemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teammember
     */
    select?: teammemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teammember
     */
    omit?: teammemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teammemberInclude<ExtArgs> | null
    /**
     * The filter to search for the teammember to update in case it exists.
     */
    where: teammemberWhereUniqueInput
    /**
     * In case the teammember found by the `where` argument doesn't exist, create a new teammember with this data.
     */
    create: XOR<teammemberCreateInput, teammemberUncheckedCreateInput>
    /**
     * In case the teammember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<teammemberUpdateInput, teammemberUncheckedUpdateInput>
  }

  /**
   * teammember delete
   */
  export type teammemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teammember
     */
    select?: teammemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teammember
     */
    omit?: teammemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teammemberInclude<ExtArgs> | null
    /**
     * Filter which teammember to delete.
     */
    where: teammemberWhereUniqueInput
  }

  /**
   * teammember deleteMany
   */
  export type teammemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which teammembers to delete
     */
    where?: teammemberWhereInput
    /**
     * Limit how many teammembers to delete.
     */
    limit?: number
  }

  /**
   * teammember without action
   */
  export type teammemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teammember
     */
    select?: teammemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teammember
     */
    omit?: teammemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teammemberInclude<ExtArgs> | null
  }


  /**
   * Model teamapplication
   */

  export type AggregateTeamapplication = {
    _count: TeamapplicationCountAggregateOutputType | null
    _avg: TeamapplicationAvgAggregateOutputType | null
    _sum: TeamapplicationSumAggregateOutputType | null
    _min: TeamapplicationMinAggregateOutputType | null
    _max: TeamapplicationMaxAggregateOutputType | null
  }

  export type TeamapplicationAvgAggregateOutputType = {
    application_id: number | null
    team_id: number | null
    student_id: number | null
  }

  export type TeamapplicationSumAggregateOutputType = {
    application_id: number | null
    team_id: number | null
    student_id: number | null
  }

  export type TeamapplicationMinAggregateOutputType = {
    application_id: number | null
    team_id: number | null
    student_id: number | null
    status: $Enums.ApplicationStatus | null
    applied_at: Date | null
  }

  export type TeamapplicationMaxAggregateOutputType = {
    application_id: number | null
    team_id: number | null
    student_id: number | null
    status: $Enums.ApplicationStatus | null
    applied_at: Date | null
  }

  export type TeamapplicationCountAggregateOutputType = {
    application_id: number
    team_id: number
    student_id: number
    status: number
    applied_at: number
    _all: number
  }


  export type TeamapplicationAvgAggregateInputType = {
    application_id?: true
    team_id?: true
    student_id?: true
  }

  export type TeamapplicationSumAggregateInputType = {
    application_id?: true
    team_id?: true
    student_id?: true
  }

  export type TeamapplicationMinAggregateInputType = {
    application_id?: true
    team_id?: true
    student_id?: true
    status?: true
    applied_at?: true
  }

  export type TeamapplicationMaxAggregateInputType = {
    application_id?: true
    team_id?: true
    student_id?: true
    status?: true
    applied_at?: true
  }

  export type TeamapplicationCountAggregateInputType = {
    application_id?: true
    team_id?: true
    student_id?: true
    status?: true
    applied_at?: true
    _all?: true
  }

  export type TeamapplicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which teamapplication to aggregate.
     */
    where?: teamapplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teamapplications to fetch.
     */
    orderBy?: teamapplicationOrderByWithRelationInput | teamapplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: teamapplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teamapplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teamapplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned teamapplications
    **/
    _count?: true | TeamapplicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamapplicationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamapplicationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamapplicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamapplicationMaxAggregateInputType
  }

  export type GetTeamapplicationAggregateType<T extends TeamapplicationAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamapplication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamapplication[P]>
      : GetScalarType<T[P], AggregateTeamapplication[P]>
  }




  export type teamapplicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teamapplicationWhereInput
    orderBy?: teamapplicationOrderByWithAggregationInput | teamapplicationOrderByWithAggregationInput[]
    by: TeamapplicationScalarFieldEnum[] | TeamapplicationScalarFieldEnum
    having?: teamapplicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamapplicationCountAggregateInputType | true
    _avg?: TeamapplicationAvgAggregateInputType
    _sum?: TeamapplicationSumAggregateInputType
    _min?: TeamapplicationMinAggregateInputType
    _max?: TeamapplicationMaxAggregateInputType
  }

  export type TeamapplicationGroupByOutputType = {
    application_id: number
    team_id: number
    student_id: number
    status: $Enums.ApplicationStatus
    applied_at: Date
    _count: TeamapplicationCountAggregateOutputType | null
    _avg: TeamapplicationAvgAggregateOutputType | null
    _sum: TeamapplicationSumAggregateOutputType | null
    _min: TeamapplicationMinAggregateOutputType | null
    _max: TeamapplicationMaxAggregateOutputType | null
  }

  type GetTeamapplicationGroupByPayload<T extends teamapplicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamapplicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamapplicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamapplicationGroupByOutputType[P]>
            : GetScalarType<T[P], TeamapplicationGroupByOutputType[P]>
        }
      >
    >


  export type teamapplicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    application_id?: boolean
    team_id?: boolean
    student_id?: boolean
    status?: boolean
    applied_at?: boolean
    student?: boolean | studentDefaultArgs<ExtArgs>
    team?: boolean | teamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamapplication"]>

  export type teamapplicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    application_id?: boolean
    team_id?: boolean
    student_id?: boolean
    status?: boolean
    applied_at?: boolean
    student?: boolean | studentDefaultArgs<ExtArgs>
    team?: boolean | teamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamapplication"]>

  export type teamapplicationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    application_id?: boolean
    team_id?: boolean
    student_id?: boolean
    status?: boolean
    applied_at?: boolean
    student?: boolean | studentDefaultArgs<ExtArgs>
    team?: boolean | teamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamapplication"]>

  export type teamapplicationSelectScalar = {
    application_id?: boolean
    team_id?: boolean
    student_id?: boolean
    status?: boolean
    applied_at?: boolean
  }

  export type teamapplicationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"application_id" | "team_id" | "student_id" | "status" | "applied_at", ExtArgs["result"]["teamapplication"]>
  export type teamapplicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | studentDefaultArgs<ExtArgs>
    team?: boolean | teamDefaultArgs<ExtArgs>
  }
  export type teamapplicationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | studentDefaultArgs<ExtArgs>
    team?: boolean | teamDefaultArgs<ExtArgs>
  }
  export type teamapplicationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | studentDefaultArgs<ExtArgs>
    team?: boolean | teamDefaultArgs<ExtArgs>
  }

  export type $teamapplicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "teamapplication"
    objects: {
      student: Prisma.$studentPayload<ExtArgs>
      team: Prisma.$teamPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      application_id: number
      team_id: number
      student_id: number
      status: $Enums.ApplicationStatus
      applied_at: Date
    }, ExtArgs["result"]["teamapplication"]>
    composites: {}
  }

  type teamapplicationGetPayload<S extends boolean | null | undefined | teamapplicationDefaultArgs> = $Result.GetResult<Prisma.$teamapplicationPayload, S>

  type teamapplicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<teamapplicationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamapplicationCountAggregateInputType | true
    }

  export interface teamapplicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['teamapplication'], meta: { name: 'teamapplication' } }
    /**
     * Find zero or one Teamapplication that matches the filter.
     * @param {teamapplicationFindUniqueArgs} args - Arguments to find a Teamapplication
     * @example
     * // Get one Teamapplication
     * const teamapplication = await prisma.teamapplication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends teamapplicationFindUniqueArgs>(args: SelectSubset<T, teamapplicationFindUniqueArgs<ExtArgs>>): Prisma__teamapplicationClient<$Result.GetResult<Prisma.$teamapplicationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Teamapplication that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {teamapplicationFindUniqueOrThrowArgs} args - Arguments to find a Teamapplication
     * @example
     * // Get one Teamapplication
     * const teamapplication = await prisma.teamapplication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends teamapplicationFindUniqueOrThrowArgs>(args: SelectSubset<T, teamapplicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__teamapplicationClient<$Result.GetResult<Prisma.$teamapplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Teamapplication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamapplicationFindFirstArgs} args - Arguments to find a Teamapplication
     * @example
     * // Get one Teamapplication
     * const teamapplication = await prisma.teamapplication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends teamapplicationFindFirstArgs>(args?: SelectSubset<T, teamapplicationFindFirstArgs<ExtArgs>>): Prisma__teamapplicationClient<$Result.GetResult<Prisma.$teamapplicationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Teamapplication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamapplicationFindFirstOrThrowArgs} args - Arguments to find a Teamapplication
     * @example
     * // Get one Teamapplication
     * const teamapplication = await prisma.teamapplication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends teamapplicationFindFirstOrThrowArgs>(args?: SelectSubset<T, teamapplicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__teamapplicationClient<$Result.GetResult<Prisma.$teamapplicationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teamapplications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamapplicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teamapplications
     * const teamapplications = await prisma.teamapplication.findMany()
     * 
     * // Get first 10 Teamapplications
     * const teamapplications = await prisma.teamapplication.findMany({ take: 10 })
     * 
     * // Only select the `application_id`
     * const teamapplicationWithApplication_idOnly = await prisma.teamapplication.findMany({ select: { application_id: true } })
     * 
     */
    findMany<T extends teamapplicationFindManyArgs>(args?: SelectSubset<T, teamapplicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teamapplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Teamapplication.
     * @param {teamapplicationCreateArgs} args - Arguments to create a Teamapplication.
     * @example
     * // Create one Teamapplication
     * const Teamapplication = await prisma.teamapplication.create({
     *   data: {
     *     // ... data to create a Teamapplication
     *   }
     * })
     * 
     */
    create<T extends teamapplicationCreateArgs>(args: SelectSubset<T, teamapplicationCreateArgs<ExtArgs>>): Prisma__teamapplicationClient<$Result.GetResult<Prisma.$teamapplicationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teamapplications.
     * @param {teamapplicationCreateManyArgs} args - Arguments to create many Teamapplications.
     * @example
     * // Create many Teamapplications
     * const teamapplication = await prisma.teamapplication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends teamapplicationCreateManyArgs>(args?: SelectSubset<T, teamapplicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teamapplications and returns the data saved in the database.
     * @param {teamapplicationCreateManyAndReturnArgs} args - Arguments to create many Teamapplications.
     * @example
     * // Create many Teamapplications
     * const teamapplication = await prisma.teamapplication.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teamapplications and only return the `application_id`
     * const teamapplicationWithApplication_idOnly = await prisma.teamapplication.createManyAndReturn({
     *   select: { application_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends teamapplicationCreateManyAndReturnArgs>(args?: SelectSubset<T, teamapplicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teamapplicationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Teamapplication.
     * @param {teamapplicationDeleteArgs} args - Arguments to delete one Teamapplication.
     * @example
     * // Delete one Teamapplication
     * const Teamapplication = await prisma.teamapplication.delete({
     *   where: {
     *     // ... filter to delete one Teamapplication
     *   }
     * })
     * 
     */
    delete<T extends teamapplicationDeleteArgs>(args: SelectSubset<T, teamapplicationDeleteArgs<ExtArgs>>): Prisma__teamapplicationClient<$Result.GetResult<Prisma.$teamapplicationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Teamapplication.
     * @param {teamapplicationUpdateArgs} args - Arguments to update one Teamapplication.
     * @example
     * // Update one Teamapplication
     * const teamapplication = await prisma.teamapplication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends teamapplicationUpdateArgs>(args: SelectSubset<T, teamapplicationUpdateArgs<ExtArgs>>): Prisma__teamapplicationClient<$Result.GetResult<Prisma.$teamapplicationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teamapplications.
     * @param {teamapplicationDeleteManyArgs} args - Arguments to filter Teamapplications to delete.
     * @example
     * // Delete a few Teamapplications
     * const { count } = await prisma.teamapplication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends teamapplicationDeleteManyArgs>(args?: SelectSubset<T, teamapplicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teamapplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamapplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teamapplications
     * const teamapplication = await prisma.teamapplication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends teamapplicationUpdateManyArgs>(args: SelectSubset<T, teamapplicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teamapplications and returns the data updated in the database.
     * @param {teamapplicationUpdateManyAndReturnArgs} args - Arguments to update many Teamapplications.
     * @example
     * // Update many Teamapplications
     * const teamapplication = await prisma.teamapplication.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Teamapplications and only return the `application_id`
     * const teamapplicationWithApplication_idOnly = await prisma.teamapplication.updateManyAndReturn({
     *   select: { application_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends teamapplicationUpdateManyAndReturnArgs>(args: SelectSubset<T, teamapplicationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teamapplicationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Teamapplication.
     * @param {teamapplicationUpsertArgs} args - Arguments to update or create a Teamapplication.
     * @example
     * // Update or create a Teamapplication
     * const teamapplication = await prisma.teamapplication.upsert({
     *   create: {
     *     // ... data to create a Teamapplication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Teamapplication we want to update
     *   }
     * })
     */
    upsert<T extends teamapplicationUpsertArgs>(args: SelectSubset<T, teamapplicationUpsertArgs<ExtArgs>>): Prisma__teamapplicationClient<$Result.GetResult<Prisma.$teamapplicationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Teamapplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamapplicationCountArgs} args - Arguments to filter Teamapplications to count.
     * @example
     * // Count the number of Teamapplications
     * const count = await prisma.teamapplication.count({
     *   where: {
     *     // ... the filter for the Teamapplications we want to count
     *   }
     * })
    **/
    count<T extends teamapplicationCountArgs>(
      args?: Subset<T, teamapplicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamapplicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Teamapplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamapplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamapplicationAggregateArgs>(args: Subset<T, TeamapplicationAggregateArgs>): Prisma.PrismaPromise<GetTeamapplicationAggregateType<T>>

    /**
     * Group by Teamapplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamapplicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends teamapplicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: teamapplicationGroupByArgs['orderBy'] }
        : { orderBy?: teamapplicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, teamapplicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamapplicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the teamapplication model
   */
  readonly fields: teamapplicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for teamapplication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__teamapplicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends studentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, studentDefaultArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    team<T extends teamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, teamDefaultArgs<ExtArgs>>): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the teamapplication model
   */
  interface teamapplicationFieldRefs {
    readonly application_id: FieldRef<"teamapplication", 'Int'>
    readonly team_id: FieldRef<"teamapplication", 'Int'>
    readonly student_id: FieldRef<"teamapplication", 'Int'>
    readonly status: FieldRef<"teamapplication", 'ApplicationStatus'>
    readonly applied_at: FieldRef<"teamapplication", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * teamapplication findUnique
   */
  export type teamapplicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teamapplication
     */
    select?: teamapplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teamapplication
     */
    omit?: teamapplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamapplicationInclude<ExtArgs> | null
    /**
     * Filter, which teamapplication to fetch.
     */
    where: teamapplicationWhereUniqueInput
  }

  /**
   * teamapplication findUniqueOrThrow
   */
  export type teamapplicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teamapplication
     */
    select?: teamapplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teamapplication
     */
    omit?: teamapplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamapplicationInclude<ExtArgs> | null
    /**
     * Filter, which teamapplication to fetch.
     */
    where: teamapplicationWhereUniqueInput
  }

  /**
   * teamapplication findFirst
   */
  export type teamapplicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teamapplication
     */
    select?: teamapplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teamapplication
     */
    omit?: teamapplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamapplicationInclude<ExtArgs> | null
    /**
     * Filter, which teamapplication to fetch.
     */
    where?: teamapplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teamapplications to fetch.
     */
    orderBy?: teamapplicationOrderByWithRelationInput | teamapplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for teamapplications.
     */
    cursor?: teamapplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teamapplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teamapplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of teamapplications.
     */
    distinct?: TeamapplicationScalarFieldEnum | TeamapplicationScalarFieldEnum[]
  }

  /**
   * teamapplication findFirstOrThrow
   */
  export type teamapplicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teamapplication
     */
    select?: teamapplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teamapplication
     */
    omit?: teamapplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamapplicationInclude<ExtArgs> | null
    /**
     * Filter, which teamapplication to fetch.
     */
    where?: teamapplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teamapplications to fetch.
     */
    orderBy?: teamapplicationOrderByWithRelationInput | teamapplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for teamapplications.
     */
    cursor?: teamapplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teamapplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teamapplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of teamapplications.
     */
    distinct?: TeamapplicationScalarFieldEnum | TeamapplicationScalarFieldEnum[]
  }

  /**
   * teamapplication findMany
   */
  export type teamapplicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teamapplication
     */
    select?: teamapplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teamapplication
     */
    omit?: teamapplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamapplicationInclude<ExtArgs> | null
    /**
     * Filter, which teamapplications to fetch.
     */
    where?: teamapplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teamapplications to fetch.
     */
    orderBy?: teamapplicationOrderByWithRelationInput | teamapplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing teamapplications.
     */
    cursor?: teamapplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teamapplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teamapplications.
     */
    skip?: number
    distinct?: TeamapplicationScalarFieldEnum | TeamapplicationScalarFieldEnum[]
  }

  /**
   * teamapplication create
   */
  export type teamapplicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teamapplication
     */
    select?: teamapplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teamapplication
     */
    omit?: teamapplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamapplicationInclude<ExtArgs> | null
    /**
     * The data needed to create a teamapplication.
     */
    data: XOR<teamapplicationCreateInput, teamapplicationUncheckedCreateInput>
  }

  /**
   * teamapplication createMany
   */
  export type teamapplicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many teamapplications.
     */
    data: teamapplicationCreateManyInput | teamapplicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * teamapplication createManyAndReturn
   */
  export type teamapplicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teamapplication
     */
    select?: teamapplicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the teamapplication
     */
    omit?: teamapplicationOmit<ExtArgs> | null
    /**
     * The data used to create many teamapplications.
     */
    data: teamapplicationCreateManyInput | teamapplicationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamapplicationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * teamapplication update
   */
  export type teamapplicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teamapplication
     */
    select?: teamapplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teamapplication
     */
    omit?: teamapplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamapplicationInclude<ExtArgs> | null
    /**
     * The data needed to update a teamapplication.
     */
    data: XOR<teamapplicationUpdateInput, teamapplicationUncheckedUpdateInput>
    /**
     * Choose, which teamapplication to update.
     */
    where: teamapplicationWhereUniqueInput
  }

  /**
   * teamapplication updateMany
   */
  export type teamapplicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update teamapplications.
     */
    data: XOR<teamapplicationUpdateManyMutationInput, teamapplicationUncheckedUpdateManyInput>
    /**
     * Filter which teamapplications to update
     */
    where?: teamapplicationWhereInput
    /**
     * Limit how many teamapplications to update.
     */
    limit?: number
  }

  /**
   * teamapplication updateManyAndReturn
   */
  export type teamapplicationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teamapplication
     */
    select?: teamapplicationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the teamapplication
     */
    omit?: teamapplicationOmit<ExtArgs> | null
    /**
     * The data used to update teamapplications.
     */
    data: XOR<teamapplicationUpdateManyMutationInput, teamapplicationUncheckedUpdateManyInput>
    /**
     * Filter which teamapplications to update
     */
    where?: teamapplicationWhereInput
    /**
     * Limit how many teamapplications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamapplicationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * teamapplication upsert
   */
  export type teamapplicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teamapplication
     */
    select?: teamapplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teamapplication
     */
    omit?: teamapplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamapplicationInclude<ExtArgs> | null
    /**
     * The filter to search for the teamapplication to update in case it exists.
     */
    where: teamapplicationWhereUniqueInput
    /**
     * In case the teamapplication found by the `where` argument doesn't exist, create a new teamapplication with this data.
     */
    create: XOR<teamapplicationCreateInput, teamapplicationUncheckedCreateInput>
    /**
     * In case the teamapplication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<teamapplicationUpdateInput, teamapplicationUncheckedUpdateInput>
  }

  /**
   * teamapplication delete
   */
  export type teamapplicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teamapplication
     */
    select?: teamapplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teamapplication
     */
    omit?: teamapplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamapplicationInclude<ExtArgs> | null
    /**
     * Filter which teamapplication to delete.
     */
    where: teamapplicationWhereUniqueInput
  }

  /**
   * teamapplication deleteMany
   */
  export type teamapplicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which teamapplications to delete
     */
    where?: teamapplicationWhereInput
    /**
     * Limit how many teamapplications to delete.
     */
    limit?: number
  }

  /**
   * teamapplication without action
   */
  export type teamapplicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teamapplication
     */
    select?: teamapplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teamapplication
     */
    omit?: teamapplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamapplicationInclude<ExtArgs> | null
  }


  /**
   * Model teamcomment
   */

  export type AggregateTeamcomment = {
    _count: TeamcommentCountAggregateOutputType | null
    _avg: TeamcommentAvgAggregateOutputType | null
    _sum: TeamcommentSumAggregateOutputType | null
    _min: TeamcommentMinAggregateOutputType | null
    _max: TeamcommentMaxAggregateOutputType | null
  }

  export type TeamcommentAvgAggregateOutputType = {
    comment_id: number | null
    team_id: number | null
    user_id: number | null
  }

  export type TeamcommentSumAggregateOutputType = {
    comment_id: number | null
    team_id: number | null
    user_id: number | null
  }

  export type TeamcommentMinAggregateOutputType = {
    comment_id: number | null
    team_id: number | null
    user_id: number | null
    comment: string | null
    created_at: Date | null
  }

  export type TeamcommentMaxAggregateOutputType = {
    comment_id: number | null
    team_id: number | null
    user_id: number | null
    comment: string | null
    created_at: Date | null
  }

  export type TeamcommentCountAggregateOutputType = {
    comment_id: number
    team_id: number
    user_id: number
    comment: number
    created_at: number
    _all: number
  }


  export type TeamcommentAvgAggregateInputType = {
    comment_id?: true
    team_id?: true
    user_id?: true
  }

  export type TeamcommentSumAggregateInputType = {
    comment_id?: true
    team_id?: true
    user_id?: true
  }

  export type TeamcommentMinAggregateInputType = {
    comment_id?: true
    team_id?: true
    user_id?: true
    comment?: true
    created_at?: true
  }

  export type TeamcommentMaxAggregateInputType = {
    comment_id?: true
    team_id?: true
    user_id?: true
    comment?: true
    created_at?: true
  }

  export type TeamcommentCountAggregateInputType = {
    comment_id?: true
    team_id?: true
    user_id?: true
    comment?: true
    created_at?: true
    _all?: true
  }

  export type TeamcommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which teamcomment to aggregate.
     */
    where?: teamcommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teamcomments to fetch.
     */
    orderBy?: teamcommentOrderByWithRelationInput | teamcommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: teamcommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teamcomments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teamcomments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned teamcomments
    **/
    _count?: true | TeamcommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamcommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamcommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamcommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamcommentMaxAggregateInputType
  }

  export type GetTeamcommentAggregateType<T extends TeamcommentAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamcomment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamcomment[P]>
      : GetScalarType<T[P], AggregateTeamcomment[P]>
  }




  export type teamcommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teamcommentWhereInput
    orderBy?: teamcommentOrderByWithAggregationInput | teamcommentOrderByWithAggregationInput[]
    by: TeamcommentScalarFieldEnum[] | TeamcommentScalarFieldEnum
    having?: teamcommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamcommentCountAggregateInputType | true
    _avg?: TeamcommentAvgAggregateInputType
    _sum?: TeamcommentSumAggregateInputType
    _min?: TeamcommentMinAggregateInputType
    _max?: TeamcommentMaxAggregateInputType
  }

  export type TeamcommentGroupByOutputType = {
    comment_id: number
    team_id: number
    user_id: number
    comment: string
    created_at: Date
    _count: TeamcommentCountAggregateOutputType | null
    _avg: TeamcommentAvgAggregateOutputType | null
    _sum: TeamcommentSumAggregateOutputType | null
    _min: TeamcommentMinAggregateOutputType | null
    _max: TeamcommentMaxAggregateOutputType | null
  }

  type GetTeamcommentGroupByPayload<T extends teamcommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamcommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamcommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamcommentGroupByOutputType[P]>
            : GetScalarType<T[P], TeamcommentGroupByOutputType[P]>
        }
      >
    >


  export type teamcommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    comment_id?: boolean
    team_id?: boolean
    user_id?: boolean
    comment?: boolean
    created_at?: boolean
    team?: boolean | teamDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamcomment"]>

  export type teamcommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    comment_id?: boolean
    team_id?: boolean
    user_id?: boolean
    comment?: boolean
    created_at?: boolean
    team?: boolean | teamDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamcomment"]>

  export type teamcommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    comment_id?: boolean
    team_id?: boolean
    user_id?: boolean
    comment?: boolean
    created_at?: boolean
    team?: boolean | teamDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamcomment"]>

  export type teamcommentSelectScalar = {
    comment_id?: boolean
    team_id?: boolean
    user_id?: boolean
    comment?: boolean
    created_at?: boolean
  }

  export type teamcommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"comment_id" | "team_id" | "user_id" | "comment" | "created_at", ExtArgs["result"]["teamcomment"]>
  export type teamcommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | teamDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type teamcommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | teamDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type teamcommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | teamDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $teamcommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "teamcomment"
    objects: {
      team: Prisma.$teamPayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      comment_id: number
      team_id: number
      user_id: number
      comment: string
      created_at: Date
    }, ExtArgs["result"]["teamcomment"]>
    composites: {}
  }

  type teamcommentGetPayload<S extends boolean | null | undefined | teamcommentDefaultArgs> = $Result.GetResult<Prisma.$teamcommentPayload, S>

  type teamcommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<teamcommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamcommentCountAggregateInputType | true
    }

  export interface teamcommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['teamcomment'], meta: { name: 'teamcomment' } }
    /**
     * Find zero or one Teamcomment that matches the filter.
     * @param {teamcommentFindUniqueArgs} args - Arguments to find a Teamcomment
     * @example
     * // Get one Teamcomment
     * const teamcomment = await prisma.teamcomment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends teamcommentFindUniqueArgs>(args: SelectSubset<T, teamcommentFindUniqueArgs<ExtArgs>>): Prisma__teamcommentClient<$Result.GetResult<Prisma.$teamcommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Teamcomment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {teamcommentFindUniqueOrThrowArgs} args - Arguments to find a Teamcomment
     * @example
     * // Get one Teamcomment
     * const teamcomment = await prisma.teamcomment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends teamcommentFindUniqueOrThrowArgs>(args: SelectSubset<T, teamcommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__teamcommentClient<$Result.GetResult<Prisma.$teamcommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Teamcomment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamcommentFindFirstArgs} args - Arguments to find a Teamcomment
     * @example
     * // Get one Teamcomment
     * const teamcomment = await prisma.teamcomment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends teamcommentFindFirstArgs>(args?: SelectSubset<T, teamcommentFindFirstArgs<ExtArgs>>): Prisma__teamcommentClient<$Result.GetResult<Prisma.$teamcommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Teamcomment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamcommentFindFirstOrThrowArgs} args - Arguments to find a Teamcomment
     * @example
     * // Get one Teamcomment
     * const teamcomment = await prisma.teamcomment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends teamcommentFindFirstOrThrowArgs>(args?: SelectSubset<T, teamcommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__teamcommentClient<$Result.GetResult<Prisma.$teamcommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teamcomments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamcommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teamcomments
     * const teamcomments = await prisma.teamcomment.findMany()
     * 
     * // Get first 10 Teamcomments
     * const teamcomments = await prisma.teamcomment.findMany({ take: 10 })
     * 
     * // Only select the `comment_id`
     * const teamcommentWithComment_idOnly = await prisma.teamcomment.findMany({ select: { comment_id: true } })
     * 
     */
    findMany<T extends teamcommentFindManyArgs>(args?: SelectSubset<T, teamcommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teamcommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Teamcomment.
     * @param {teamcommentCreateArgs} args - Arguments to create a Teamcomment.
     * @example
     * // Create one Teamcomment
     * const Teamcomment = await prisma.teamcomment.create({
     *   data: {
     *     // ... data to create a Teamcomment
     *   }
     * })
     * 
     */
    create<T extends teamcommentCreateArgs>(args: SelectSubset<T, teamcommentCreateArgs<ExtArgs>>): Prisma__teamcommentClient<$Result.GetResult<Prisma.$teamcommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teamcomments.
     * @param {teamcommentCreateManyArgs} args - Arguments to create many Teamcomments.
     * @example
     * // Create many Teamcomments
     * const teamcomment = await prisma.teamcomment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends teamcommentCreateManyArgs>(args?: SelectSubset<T, teamcommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teamcomments and returns the data saved in the database.
     * @param {teamcommentCreateManyAndReturnArgs} args - Arguments to create many Teamcomments.
     * @example
     * // Create many Teamcomments
     * const teamcomment = await prisma.teamcomment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teamcomments and only return the `comment_id`
     * const teamcommentWithComment_idOnly = await prisma.teamcomment.createManyAndReturn({
     *   select: { comment_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends teamcommentCreateManyAndReturnArgs>(args?: SelectSubset<T, teamcommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teamcommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Teamcomment.
     * @param {teamcommentDeleteArgs} args - Arguments to delete one Teamcomment.
     * @example
     * // Delete one Teamcomment
     * const Teamcomment = await prisma.teamcomment.delete({
     *   where: {
     *     // ... filter to delete one Teamcomment
     *   }
     * })
     * 
     */
    delete<T extends teamcommentDeleteArgs>(args: SelectSubset<T, teamcommentDeleteArgs<ExtArgs>>): Prisma__teamcommentClient<$Result.GetResult<Prisma.$teamcommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Teamcomment.
     * @param {teamcommentUpdateArgs} args - Arguments to update one Teamcomment.
     * @example
     * // Update one Teamcomment
     * const teamcomment = await prisma.teamcomment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends teamcommentUpdateArgs>(args: SelectSubset<T, teamcommentUpdateArgs<ExtArgs>>): Prisma__teamcommentClient<$Result.GetResult<Prisma.$teamcommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teamcomments.
     * @param {teamcommentDeleteManyArgs} args - Arguments to filter Teamcomments to delete.
     * @example
     * // Delete a few Teamcomments
     * const { count } = await prisma.teamcomment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends teamcommentDeleteManyArgs>(args?: SelectSubset<T, teamcommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teamcomments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamcommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teamcomments
     * const teamcomment = await prisma.teamcomment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends teamcommentUpdateManyArgs>(args: SelectSubset<T, teamcommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teamcomments and returns the data updated in the database.
     * @param {teamcommentUpdateManyAndReturnArgs} args - Arguments to update many Teamcomments.
     * @example
     * // Update many Teamcomments
     * const teamcomment = await prisma.teamcomment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Teamcomments and only return the `comment_id`
     * const teamcommentWithComment_idOnly = await prisma.teamcomment.updateManyAndReturn({
     *   select: { comment_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends teamcommentUpdateManyAndReturnArgs>(args: SelectSubset<T, teamcommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teamcommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Teamcomment.
     * @param {teamcommentUpsertArgs} args - Arguments to update or create a Teamcomment.
     * @example
     * // Update or create a Teamcomment
     * const teamcomment = await prisma.teamcomment.upsert({
     *   create: {
     *     // ... data to create a Teamcomment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Teamcomment we want to update
     *   }
     * })
     */
    upsert<T extends teamcommentUpsertArgs>(args: SelectSubset<T, teamcommentUpsertArgs<ExtArgs>>): Prisma__teamcommentClient<$Result.GetResult<Prisma.$teamcommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Teamcomments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamcommentCountArgs} args - Arguments to filter Teamcomments to count.
     * @example
     * // Count the number of Teamcomments
     * const count = await prisma.teamcomment.count({
     *   where: {
     *     // ... the filter for the Teamcomments we want to count
     *   }
     * })
    **/
    count<T extends teamcommentCountArgs>(
      args?: Subset<T, teamcommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamcommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Teamcomment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamcommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamcommentAggregateArgs>(args: Subset<T, TeamcommentAggregateArgs>): Prisma.PrismaPromise<GetTeamcommentAggregateType<T>>

    /**
     * Group by Teamcomment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamcommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends teamcommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: teamcommentGroupByArgs['orderBy'] }
        : { orderBy?: teamcommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, teamcommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamcommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the teamcomment model
   */
  readonly fields: teamcommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for teamcomment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__teamcommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends teamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, teamDefaultArgs<ExtArgs>>): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the teamcomment model
   */
  interface teamcommentFieldRefs {
    readonly comment_id: FieldRef<"teamcomment", 'Int'>
    readonly team_id: FieldRef<"teamcomment", 'Int'>
    readonly user_id: FieldRef<"teamcomment", 'Int'>
    readonly comment: FieldRef<"teamcomment", 'String'>
    readonly created_at: FieldRef<"teamcomment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * teamcomment findUnique
   */
  export type teamcommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teamcomment
     */
    select?: teamcommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teamcomment
     */
    omit?: teamcommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamcommentInclude<ExtArgs> | null
    /**
     * Filter, which teamcomment to fetch.
     */
    where: teamcommentWhereUniqueInput
  }

  /**
   * teamcomment findUniqueOrThrow
   */
  export type teamcommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teamcomment
     */
    select?: teamcommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teamcomment
     */
    omit?: teamcommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamcommentInclude<ExtArgs> | null
    /**
     * Filter, which teamcomment to fetch.
     */
    where: teamcommentWhereUniqueInput
  }

  /**
   * teamcomment findFirst
   */
  export type teamcommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teamcomment
     */
    select?: teamcommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teamcomment
     */
    omit?: teamcommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamcommentInclude<ExtArgs> | null
    /**
     * Filter, which teamcomment to fetch.
     */
    where?: teamcommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teamcomments to fetch.
     */
    orderBy?: teamcommentOrderByWithRelationInput | teamcommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for teamcomments.
     */
    cursor?: teamcommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teamcomments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teamcomments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of teamcomments.
     */
    distinct?: TeamcommentScalarFieldEnum | TeamcommentScalarFieldEnum[]
  }

  /**
   * teamcomment findFirstOrThrow
   */
  export type teamcommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teamcomment
     */
    select?: teamcommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teamcomment
     */
    omit?: teamcommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamcommentInclude<ExtArgs> | null
    /**
     * Filter, which teamcomment to fetch.
     */
    where?: teamcommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teamcomments to fetch.
     */
    orderBy?: teamcommentOrderByWithRelationInput | teamcommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for teamcomments.
     */
    cursor?: teamcommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teamcomments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teamcomments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of teamcomments.
     */
    distinct?: TeamcommentScalarFieldEnum | TeamcommentScalarFieldEnum[]
  }

  /**
   * teamcomment findMany
   */
  export type teamcommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teamcomment
     */
    select?: teamcommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teamcomment
     */
    omit?: teamcommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamcommentInclude<ExtArgs> | null
    /**
     * Filter, which teamcomments to fetch.
     */
    where?: teamcommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teamcomments to fetch.
     */
    orderBy?: teamcommentOrderByWithRelationInput | teamcommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing teamcomments.
     */
    cursor?: teamcommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teamcomments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teamcomments.
     */
    skip?: number
    distinct?: TeamcommentScalarFieldEnum | TeamcommentScalarFieldEnum[]
  }

  /**
   * teamcomment create
   */
  export type teamcommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teamcomment
     */
    select?: teamcommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teamcomment
     */
    omit?: teamcommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamcommentInclude<ExtArgs> | null
    /**
     * The data needed to create a teamcomment.
     */
    data: XOR<teamcommentCreateInput, teamcommentUncheckedCreateInput>
  }

  /**
   * teamcomment createMany
   */
  export type teamcommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many teamcomments.
     */
    data: teamcommentCreateManyInput | teamcommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * teamcomment createManyAndReturn
   */
  export type teamcommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teamcomment
     */
    select?: teamcommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the teamcomment
     */
    omit?: teamcommentOmit<ExtArgs> | null
    /**
     * The data used to create many teamcomments.
     */
    data: teamcommentCreateManyInput | teamcommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamcommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * teamcomment update
   */
  export type teamcommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teamcomment
     */
    select?: teamcommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teamcomment
     */
    omit?: teamcommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamcommentInclude<ExtArgs> | null
    /**
     * The data needed to update a teamcomment.
     */
    data: XOR<teamcommentUpdateInput, teamcommentUncheckedUpdateInput>
    /**
     * Choose, which teamcomment to update.
     */
    where: teamcommentWhereUniqueInput
  }

  /**
   * teamcomment updateMany
   */
  export type teamcommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update teamcomments.
     */
    data: XOR<teamcommentUpdateManyMutationInput, teamcommentUncheckedUpdateManyInput>
    /**
     * Filter which teamcomments to update
     */
    where?: teamcommentWhereInput
    /**
     * Limit how many teamcomments to update.
     */
    limit?: number
  }

  /**
   * teamcomment updateManyAndReturn
   */
  export type teamcommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teamcomment
     */
    select?: teamcommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the teamcomment
     */
    omit?: teamcommentOmit<ExtArgs> | null
    /**
     * The data used to update teamcomments.
     */
    data: XOR<teamcommentUpdateManyMutationInput, teamcommentUncheckedUpdateManyInput>
    /**
     * Filter which teamcomments to update
     */
    where?: teamcommentWhereInput
    /**
     * Limit how many teamcomments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamcommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * teamcomment upsert
   */
  export type teamcommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teamcomment
     */
    select?: teamcommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teamcomment
     */
    omit?: teamcommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamcommentInclude<ExtArgs> | null
    /**
     * The filter to search for the teamcomment to update in case it exists.
     */
    where: teamcommentWhereUniqueInput
    /**
     * In case the teamcomment found by the `where` argument doesn't exist, create a new teamcomment with this data.
     */
    create: XOR<teamcommentCreateInput, teamcommentUncheckedCreateInput>
    /**
     * In case the teamcomment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<teamcommentUpdateInput, teamcommentUncheckedUpdateInput>
  }

  /**
   * teamcomment delete
   */
  export type teamcommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teamcomment
     */
    select?: teamcommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teamcomment
     */
    omit?: teamcommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamcommentInclude<ExtArgs> | null
    /**
     * Filter which teamcomment to delete.
     */
    where: teamcommentWhereUniqueInput
  }

  /**
   * teamcomment deleteMany
   */
  export type teamcommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which teamcomments to delete
     */
    where?: teamcommentWhereInput
    /**
     * Limit how many teamcomments to delete.
     */
    limit?: number
  }

  /**
   * teamcomment without action
   */
  export type teamcommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teamcomment
     */
    select?: teamcommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teamcomment
     */
    omit?: teamcommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamcommentInclude<ExtArgs> | null
  }


  /**
   * Model paper
   */

  export type AggregatePaper = {
    _count: PaperCountAggregateOutputType | null
    _avg: PaperAvgAggregateOutputType | null
    _sum: PaperSumAggregateOutputType | null
    _min: PaperMinAggregateOutputType | null
    _max: PaperMaxAggregateOutputType | null
  }

  export type PaperAvgAggregateOutputType = {
    paper_id: number | null
    team_id: number | null
    submitted_by: number | null
    file_size: number | null
  }

  export type PaperSumAggregateOutputType = {
    paper_id: number | null
    team_id: number | null
    submitted_by: number | null
    file_size: number | null
  }

  export type PaperMinAggregateOutputType = {
    paper_id: number | null
    title: string | null
    abstract: string | null
    status: $Enums.PaperStatus | null
    team_id: number | null
    submitted_by: number | null
    pdf_path: string | null
    file_size: number | null
    created_at: Date | null
    aggregated_decided_at: Date | null
    aggregated_decision: $Enums.ReviewDecision | null
  }

  export type PaperMaxAggregateOutputType = {
    paper_id: number | null
    title: string | null
    abstract: string | null
    status: $Enums.PaperStatus | null
    team_id: number | null
    submitted_by: number | null
    pdf_path: string | null
    file_size: number | null
    created_at: Date | null
    aggregated_decided_at: Date | null
    aggregated_decision: $Enums.ReviewDecision | null
  }

  export type PaperCountAggregateOutputType = {
    paper_id: number
    title: number
    abstract: number
    status: number
    team_id: number
    submitted_by: number
    pdf_path: number
    file_size: number
    created_at: number
    aggregated_decided_at: number
    aggregated_decision: number
    _all: number
  }


  export type PaperAvgAggregateInputType = {
    paper_id?: true
    team_id?: true
    submitted_by?: true
    file_size?: true
  }

  export type PaperSumAggregateInputType = {
    paper_id?: true
    team_id?: true
    submitted_by?: true
    file_size?: true
  }

  export type PaperMinAggregateInputType = {
    paper_id?: true
    title?: true
    abstract?: true
    status?: true
    team_id?: true
    submitted_by?: true
    pdf_path?: true
    file_size?: true
    created_at?: true
    aggregated_decided_at?: true
    aggregated_decision?: true
  }

  export type PaperMaxAggregateInputType = {
    paper_id?: true
    title?: true
    abstract?: true
    status?: true
    team_id?: true
    submitted_by?: true
    pdf_path?: true
    file_size?: true
    created_at?: true
    aggregated_decided_at?: true
    aggregated_decision?: true
  }

  export type PaperCountAggregateInputType = {
    paper_id?: true
    title?: true
    abstract?: true
    status?: true
    team_id?: true
    submitted_by?: true
    pdf_path?: true
    file_size?: true
    created_at?: true
    aggregated_decided_at?: true
    aggregated_decision?: true
    _all?: true
  }

  export type PaperAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which paper to aggregate.
     */
    where?: paperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of papers to fetch.
     */
    orderBy?: paperOrderByWithRelationInput | paperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: paperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` papers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` papers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned papers
    **/
    _count?: true | PaperCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaperAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaperSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaperMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaperMaxAggregateInputType
  }

  export type GetPaperAggregateType<T extends PaperAggregateArgs> = {
        [P in keyof T & keyof AggregatePaper]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaper[P]>
      : GetScalarType<T[P], AggregatePaper[P]>
  }




  export type paperGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paperWhereInput
    orderBy?: paperOrderByWithAggregationInput | paperOrderByWithAggregationInput[]
    by: PaperScalarFieldEnum[] | PaperScalarFieldEnum
    having?: paperScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaperCountAggregateInputType | true
    _avg?: PaperAvgAggregateInputType
    _sum?: PaperSumAggregateInputType
    _min?: PaperMinAggregateInputType
    _max?: PaperMaxAggregateInputType
  }

  export type PaperGroupByOutputType = {
    paper_id: number
    title: string | null
    abstract: string | null
    status: $Enums.PaperStatus | null
    team_id: number | null
    submitted_by: number | null
    pdf_path: string | null
    file_size: number | null
    created_at: Date
    aggregated_decided_at: Date | null
    aggregated_decision: $Enums.ReviewDecision | null
    _count: PaperCountAggregateOutputType | null
    _avg: PaperAvgAggregateOutputType | null
    _sum: PaperSumAggregateOutputType | null
    _min: PaperMinAggregateOutputType | null
    _max: PaperMaxAggregateOutputType | null
  }

  type GetPaperGroupByPayload<T extends paperGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaperGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaperGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaperGroupByOutputType[P]>
            : GetScalarType<T[P], PaperGroupByOutputType[P]>
        }
      >
    >


  export type paperSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    paper_id?: boolean
    title?: boolean
    abstract?: boolean
    status?: boolean
    team_id?: boolean
    submitted_by?: boolean
    pdf_path?: boolean
    file_size?: boolean
    created_at?: boolean
    aggregated_decided_at?: boolean
    aggregated_decision?: boolean
    teacher?: boolean | paper$teacherArgs<ExtArgs>
    team?: boolean | paper$teamArgs<ExtArgs>
    review?: boolean | paper$reviewArgs<ExtArgs>
    reviewerassignment?: boolean | paper$reviewerassignmentArgs<ExtArgs>
    _count?: boolean | PaperCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paper"]>

  export type paperSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    paper_id?: boolean
    title?: boolean
    abstract?: boolean
    status?: boolean
    team_id?: boolean
    submitted_by?: boolean
    pdf_path?: boolean
    file_size?: boolean
    created_at?: boolean
    aggregated_decided_at?: boolean
    aggregated_decision?: boolean
    teacher?: boolean | paper$teacherArgs<ExtArgs>
    team?: boolean | paper$teamArgs<ExtArgs>
  }, ExtArgs["result"]["paper"]>

  export type paperSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    paper_id?: boolean
    title?: boolean
    abstract?: boolean
    status?: boolean
    team_id?: boolean
    submitted_by?: boolean
    pdf_path?: boolean
    file_size?: boolean
    created_at?: boolean
    aggregated_decided_at?: boolean
    aggregated_decision?: boolean
    teacher?: boolean | paper$teacherArgs<ExtArgs>
    team?: boolean | paper$teamArgs<ExtArgs>
  }, ExtArgs["result"]["paper"]>

  export type paperSelectScalar = {
    paper_id?: boolean
    title?: boolean
    abstract?: boolean
    status?: boolean
    team_id?: boolean
    submitted_by?: boolean
    pdf_path?: boolean
    file_size?: boolean
    created_at?: boolean
    aggregated_decided_at?: boolean
    aggregated_decision?: boolean
  }

  export type paperOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"paper_id" | "title" | "abstract" | "status" | "team_id" | "submitted_by" | "pdf_path" | "file_size" | "created_at" | "aggregated_decided_at" | "aggregated_decision", ExtArgs["result"]["paper"]>
  export type paperInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | paper$teacherArgs<ExtArgs>
    team?: boolean | paper$teamArgs<ExtArgs>
    review?: boolean | paper$reviewArgs<ExtArgs>
    reviewerassignment?: boolean | paper$reviewerassignmentArgs<ExtArgs>
    _count?: boolean | PaperCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type paperIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | paper$teacherArgs<ExtArgs>
    team?: boolean | paper$teamArgs<ExtArgs>
  }
  export type paperIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | paper$teacherArgs<ExtArgs>
    team?: boolean | paper$teamArgs<ExtArgs>
  }

  export type $paperPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "paper"
    objects: {
      teacher: Prisma.$teacherPayload<ExtArgs> | null
      team: Prisma.$teamPayload<ExtArgs> | null
      review: Prisma.$reviewPayload<ExtArgs>[]
      reviewerassignment: Prisma.$reviewerassignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      paper_id: number
      title: string | null
      abstract: string | null
      status: $Enums.PaperStatus | null
      team_id: number | null
      submitted_by: number | null
      pdf_path: string | null
      file_size: number | null
      created_at: Date
      aggregated_decided_at: Date | null
      aggregated_decision: $Enums.ReviewDecision | null
    }, ExtArgs["result"]["paper"]>
    composites: {}
  }

  type paperGetPayload<S extends boolean | null | undefined | paperDefaultArgs> = $Result.GetResult<Prisma.$paperPayload, S>

  type paperCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<paperFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaperCountAggregateInputType | true
    }

  export interface paperDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['paper'], meta: { name: 'paper' } }
    /**
     * Find zero or one Paper that matches the filter.
     * @param {paperFindUniqueArgs} args - Arguments to find a Paper
     * @example
     * // Get one Paper
     * const paper = await prisma.paper.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends paperFindUniqueArgs>(args: SelectSubset<T, paperFindUniqueArgs<ExtArgs>>): Prisma__paperClient<$Result.GetResult<Prisma.$paperPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Paper that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {paperFindUniqueOrThrowArgs} args - Arguments to find a Paper
     * @example
     * // Get one Paper
     * const paper = await prisma.paper.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends paperFindUniqueOrThrowArgs>(args: SelectSubset<T, paperFindUniqueOrThrowArgs<ExtArgs>>): Prisma__paperClient<$Result.GetResult<Prisma.$paperPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Paper that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paperFindFirstArgs} args - Arguments to find a Paper
     * @example
     * // Get one Paper
     * const paper = await prisma.paper.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends paperFindFirstArgs>(args?: SelectSubset<T, paperFindFirstArgs<ExtArgs>>): Prisma__paperClient<$Result.GetResult<Prisma.$paperPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Paper that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paperFindFirstOrThrowArgs} args - Arguments to find a Paper
     * @example
     * // Get one Paper
     * const paper = await prisma.paper.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends paperFindFirstOrThrowArgs>(args?: SelectSubset<T, paperFindFirstOrThrowArgs<ExtArgs>>): Prisma__paperClient<$Result.GetResult<Prisma.$paperPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Papers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paperFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Papers
     * const papers = await prisma.paper.findMany()
     * 
     * // Get first 10 Papers
     * const papers = await prisma.paper.findMany({ take: 10 })
     * 
     * // Only select the `paper_id`
     * const paperWithPaper_idOnly = await prisma.paper.findMany({ select: { paper_id: true } })
     * 
     */
    findMany<T extends paperFindManyArgs>(args?: SelectSubset<T, paperFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paperPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Paper.
     * @param {paperCreateArgs} args - Arguments to create a Paper.
     * @example
     * // Create one Paper
     * const Paper = await prisma.paper.create({
     *   data: {
     *     // ... data to create a Paper
     *   }
     * })
     * 
     */
    create<T extends paperCreateArgs>(args: SelectSubset<T, paperCreateArgs<ExtArgs>>): Prisma__paperClient<$Result.GetResult<Prisma.$paperPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Papers.
     * @param {paperCreateManyArgs} args - Arguments to create many Papers.
     * @example
     * // Create many Papers
     * const paper = await prisma.paper.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends paperCreateManyArgs>(args?: SelectSubset<T, paperCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Papers and returns the data saved in the database.
     * @param {paperCreateManyAndReturnArgs} args - Arguments to create many Papers.
     * @example
     * // Create many Papers
     * const paper = await prisma.paper.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Papers and only return the `paper_id`
     * const paperWithPaper_idOnly = await prisma.paper.createManyAndReturn({
     *   select: { paper_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends paperCreateManyAndReturnArgs>(args?: SelectSubset<T, paperCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paperPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Paper.
     * @param {paperDeleteArgs} args - Arguments to delete one Paper.
     * @example
     * // Delete one Paper
     * const Paper = await prisma.paper.delete({
     *   where: {
     *     // ... filter to delete one Paper
     *   }
     * })
     * 
     */
    delete<T extends paperDeleteArgs>(args: SelectSubset<T, paperDeleteArgs<ExtArgs>>): Prisma__paperClient<$Result.GetResult<Prisma.$paperPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Paper.
     * @param {paperUpdateArgs} args - Arguments to update one Paper.
     * @example
     * // Update one Paper
     * const paper = await prisma.paper.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends paperUpdateArgs>(args: SelectSubset<T, paperUpdateArgs<ExtArgs>>): Prisma__paperClient<$Result.GetResult<Prisma.$paperPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Papers.
     * @param {paperDeleteManyArgs} args - Arguments to filter Papers to delete.
     * @example
     * // Delete a few Papers
     * const { count } = await prisma.paper.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends paperDeleteManyArgs>(args?: SelectSubset<T, paperDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Papers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paperUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Papers
     * const paper = await prisma.paper.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends paperUpdateManyArgs>(args: SelectSubset<T, paperUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Papers and returns the data updated in the database.
     * @param {paperUpdateManyAndReturnArgs} args - Arguments to update many Papers.
     * @example
     * // Update many Papers
     * const paper = await prisma.paper.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Papers and only return the `paper_id`
     * const paperWithPaper_idOnly = await prisma.paper.updateManyAndReturn({
     *   select: { paper_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends paperUpdateManyAndReturnArgs>(args: SelectSubset<T, paperUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paperPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Paper.
     * @param {paperUpsertArgs} args - Arguments to update or create a Paper.
     * @example
     * // Update or create a Paper
     * const paper = await prisma.paper.upsert({
     *   create: {
     *     // ... data to create a Paper
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Paper we want to update
     *   }
     * })
     */
    upsert<T extends paperUpsertArgs>(args: SelectSubset<T, paperUpsertArgs<ExtArgs>>): Prisma__paperClient<$Result.GetResult<Prisma.$paperPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Papers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paperCountArgs} args - Arguments to filter Papers to count.
     * @example
     * // Count the number of Papers
     * const count = await prisma.paper.count({
     *   where: {
     *     // ... the filter for the Papers we want to count
     *   }
     * })
    **/
    count<T extends paperCountArgs>(
      args?: Subset<T, paperCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaperCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Paper.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaperAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaperAggregateArgs>(args: Subset<T, PaperAggregateArgs>): Prisma.PrismaPromise<GetPaperAggregateType<T>>

    /**
     * Group by Paper.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paperGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends paperGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: paperGroupByArgs['orderBy'] }
        : { orderBy?: paperGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, paperGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaperGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the paper model
   */
  readonly fields: paperFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for paper.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__paperClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teacher<T extends paper$teacherArgs<ExtArgs> = {}>(args?: Subset<T, paper$teacherArgs<ExtArgs>>): Prisma__teacherClient<$Result.GetResult<Prisma.$teacherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    team<T extends paper$teamArgs<ExtArgs> = {}>(args?: Subset<T, paper$teamArgs<ExtArgs>>): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    review<T extends paper$reviewArgs<ExtArgs> = {}>(args?: Subset<T, paper$reviewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviewerassignment<T extends paper$reviewerassignmentArgs<ExtArgs> = {}>(args?: Subset<T, paper$reviewerassignmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewerassignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the paper model
   */
  interface paperFieldRefs {
    readonly paper_id: FieldRef<"paper", 'Int'>
    readonly title: FieldRef<"paper", 'String'>
    readonly abstract: FieldRef<"paper", 'String'>
    readonly status: FieldRef<"paper", 'PaperStatus'>
    readonly team_id: FieldRef<"paper", 'Int'>
    readonly submitted_by: FieldRef<"paper", 'Int'>
    readonly pdf_path: FieldRef<"paper", 'String'>
    readonly file_size: FieldRef<"paper", 'Int'>
    readonly created_at: FieldRef<"paper", 'DateTime'>
    readonly aggregated_decided_at: FieldRef<"paper", 'DateTime'>
    readonly aggregated_decision: FieldRef<"paper", 'ReviewDecision'>
  }
    

  // Custom InputTypes
  /**
   * paper findUnique
   */
  export type paperFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paper
     */
    select?: paperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paper
     */
    omit?: paperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paperInclude<ExtArgs> | null
    /**
     * Filter, which paper to fetch.
     */
    where: paperWhereUniqueInput
  }

  /**
   * paper findUniqueOrThrow
   */
  export type paperFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paper
     */
    select?: paperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paper
     */
    omit?: paperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paperInclude<ExtArgs> | null
    /**
     * Filter, which paper to fetch.
     */
    where: paperWhereUniqueInput
  }

  /**
   * paper findFirst
   */
  export type paperFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paper
     */
    select?: paperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paper
     */
    omit?: paperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paperInclude<ExtArgs> | null
    /**
     * Filter, which paper to fetch.
     */
    where?: paperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of papers to fetch.
     */
    orderBy?: paperOrderByWithRelationInput | paperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for papers.
     */
    cursor?: paperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` papers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` papers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of papers.
     */
    distinct?: PaperScalarFieldEnum | PaperScalarFieldEnum[]
  }

  /**
   * paper findFirstOrThrow
   */
  export type paperFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paper
     */
    select?: paperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paper
     */
    omit?: paperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paperInclude<ExtArgs> | null
    /**
     * Filter, which paper to fetch.
     */
    where?: paperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of papers to fetch.
     */
    orderBy?: paperOrderByWithRelationInput | paperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for papers.
     */
    cursor?: paperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` papers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` papers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of papers.
     */
    distinct?: PaperScalarFieldEnum | PaperScalarFieldEnum[]
  }

  /**
   * paper findMany
   */
  export type paperFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paper
     */
    select?: paperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paper
     */
    omit?: paperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paperInclude<ExtArgs> | null
    /**
     * Filter, which papers to fetch.
     */
    where?: paperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of papers to fetch.
     */
    orderBy?: paperOrderByWithRelationInput | paperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing papers.
     */
    cursor?: paperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` papers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` papers.
     */
    skip?: number
    distinct?: PaperScalarFieldEnum | PaperScalarFieldEnum[]
  }

  /**
   * paper create
   */
  export type paperCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paper
     */
    select?: paperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paper
     */
    omit?: paperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paperInclude<ExtArgs> | null
    /**
     * The data needed to create a paper.
     */
    data?: XOR<paperCreateInput, paperUncheckedCreateInput>
  }

  /**
   * paper createMany
   */
  export type paperCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many papers.
     */
    data: paperCreateManyInput | paperCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * paper createManyAndReturn
   */
  export type paperCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paper
     */
    select?: paperSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the paper
     */
    omit?: paperOmit<ExtArgs> | null
    /**
     * The data used to create many papers.
     */
    data: paperCreateManyInput | paperCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paperIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * paper update
   */
  export type paperUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paper
     */
    select?: paperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paper
     */
    omit?: paperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paperInclude<ExtArgs> | null
    /**
     * The data needed to update a paper.
     */
    data: XOR<paperUpdateInput, paperUncheckedUpdateInput>
    /**
     * Choose, which paper to update.
     */
    where: paperWhereUniqueInput
  }

  /**
   * paper updateMany
   */
  export type paperUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update papers.
     */
    data: XOR<paperUpdateManyMutationInput, paperUncheckedUpdateManyInput>
    /**
     * Filter which papers to update
     */
    where?: paperWhereInput
    /**
     * Limit how many papers to update.
     */
    limit?: number
  }

  /**
   * paper updateManyAndReturn
   */
  export type paperUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paper
     */
    select?: paperSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the paper
     */
    omit?: paperOmit<ExtArgs> | null
    /**
     * The data used to update papers.
     */
    data: XOR<paperUpdateManyMutationInput, paperUncheckedUpdateManyInput>
    /**
     * Filter which papers to update
     */
    where?: paperWhereInput
    /**
     * Limit how many papers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paperIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * paper upsert
   */
  export type paperUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paper
     */
    select?: paperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paper
     */
    omit?: paperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paperInclude<ExtArgs> | null
    /**
     * The filter to search for the paper to update in case it exists.
     */
    where: paperWhereUniqueInput
    /**
     * In case the paper found by the `where` argument doesn't exist, create a new paper with this data.
     */
    create: XOR<paperCreateInput, paperUncheckedCreateInput>
    /**
     * In case the paper was found with the provided `where` argument, update it with this data.
     */
    update: XOR<paperUpdateInput, paperUncheckedUpdateInput>
  }

  /**
   * paper delete
   */
  export type paperDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paper
     */
    select?: paperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paper
     */
    omit?: paperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paperInclude<ExtArgs> | null
    /**
     * Filter which paper to delete.
     */
    where: paperWhereUniqueInput
  }

  /**
   * paper deleteMany
   */
  export type paperDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which papers to delete
     */
    where?: paperWhereInput
    /**
     * Limit how many papers to delete.
     */
    limit?: number
  }

  /**
   * paper.teacher
   */
  export type paper$teacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher
     */
    select?: teacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher
     */
    omit?: teacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacherInclude<ExtArgs> | null
    where?: teacherWhereInput
  }

  /**
   * paper.team
   */
  export type paper$teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the team
     */
    omit?: teamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamInclude<ExtArgs> | null
    where?: teamWhereInput
  }

  /**
   * paper.review
   */
  export type paper$reviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review
     */
    select?: reviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the review
     */
    omit?: reviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewInclude<ExtArgs> | null
    where?: reviewWhereInput
    orderBy?: reviewOrderByWithRelationInput | reviewOrderByWithRelationInput[]
    cursor?: reviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * paper.reviewerassignment
   */
  export type paper$reviewerassignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewerassignment
     */
    select?: reviewerassignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewerassignment
     */
    omit?: reviewerassignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewerassignmentInclude<ExtArgs> | null
    where?: reviewerassignmentWhereInput
    orderBy?: reviewerassignmentOrderByWithRelationInput | reviewerassignmentOrderByWithRelationInput[]
    cursor?: reviewerassignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewerassignmentScalarFieldEnum | ReviewerassignmentScalarFieldEnum[]
  }

  /**
   * paper without action
   */
  export type paperDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paper
     */
    select?: paperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paper
     */
    omit?: paperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paperInclude<ExtArgs> | null
  }


  /**
   * Model proposal
   */

  export type AggregateProposal = {
    _count: ProposalCountAggregateOutputType | null
    _avg: ProposalAvgAggregateOutputType | null
    _sum: ProposalSumAggregateOutputType | null
    _min: ProposalMinAggregateOutputType | null
    _max: ProposalMaxAggregateOutputType | null
  }

  export type ProposalAvgAggregateOutputType = {
    proposal_id: number | null
    team_id: number | null
    submitted_by: number | null
    file_size: number | null
  }

  export type ProposalSumAggregateOutputType = {
    proposal_id: number | null
    team_id: number | null
    submitted_by: number | null
    file_size: number | null
  }

  export type ProposalMinAggregateOutputType = {
    proposal_id: number | null
    title: string | null
    abstract: string | null
    status: $Enums.PaperStatus | null
    team_id: number | null
    submitted_by: number | null
    pdf_path: string | null
    file_size: number | null
    created_at: Date | null
    aggregated_decided_at: Date | null
    aggregated_decision: $Enums.ReviewDecision | null
  }

  export type ProposalMaxAggregateOutputType = {
    proposal_id: number | null
    title: string | null
    abstract: string | null
    status: $Enums.PaperStatus | null
    team_id: number | null
    submitted_by: number | null
    pdf_path: string | null
    file_size: number | null
    created_at: Date | null
    aggregated_decided_at: Date | null
    aggregated_decision: $Enums.ReviewDecision | null
  }

  export type ProposalCountAggregateOutputType = {
    proposal_id: number
    title: number
    abstract: number
    status: number
    team_id: number
    submitted_by: number
    pdf_path: number
    file_size: number
    created_at: number
    aggregated_decided_at: number
    aggregated_decision: number
    _all: number
  }


  export type ProposalAvgAggregateInputType = {
    proposal_id?: true
    team_id?: true
    submitted_by?: true
    file_size?: true
  }

  export type ProposalSumAggregateInputType = {
    proposal_id?: true
    team_id?: true
    submitted_by?: true
    file_size?: true
  }

  export type ProposalMinAggregateInputType = {
    proposal_id?: true
    title?: true
    abstract?: true
    status?: true
    team_id?: true
    submitted_by?: true
    pdf_path?: true
    file_size?: true
    created_at?: true
    aggregated_decided_at?: true
    aggregated_decision?: true
  }

  export type ProposalMaxAggregateInputType = {
    proposal_id?: true
    title?: true
    abstract?: true
    status?: true
    team_id?: true
    submitted_by?: true
    pdf_path?: true
    file_size?: true
    created_at?: true
    aggregated_decided_at?: true
    aggregated_decision?: true
  }

  export type ProposalCountAggregateInputType = {
    proposal_id?: true
    title?: true
    abstract?: true
    status?: true
    team_id?: true
    submitted_by?: true
    pdf_path?: true
    file_size?: true
    created_at?: true
    aggregated_decided_at?: true
    aggregated_decision?: true
    _all?: true
  }

  export type ProposalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which proposal to aggregate.
     */
    where?: proposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proposals to fetch.
     */
    orderBy?: proposalOrderByWithRelationInput | proposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: proposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned proposals
    **/
    _count?: true | ProposalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProposalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProposalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProposalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProposalMaxAggregateInputType
  }

  export type GetProposalAggregateType<T extends ProposalAggregateArgs> = {
        [P in keyof T & keyof AggregateProposal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProposal[P]>
      : GetScalarType<T[P], AggregateProposal[P]>
  }




  export type proposalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: proposalWhereInput
    orderBy?: proposalOrderByWithAggregationInput | proposalOrderByWithAggregationInput[]
    by: ProposalScalarFieldEnum[] | ProposalScalarFieldEnum
    having?: proposalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProposalCountAggregateInputType | true
    _avg?: ProposalAvgAggregateInputType
    _sum?: ProposalSumAggregateInputType
    _min?: ProposalMinAggregateInputType
    _max?: ProposalMaxAggregateInputType
  }

  export type ProposalGroupByOutputType = {
    proposal_id: number
    title: string | null
    abstract: string | null
    status: $Enums.PaperStatus | null
    team_id: number | null
    submitted_by: number | null
    pdf_path: string | null
    file_size: number | null
    created_at: Date
    aggregated_decided_at: Date | null
    aggregated_decision: $Enums.ReviewDecision | null
    _count: ProposalCountAggregateOutputType | null
    _avg: ProposalAvgAggregateOutputType | null
    _sum: ProposalSumAggregateOutputType | null
    _min: ProposalMinAggregateOutputType | null
    _max: ProposalMaxAggregateOutputType | null
  }

  type GetProposalGroupByPayload<T extends proposalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProposalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProposalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProposalGroupByOutputType[P]>
            : GetScalarType<T[P], ProposalGroupByOutputType[P]>
        }
      >
    >


  export type proposalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    proposal_id?: boolean
    title?: boolean
    abstract?: boolean
    status?: boolean
    team_id?: boolean
    submitted_by?: boolean
    pdf_path?: boolean
    file_size?: boolean
    created_at?: boolean
    aggregated_decided_at?: boolean
    aggregated_decision?: boolean
    teacher?: boolean | proposal$teacherArgs<ExtArgs>
    team?: boolean | proposal$teamArgs<ExtArgs>
    review?: boolean | proposal$reviewArgs<ExtArgs>
    reviewerassignment?: boolean | proposal$reviewerassignmentArgs<ExtArgs>
    _count?: boolean | ProposalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proposal"]>

  export type proposalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    proposal_id?: boolean
    title?: boolean
    abstract?: boolean
    status?: boolean
    team_id?: boolean
    submitted_by?: boolean
    pdf_path?: boolean
    file_size?: boolean
    created_at?: boolean
    aggregated_decided_at?: boolean
    aggregated_decision?: boolean
    teacher?: boolean | proposal$teacherArgs<ExtArgs>
    team?: boolean | proposal$teamArgs<ExtArgs>
  }, ExtArgs["result"]["proposal"]>

  export type proposalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    proposal_id?: boolean
    title?: boolean
    abstract?: boolean
    status?: boolean
    team_id?: boolean
    submitted_by?: boolean
    pdf_path?: boolean
    file_size?: boolean
    created_at?: boolean
    aggregated_decided_at?: boolean
    aggregated_decision?: boolean
    teacher?: boolean | proposal$teacherArgs<ExtArgs>
    team?: boolean | proposal$teamArgs<ExtArgs>
  }, ExtArgs["result"]["proposal"]>

  export type proposalSelectScalar = {
    proposal_id?: boolean
    title?: boolean
    abstract?: boolean
    status?: boolean
    team_id?: boolean
    submitted_by?: boolean
    pdf_path?: boolean
    file_size?: boolean
    created_at?: boolean
    aggregated_decided_at?: boolean
    aggregated_decision?: boolean
  }

  export type proposalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"proposal_id" | "title" | "abstract" | "status" | "team_id" | "submitted_by" | "pdf_path" | "file_size" | "created_at" | "aggregated_decided_at" | "aggregated_decision", ExtArgs["result"]["proposal"]>
  export type proposalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | proposal$teacherArgs<ExtArgs>
    team?: boolean | proposal$teamArgs<ExtArgs>
    review?: boolean | proposal$reviewArgs<ExtArgs>
    reviewerassignment?: boolean | proposal$reviewerassignmentArgs<ExtArgs>
    _count?: boolean | ProposalCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type proposalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | proposal$teacherArgs<ExtArgs>
    team?: boolean | proposal$teamArgs<ExtArgs>
  }
  export type proposalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | proposal$teacherArgs<ExtArgs>
    team?: boolean | proposal$teamArgs<ExtArgs>
  }

  export type $proposalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "proposal"
    objects: {
      teacher: Prisma.$teacherPayload<ExtArgs> | null
      team: Prisma.$teamPayload<ExtArgs> | null
      review: Prisma.$reviewPayload<ExtArgs>[]
      reviewerassignment: Prisma.$reviewerassignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      proposal_id: number
      title: string | null
      abstract: string | null
      status: $Enums.PaperStatus | null
      team_id: number | null
      submitted_by: number | null
      pdf_path: string | null
      file_size: number | null
      created_at: Date
      aggregated_decided_at: Date | null
      aggregated_decision: $Enums.ReviewDecision | null
    }, ExtArgs["result"]["proposal"]>
    composites: {}
  }

  type proposalGetPayload<S extends boolean | null | undefined | proposalDefaultArgs> = $Result.GetResult<Prisma.$proposalPayload, S>

  type proposalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<proposalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProposalCountAggregateInputType | true
    }

  export interface proposalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['proposal'], meta: { name: 'proposal' } }
    /**
     * Find zero or one Proposal that matches the filter.
     * @param {proposalFindUniqueArgs} args - Arguments to find a Proposal
     * @example
     * // Get one Proposal
     * const proposal = await prisma.proposal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends proposalFindUniqueArgs>(args: SelectSubset<T, proposalFindUniqueArgs<ExtArgs>>): Prisma__proposalClient<$Result.GetResult<Prisma.$proposalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Proposal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {proposalFindUniqueOrThrowArgs} args - Arguments to find a Proposal
     * @example
     * // Get one Proposal
     * const proposal = await prisma.proposal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends proposalFindUniqueOrThrowArgs>(args: SelectSubset<T, proposalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__proposalClient<$Result.GetResult<Prisma.$proposalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Proposal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proposalFindFirstArgs} args - Arguments to find a Proposal
     * @example
     * // Get one Proposal
     * const proposal = await prisma.proposal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends proposalFindFirstArgs>(args?: SelectSubset<T, proposalFindFirstArgs<ExtArgs>>): Prisma__proposalClient<$Result.GetResult<Prisma.$proposalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Proposal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proposalFindFirstOrThrowArgs} args - Arguments to find a Proposal
     * @example
     * // Get one Proposal
     * const proposal = await prisma.proposal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends proposalFindFirstOrThrowArgs>(args?: SelectSubset<T, proposalFindFirstOrThrowArgs<ExtArgs>>): Prisma__proposalClient<$Result.GetResult<Prisma.$proposalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Proposals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proposalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Proposals
     * const proposals = await prisma.proposal.findMany()
     * 
     * // Get first 10 Proposals
     * const proposals = await prisma.proposal.findMany({ take: 10 })
     * 
     * // Only select the `proposal_id`
     * const proposalWithProposal_idOnly = await prisma.proposal.findMany({ select: { proposal_id: true } })
     * 
     */
    findMany<T extends proposalFindManyArgs>(args?: SelectSubset<T, proposalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$proposalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Proposal.
     * @param {proposalCreateArgs} args - Arguments to create a Proposal.
     * @example
     * // Create one Proposal
     * const Proposal = await prisma.proposal.create({
     *   data: {
     *     // ... data to create a Proposal
     *   }
     * })
     * 
     */
    create<T extends proposalCreateArgs>(args: SelectSubset<T, proposalCreateArgs<ExtArgs>>): Prisma__proposalClient<$Result.GetResult<Prisma.$proposalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Proposals.
     * @param {proposalCreateManyArgs} args - Arguments to create many Proposals.
     * @example
     * // Create many Proposals
     * const proposal = await prisma.proposal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends proposalCreateManyArgs>(args?: SelectSubset<T, proposalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Proposals and returns the data saved in the database.
     * @param {proposalCreateManyAndReturnArgs} args - Arguments to create many Proposals.
     * @example
     * // Create many Proposals
     * const proposal = await prisma.proposal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Proposals and only return the `proposal_id`
     * const proposalWithProposal_idOnly = await prisma.proposal.createManyAndReturn({
     *   select: { proposal_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends proposalCreateManyAndReturnArgs>(args?: SelectSubset<T, proposalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$proposalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Proposal.
     * @param {proposalDeleteArgs} args - Arguments to delete one Proposal.
     * @example
     * // Delete one Proposal
     * const Proposal = await prisma.proposal.delete({
     *   where: {
     *     // ... filter to delete one Proposal
     *   }
     * })
     * 
     */
    delete<T extends proposalDeleteArgs>(args: SelectSubset<T, proposalDeleteArgs<ExtArgs>>): Prisma__proposalClient<$Result.GetResult<Prisma.$proposalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Proposal.
     * @param {proposalUpdateArgs} args - Arguments to update one Proposal.
     * @example
     * // Update one Proposal
     * const proposal = await prisma.proposal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends proposalUpdateArgs>(args: SelectSubset<T, proposalUpdateArgs<ExtArgs>>): Prisma__proposalClient<$Result.GetResult<Prisma.$proposalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Proposals.
     * @param {proposalDeleteManyArgs} args - Arguments to filter Proposals to delete.
     * @example
     * // Delete a few Proposals
     * const { count } = await prisma.proposal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends proposalDeleteManyArgs>(args?: SelectSubset<T, proposalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Proposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proposalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Proposals
     * const proposal = await prisma.proposal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends proposalUpdateManyArgs>(args: SelectSubset<T, proposalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Proposals and returns the data updated in the database.
     * @param {proposalUpdateManyAndReturnArgs} args - Arguments to update many Proposals.
     * @example
     * // Update many Proposals
     * const proposal = await prisma.proposal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Proposals and only return the `proposal_id`
     * const proposalWithProposal_idOnly = await prisma.proposal.updateManyAndReturn({
     *   select: { proposal_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends proposalUpdateManyAndReturnArgs>(args: SelectSubset<T, proposalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$proposalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Proposal.
     * @param {proposalUpsertArgs} args - Arguments to update or create a Proposal.
     * @example
     * // Update or create a Proposal
     * const proposal = await prisma.proposal.upsert({
     *   create: {
     *     // ... data to create a Proposal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Proposal we want to update
     *   }
     * })
     */
    upsert<T extends proposalUpsertArgs>(args: SelectSubset<T, proposalUpsertArgs<ExtArgs>>): Prisma__proposalClient<$Result.GetResult<Prisma.$proposalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Proposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proposalCountArgs} args - Arguments to filter Proposals to count.
     * @example
     * // Count the number of Proposals
     * const count = await prisma.proposal.count({
     *   where: {
     *     // ... the filter for the Proposals we want to count
     *   }
     * })
    **/
    count<T extends proposalCountArgs>(
      args?: Subset<T, proposalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProposalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Proposal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProposalAggregateArgs>(args: Subset<T, ProposalAggregateArgs>): Prisma.PrismaPromise<GetProposalAggregateType<T>>

    /**
     * Group by Proposal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proposalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends proposalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: proposalGroupByArgs['orderBy'] }
        : { orderBy?: proposalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, proposalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProposalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the proposal model
   */
  readonly fields: proposalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for proposal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__proposalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teacher<T extends proposal$teacherArgs<ExtArgs> = {}>(args?: Subset<T, proposal$teacherArgs<ExtArgs>>): Prisma__teacherClient<$Result.GetResult<Prisma.$teacherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    team<T extends proposal$teamArgs<ExtArgs> = {}>(args?: Subset<T, proposal$teamArgs<ExtArgs>>): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    review<T extends proposal$reviewArgs<ExtArgs> = {}>(args?: Subset<T, proposal$reviewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviewerassignment<T extends proposal$reviewerassignmentArgs<ExtArgs> = {}>(args?: Subset<T, proposal$reviewerassignmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewerassignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the proposal model
   */
  interface proposalFieldRefs {
    readonly proposal_id: FieldRef<"proposal", 'Int'>
    readonly title: FieldRef<"proposal", 'String'>
    readonly abstract: FieldRef<"proposal", 'String'>
    readonly status: FieldRef<"proposal", 'PaperStatus'>
    readonly team_id: FieldRef<"proposal", 'Int'>
    readonly submitted_by: FieldRef<"proposal", 'Int'>
    readonly pdf_path: FieldRef<"proposal", 'String'>
    readonly file_size: FieldRef<"proposal", 'Int'>
    readonly created_at: FieldRef<"proposal", 'DateTime'>
    readonly aggregated_decided_at: FieldRef<"proposal", 'DateTime'>
    readonly aggregated_decision: FieldRef<"proposal", 'ReviewDecision'>
  }
    

  // Custom InputTypes
  /**
   * proposal findUnique
   */
  export type proposalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proposal
     */
    select?: proposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proposal
     */
    omit?: proposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proposalInclude<ExtArgs> | null
    /**
     * Filter, which proposal to fetch.
     */
    where: proposalWhereUniqueInput
  }

  /**
   * proposal findUniqueOrThrow
   */
  export type proposalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proposal
     */
    select?: proposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proposal
     */
    omit?: proposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proposalInclude<ExtArgs> | null
    /**
     * Filter, which proposal to fetch.
     */
    where: proposalWhereUniqueInput
  }

  /**
   * proposal findFirst
   */
  export type proposalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proposal
     */
    select?: proposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proposal
     */
    omit?: proposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proposalInclude<ExtArgs> | null
    /**
     * Filter, which proposal to fetch.
     */
    where?: proposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proposals to fetch.
     */
    orderBy?: proposalOrderByWithRelationInput | proposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for proposals.
     */
    cursor?: proposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of proposals.
     */
    distinct?: ProposalScalarFieldEnum | ProposalScalarFieldEnum[]
  }

  /**
   * proposal findFirstOrThrow
   */
  export type proposalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proposal
     */
    select?: proposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proposal
     */
    omit?: proposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proposalInclude<ExtArgs> | null
    /**
     * Filter, which proposal to fetch.
     */
    where?: proposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proposals to fetch.
     */
    orderBy?: proposalOrderByWithRelationInput | proposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for proposals.
     */
    cursor?: proposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of proposals.
     */
    distinct?: ProposalScalarFieldEnum | ProposalScalarFieldEnum[]
  }

  /**
   * proposal findMany
   */
  export type proposalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proposal
     */
    select?: proposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proposal
     */
    omit?: proposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proposalInclude<ExtArgs> | null
    /**
     * Filter, which proposals to fetch.
     */
    where?: proposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proposals to fetch.
     */
    orderBy?: proposalOrderByWithRelationInput | proposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing proposals.
     */
    cursor?: proposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proposals.
     */
    skip?: number
    distinct?: ProposalScalarFieldEnum | ProposalScalarFieldEnum[]
  }

  /**
   * proposal create
   */
  export type proposalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proposal
     */
    select?: proposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proposal
     */
    omit?: proposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proposalInclude<ExtArgs> | null
    /**
     * The data needed to create a proposal.
     */
    data?: XOR<proposalCreateInput, proposalUncheckedCreateInput>
  }

  /**
   * proposal createMany
   */
  export type proposalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many proposals.
     */
    data: proposalCreateManyInput | proposalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * proposal createManyAndReturn
   */
  export type proposalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proposal
     */
    select?: proposalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the proposal
     */
    omit?: proposalOmit<ExtArgs> | null
    /**
     * The data used to create many proposals.
     */
    data: proposalCreateManyInput | proposalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proposalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * proposal update
   */
  export type proposalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proposal
     */
    select?: proposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proposal
     */
    omit?: proposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proposalInclude<ExtArgs> | null
    /**
     * The data needed to update a proposal.
     */
    data: XOR<proposalUpdateInput, proposalUncheckedUpdateInput>
    /**
     * Choose, which proposal to update.
     */
    where: proposalWhereUniqueInput
  }

  /**
   * proposal updateMany
   */
  export type proposalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update proposals.
     */
    data: XOR<proposalUpdateManyMutationInput, proposalUncheckedUpdateManyInput>
    /**
     * Filter which proposals to update
     */
    where?: proposalWhereInput
    /**
     * Limit how many proposals to update.
     */
    limit?: number
  }

  /**
   * proposal updateManyAndReturn
   */
  export type proposalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proposal
     */
    select?: proposalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the proposal
     */
    omit?: proposalOmit<ExtArgs> | null
    /**
     * The data used to update proposals.
     */
    data: XOR<proposalUpdateManyMutationInput, proposalUncheckedUpdateManyInput>
    /**
     * Filter which proposals to update
     */
    where?: proposalWhereInput
    /**
     * Limit how many proposals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proposalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * proposal upsert
   */
  export type proposalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proposal
     */
    select?: proposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proposal
     */
    omit?: proposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proposalInclude<ExtArgs> | null
    /**
     * The filter to search for the proposal to update in case it exists.
     */
    where: proposalWhereUniqueInput
    /**
     * In case the proposal found by the `where` argument doesn't exist, create a new proposal with this data.
     */
    create: XOR<proposalCreateInput, proposalUncheckedCreateInput>
    /**
     * In case the proposal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<proposalUpdateInput, proposalUncheckedUpdateInput>
  }

  /**
   * proposal delete
   */
  export type proposalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proposal
     */
    select?: proposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proposal
     */
    omit?: proposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proposalInclude<ExtArgs> | null
    /**
     * Filter which proposal to delete.
     */
    where: proposalWhereUniqueInput
  }

  /**
   * proposal deleteMany
   */
  export type proposalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which proposals to delete
     */
    where?: proposalWhereInput
    /**
     * Limit how many proposals to delete.
     */
    limit?: number
  }

  /**
   * proposal.teacher
   */
  export type proposal$teacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher
     */
    select?: teacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher
     */
    omit?: teacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacherInclude<ExtArgs> | null
    where?: teacherWhereInput
  }

  /**
   * proposal.team
   */
  export type proposal$teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the team
     */
    omit?: teamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamInclude<ExtArgs> | null
    where?: teamWhereInput
  }

  /**
   * proposal.review
   */
  export type proposal$reviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review
     */
    select?: reviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the review
     */
    omit?: reviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewInclude<ExtArgs> | null
    where?: reviewWhereInput
    orderBy?: reviewOrderByWithRelationInput | reviewOrderByWithRelationInput[]
    cursor?: reviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * proposal.reviewerassignment
   */
  export type proposal$reviewerassignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewerassignment
     */
    select?: reviewerassignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewerassignment
     */
    omit?: reviewerassignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewerassignmentInclude<ExtArgs> | null
    where?: reviewerassignmentWhereInput
    orderBy?: reviewerassignmentOrderByWithRelationInput | reviewerassignmentOrderByWithRelationInput[]
    cursor?: reviewerassignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewerassignmentScalarFieldEnum | ReviewerassignmentScalarFieldEnum[]
  }

  /**
   * proposal without action
   */
  export type proposalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proposal
     */
    select?: proposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proposal
     */
    omit?: proposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proposalInclude<ExtArgs> | null
  }


  /**
   * Model review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    review_id: number | null
    reviewer_id: number | null
    proposal_id: number | null
    paper_id: number | null
    score: number | null
  }

  export type ReviewSumAggregateOutputType = {
    review_id: number | null
    reviewer_id: number | null
    proposal_id: number | null
    paper_id: number | null
    score: number | null
  }

  export type ReviewMinAggregateOutputType = {
    review_id: number | null
    reviewer_id: number | null
    proposal_id: number | null
    paper_id: number | null
    comments: string | null
    score: number | null
    reviewed_at: Date | null
    attachment_path: string | null
    decision: $Enums.ReviewDecision | null
  }

  export type ReviewMaxAggregateOutputType = {
    review_id: number | null
    reviewer_id: number | null
    proposal_id: number | null
    paper_id: number | null
    comments: string | null
    score: number | null
    reviewed_at: Date | null
    attachment_path: string | null
    decision: $Enums.ReviewDecision | null
  }

  export type ReviewCountAggregateOutputType = {
    review_id: number
    reviewer_id: number
    proposal_id: number
    paper_id: number
    comments: number
    score: number
    reviewed_at: number
    attachment_path: number
    decision: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    review_id?: true
    reviewer_id?: true
    proposal_id?: true
    paper_id?: true
    score?: true
  }

  export type ReviewSumAggregateInputType = {
    review_id?: true
    reviewer_id?: true
    proposal_id?: true
    paper_id?: true
    score?: true
  }

  export type ReviewMinAggregateInputType = {
    review_id?: true
    reviewer_id?: true
    proposal_id?: true
    paper_id?: true
    comments?: true
    score?: true
    reviewed_at?: true
    attachment_path?: true
    decision?: true
  }

  export type ReviewMaxAggregateInputType = {
    review_id?: true
    reviewer_id?: true
    proposal_id?: true
    paper_id?: true
    comments?: true
    score?: true
    reviewed_at?: true
    attachment_path?: true
    decision?: true
  }

  export type ReviewCountAggregateInputType = {
    review_id?: true
    reviewer_id?: true
    proposal_id?: true
    paper_id?: true
    comments?: true
    score?: true
    reviewed_at?: true
    attachment_path?: true
    decision?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which review to aggregate.
     */
    where?: reviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews to fetch.
     */
    orderBy?: reviewOrderByWithRelationInput | reviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: reviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type reviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reviewWhereInput
    orderBy?: reviewOrderByWithAggregationInput | reviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: reviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    review_id: number
    reviewer_id: number | null
    proposal_id: number | null
    paper_id: number | null
    comments: string | null
    score: number | null
    reviewed_at: Date
    attachment_path: string | null
    decision: $Enums.ReviewDecision | null
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends reviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type reviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    review_id?: boolean
    reviewer_id?: boolean
    proposal_id?: boolean
    paper_id?: boolean
    comments?: boolean
    score?: boolean
    reviewed_at?: boolean
    attachment_path?: boolean
    decision?: boolean
    paper?: boolean | review$paperArgs<ExtArgs>
    proposal?: boolean | review$proposalArgs<ExtArgs>
    reviewer?: boolean | review$reviewerArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type reviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    review_id?: boolean
    reviewer_id?: boolean
    proposal_id?: boolean
    paper_id?: boolean
    comments?: boolean
    score?: boolean
    reviewed_at?: boolean
    attachment_path?: boolean
    decision?: boolean
    paper?: boolean | review$paperArgs<ExtArgs>
    proposal?: boolean | review$proposalArgs<ExtArgs>
    reviewer?: boolean | review$reviewerArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type reviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    review_id?: boolean
    reviewer_id?: boolean
    proposal_id?: boolean
    paper_id?: boolean
    comments?: boolean
    score?: boolean
    reviewed_at?: boolean
    attachment_path?: boolean
    decision?: boolean
    paper?: boolean | review$paperArgs<ExtArgs>
    proposal?: boolean | review$proposalArgs<ExtArgs>
    reviewer?: boolean | review$reviewerArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type reviewSelectScalar = {
    review_id?: boolean
    reviewer_id?: boolean
    proposal_id?: boolean
    paper_id?: boolean
    comments?: boolean
    score?: boolean
    reviewed_at?: boolean
    attachment_path?: boolean
    decision?: boolean
  }

  export type reviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"review_id" | "reviewer_id" | "proposal_id" | "paper_id" | "comments" | "score" | "reviewed_at" | "attachment_path" | "decision", ExtArgs["result"]["review"]>
  export type reviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paper?: boolean | review$paperArgs<ExtArgs>
    proposal?: boolean | review$proposalArgs<ExtArgs>
    reviewer?: boolean | review$reviewerArgs<ExtArgs>
  }
  export type reviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paper?: boolean | review$paperArgs<ExtArgs>
    proposal?: boolean | review$proposalArgs<ExtArgs>
    reviewer?: boolean | review$reviewerArgs<ExtArgs>
  }
  export type reviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paper?: boolean | review$paperArgs<ExtArgs>
    proposal?: boolean | review$proposalArgs<ExtArgs>
    reviewer?: boolean | review$reviewerArgs<ExtArgs>
  }

  export type $reviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "review"
    objects: {
      paper: Prisma.$paperPayload<ExtArgs> | null
      proposal: Prisma.$proposalPayload<ExtArgs> | null
      reviewer: Prisma.$reviewerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      review_id: number
      reviewer_id: number | null
      proposal_id: number | null
      paper_id: number | null
      comments: string | null
      score: number | null
      reviewed_at: Date
      attachment_path: string | null
      decision: $Enums.ReviewDecision | null
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type reviewGetPayload<S extends boolean | null | undefined | reviewDefaultArgs> = $Result.GetResult<Prisma.$reviewPayload, S>

  type reviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<reviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface reviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['review'], meta: { name: 'review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {reviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends reviewFindUniqueArgs>(args: SelectSubset<T, reviewFindUniqueArgs<ExtArgs>>): Prisma__reviewClient<$Result.GetResult<Prisma.$reviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {reviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends reviewFindUniqueOrThrowArgs>(args: SelectSubset<T, reviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__reviewClient<$Result.GetResult<Prisma.$reviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends reviewFindFirstArgs>(args?: SelectSubset<T, reviewFindFirstArgs<ExtArgs>>): Prisma__reviewClient<$Result.GetResult<Prisma.$reviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends reviewFindFirstOrThrowArgs>(args?: SelectSubset<T, reviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__reviewClient<$Result.GetResult<Prisma.$reviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `review_id`
     * const reviewWithReview_idOnly = await prisma.review.findMany({ select: { review_id: true } })
     * 
     */
    findMany<T extends reviewFindManyArgs>(args?: SelectSubset<T, reviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Review.
     * @param {reviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends reviewCreateArgs>(args: SelectSubset<T, reviewCreateArgs<ExtArgs>>): Prisma__reviewClient<$Result.GetResult<Prisma.$reviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reviews.
     * @param {reviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends reviewCreateManyArgs>(args?: SelectSubset<T, reviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {reviewCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `review_id`
     * const reviewWithReview_idOnly = await prisma.review.createManyAndReturn({
     *   select: { review_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends reviewCreateManyAndReturnArgs>(args?: SelectSubset<T, reviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Review.
     * @param {reviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends reviewDeleteArgs>(args: SelectSubset<T, reviewDeleteArgs<ExtArgs>>): Prisma__reviewClient<$Result.GetResult<Prisma.$reviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Review.
     * @param {reviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends reviewUpdateArgs>(args: SelectSubset<T, reviewUpdateArgs<ExtArgs>>): Prisma__reviewClient<$Result.GetResult<Prisma.$reviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reviews.
     * @param {reviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends reviewDeleteManyArgs>(args?: SelectSubset<T, reviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends reviewUpdateManyArgs>(args: SelectSubset<T, reviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews and returns the data updated in the database.
     * @param {reviewUpdateManyAndReturnArgs} args - Arguments to update many Reviews.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reviews and only return the `review_id`
     * const reviewWithReview_idOnly = await prisma.review.updateManyAndReturn({
     *   select: { review_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends reviewUpdateManyAndReturnArgs>(args: SelectSubset<T, reviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Review.
     * @param {reviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends reviewUpsertArgs>(args: SelectSubset<T, reviewUpsertArgs<ExtArgs>>): Prisma__reviewClient<$Result.GetResult<Prisma.$reviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends reviewCountArgs>(
      args?: Subset<T, reviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends reviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: reviewGroupByArgs['orderBy'] }
        : { orderBy?: reviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, reviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the review model
   */
  readonly fields: reviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__reviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    paper<T extends review$paperArgs<ExtArgs> = {}>(args?: Subset<T, review$paperArgs<ExtArgs>>): Prisma__paperClient<$Result.GetResult<Prisma.$paperPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    proposal<T extends review$proposalArgs<ExtArgs> = {}>(args?: Subset<T, review$proposalArgs<ExtArgs>>): Prisma__proposalClient<$Result.GetResult<Prisma.$proposalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    reviewer<T extends review$reviewerArgs<ExtArgs> = {}>(args?: Subset<T, review$reviewerArgs<ExtArgs>>): Prisma__reviewerClient<$Result.GetResult<Prisma.$reviewerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the review model
   */
  interface reviewFieldRefs {
    readonly review_id: FieldRef<"review", 'Int'>
    readonly reviewer_id: FieldRef<"review", 'Int'>
    readonly proposal_id: FieldRef<"review", 'Int'>
    readonly paper_id: FieldRef<"review", 'Int'>
    readonly comments: FieldRef<"review", 'String'>
    readonly score: FieldRef<"review", 'Int'>
    readonly reviewed_at: FieldRef<"review", 'DateTime'>
    readonly attachment_path: FieldRef<"review", 'String'>
    readonly decision: FieldRef<"review", 'ReviewDecision'>
  }
    

  // Custom InputTypes
  /**
   * review findUnique
   */
  export type reviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review
     */
    select?: reviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the review
     */
    omit?: reviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewInclude<ExtArgs> | null
    /**
     * Filter, which review to fetch.
     */
    where: reviewWhereUniqueInput
  }

  /**
   * review findUniqueOrThrow
   */
  export type reviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review
     */
    select?: reviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the review
     */
    omit?: reviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewInclude<ExtArgs> | null
    /**
     * Filter, which review to fetch.
     */
    where: reviewWhereUniqueInput
  }

  /**
   * review findFirst
   */
  export type reviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review
     */
    select?: reviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the review
     */
    omit?: reviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewInclude<ExtArgs> | null
    /**
     * Filter, which review to fetch.
     */
    where?: reviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews to fetch.
     */
    orderBy?: reviewOrderByWithRelationInput | reviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reviews.
     */
    cursor?: reviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * review findFirstOrThrow
   */
  export type reviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review
     */
    select?: reviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the review
     */
    omit?: reviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewInclude<ExtArgs> | null
    /**
     * Filter, which review to fetch.
     */
    where?: reviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews to fetch.
     */
    orderBy?: reviewOrderByWithRelationInput | reviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reviews.
     */
    cursor?: reviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * review findMany
   */
  export type reviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review
     */
    select?: reviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the review
     */
    omit?: reviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewInclude<ExtArgs> | null
    /**
     * Filter, which reviews to fetch.
     */
    where?: reviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews to fetch.
     */
    orderBy?: reviewOrderByWithRelationInput | reviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reviews.
     */
    cursor?: reviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * review create
   */
  export type reviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review
     */
    select?: reviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the review
     */
    omit?: reviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewInclude<ExtArgs> | null
    /**
     * The data needed to create a review.
     */
    data?: XOR<reviewCreateInput, reviewUncheckedCreateInput>
  }

  /**
   * review createMany
   */
  export type reviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many reviews.
     */
    data: reviewCreateManyInput | reviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * review createManyAndReturn
   */
  export type reviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review
     */
    select?: reviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the review
     */
    omit?: reviewOmit<ExtArgs> | null
    /**
     * The data used to create many reviews.
     */
    data: reviewCreateManyInput | reviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * review update
   */
  export type reviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review
     */
    select?: reviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the review
     */
    omit?: reviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewInclude<ExtArgs> | null
    /**
     * The data needed to update a review.
     */
    data: XOR<reviewUpdateInput, reviewUncheckedUpdateInput>
    /**
     * Choose, which review to update.
     */
    where: reviewWhereUniqueInput
  }

  /**
   * review updateMany
   */
  export type reviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update reviews.
     */
    data: XOR<reviewUpdateManyMutationInput, reviewUncheckedUpdateManyInput>
    /**
     * Filter which reviews to update
     */
    where?: reviewWhereInput
    /**
     * Limit how many reviews to update.
     */
    limit?: number
  }

  /**
   * review updateManyAndReturn
   */
  export type reviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review
     */
    select?: reviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the review
     */
    omit?: reviewOmit<ExtArgs> | null
    /**
     * The data used to update reviews.
     */
    data: XOR<reviewUpdateManyMutationInput, reviewUncheckedUpdateManyInput>
    /**
     * Filter which reviews to update
     */
    where?: reviewWhereInput
    /**
     * Limit how many reviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * review upsert
   */
  export type reviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review
     */
    select?: reviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the review
     */
    omit?: reviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewInclude<ExtArgs> | null
    /**
     * The filter to search for the review to update in case it exists.
     */
    where: reviewWhereUniqueInput
    /**
     * In case the review found by the `where` argument doesn't exist, create a new review with this data.
     */
    create: XOR<reviewCreateInput, reviewUncheckedCreateInput>
    /**
     * In case the review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<reviewUpdateInput, reviewUncheckedUpdateInput>
  }

  /**
   * review delete
   */
  export type reviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review
     */
    select?: reviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the review
     */
    omit?: reviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewInclude<ExtArgs> | null
    /**
     * Filter which review to delete.
     */
    where: reviewWhereUniqueInput
  }

  /**
   * review deleteMany
   */
  export type reviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reviews to delete
     */
    where?: reviewWhereInput
    /**
     * Limit how many reviews to delete.
     */
    limit?: number
  }

  /**
   * review.paper
   */
  export type review$paperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paper
     */
    select?: paperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paper
     */
    omit?: paperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paperInclude<ExtArgs> | null
    where?: paperWhereInput
  }

  /**
   * review.proposal
   */
  export type review$proposalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proposal
     */
    select?: proposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proposal
     */
    omit?: proposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proposalInclude<ExtArgs> | null
    where?: proposalWhereInput
  }

  /**
   * review.reviewer
   */
  export type review$reviewerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewer
     */
    select?: reviewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewer
     */
    omit?: reviewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewerInclude<ExtArgs> | null
    where?: reviewerWhereInput
  }

  /**
   * review without action
   */
  export type reviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review
     */
    select?: reviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the review
     */
    omit?: reviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewInclude<ExtArgs> | null
  }


  /**
   * Model reviewerassignment
   */

  export type AggregateReviewerassignment = {
    _count: ReviewerassignmentCountAggregateOutputType | null
    _avg: ReviewerassignmentAvgAggregateOutputType | null
    _sum: ReviewerassignmentSumAggregateOutputType | null
    _min: ReviewerassignmentMinAggregateOutputType | null
    _max: ReviewerassignmentMaxAggregateOutputType | null
  }

  export type ReviewerassignmentAvgAggregateOutputType = {
    assignment_id: number | null
    reviewer_id: number | null
    proposal_id: number | null
    paper_id: number | null
  }

  export type ReviewerassignmentSumAggregateOutputType = {
    assignment_id: number | null
    reviewer_id: number | null
    proposal_id: number | null
    paper_id: number | null
  }

  export type ReviewerassignmentMinAggregateOutputType = {
    assignment_id: number | null
    reviewer_id: number | null
    proposal_id: number | null
    paper_id: number | null
    assigned_date: Date | null
    due_date: Date | null
    status: $Enums.AssignmentStatus | null
    completed_at: Date | null
    started_at: Date | null
  }

  export type ReviewerassignmentMaxAggregateOutputType = {
    assignment_id: number | null
    reviewer_id: number | null
    proposal_id: number | null
    paper_id: number | null
    assigned_date: Date | null
    due_date: Date | null
    status: $Enums.AssignmentStatus | null
    completed_at: Date | null
    started_at: Date | null
  }

  export type ReviewerassignmentCountAggregateOutputType = {
    assignment_id: number
    reviewer_id: number
    proposal_id: number
    paper_id: number
    assigned_date: number
    due_date: number
    status: number
    completed_at: number
    started_at: number
    _all: number
  }


  export type ReviewerassignmentAvgAggregateInputType = {
    assignment_id?: true
    reviewer_id?: true
    proposal_id?: true
    paper_id?: true
  }

  export type ReviewerassignmentSumAggregateInputType = {
    assignment_id?: true
    reviewer_id?: true
    proposal_id?: true
    paper_id?: true
  }

  export type ReviewerassignmentMinAggregateInputType = {
    assignment_id?: true
    reviewer_id?: true
    proposal_id?: true
    paper_id?: true
    assigned_date?: true
    due_date?: true
    status?: true
    completed_at?: true
    started_at?: true
  }

  export type ReviewerassignmentMaxAggregateInputType = {
    assignment_id?: true
    reviewer_id?: true
    proposal_id?: true
    paper_id?: true
    assigned_date?: true
    due_date?: true
    status?: true
    completed_at?: true
    started_at?: true
  }

  export type ReviewerassignmentCountAggregateInputType = {
    assignment_id?: true
    reviewer_id?: true
    proposal_id?: true
    paper_id?: true
    assigned_date?: true
    due_date?: true
    status?: true
    completed_at?: true
    started_at?: true
    _all?: true
  }

  export type ReviewerassignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reviewerassignment to aggregate.
     */
    where?: reviewerassignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviewerassignments to fetch.
     */
    orderBy?: reviewerassignmentOrderByWithRelationInput | reviewerassignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: reviewerassignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviewerassignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviewerassignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reviewerassignments
    **/
    _count?: true | ReviewerassignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewerassignmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewerassignmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewerassignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewerassignmentMaxAggregateInputType
  }

  export type GetReviewerassignmentAggregateType<T extends ReviewerassignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateReviewerassignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReviewerassignment[P]>
      : GetScalarType<T[P], AggregateReviewerassignment[P]>
  }




  export type reviewerassignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reviewerassignmentWhereInput
    orderBy?: reviewerassignmentOrderByWithAggregationInput | reviewerassignmentOrderByWithAggregationInput[]
    by: ReviewerassignmentScalarFieldEnum[] | ReviewerassignmentScalarFieldEnum
    having?: reviewerassignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewerassignmentCountAggregateInputType | true
    _avg?: ReviewerassignmentAvgAggregateInputType
    _sum?: ReviewerassignmentSumAggregateInputType
    _min?: ReviewerassignmentMinAggregateInputType
    _max?: ReviewerassignmentMaxAggregateInputType
  }

  export type ReviewerassignmentGroupByOutputType = {
    assignment_id: number
    reviewer_id: number
    proposal_id: number | null
    paper_id: number | null
    assigned_date: Date
    due_date: Date
    status: $Enums.AssignmentStatus
    completed_at: Date | null
    started_at: Date | null
    _count: ReviewerassignmentCountAggregateOutputType | null
    _avg: ReviewerassignmentAvgAggregateOutputType | null
    _sum: ReviewerassignmentSumAggregateOutputType | null
    _min: ReviewerassignmentMinAggregateOutputType | null
    _max: ReviewerassignmentMaxAggregateOutputType | null
  }

  type GetReviewerassignmentGroupByPayload<T extends reviewerassignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewerassignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewerassignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewerassignmentGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewerassignmentGroupByOutputType[P]>
        }
      >
    >


  export type reviewerassignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    assignment_id?: boolean
    reviewer_id?: boolean
    proposal_id?: boolean
    paper_id?: boolean
    assigned_date?: boolean
    due_date?: boolean
    status?: boolean
    completed_at?: boolean
    started_at?: boolean
    paper?: boolean | reviewerassignment$paperArgs<ExtArgs>
    proposal?: boolean | reviewerassignment$proposalArgs<ExtArgs>
    reviewer?: boolean | reviewerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewerassignment"]>

  export type reviewerassignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    assignment_id?: boolean
    reviewer_id?: boolean
    proposal_id?: boolean
    paper_id?: boolean
    assigned_date?: boolean
    due_date?: boolean
    status?: boolean
    completed_at?: boolean
    started_at?: boolean
    paper?: boolean | reviewerassignment$paperArgs<ExtArgs>
    proposal?: boolean | reviewerassignment$proposalArgs<ExtArgs>
    reviewer?: boolean | reviewerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewerassignment"]>

  export type reviewerassignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    assignment_id?: boolean
    reviewer_id?: boolean
    proposal_id?: boolean
    paper_id?: boolean
    assigned_date?: boolean
    due_date?: boolean
    status?: boolean
    completed_at?: boolean
    started_at?: boolean
    paper?: boolean | reviewerassignment$paperArgs<ExtArgs>
    proposal?: boolean | reviewerassignment$proposalArgs<ExtArgs>
    reviewer?: boolean | reviewerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewerassignment"]>

  export type reviewerassignmentSelectScalar = {
    assignment_id?: boolean
    reviewer_id?: boolean
    proposal_id?: boolean
    paper_id?: boolean
    assigned_date?: boolean
    due_date?: boolean
    status?: boolean
    completed_at?: boolean
    started_at?: boolean
  }

  export type reviewerassignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"assignment_id" | "reviewer_id" | "proposal_id" | "paper_id" | "assigned_date" | "due_date" | "status" | "completed_at" | "started_at", ExtArgs["result"]["reviewerassignment"]>
  export type reviewerassignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paper?: boolean | reviewerassignment$paperArgs<ExtArgs>
    proposal?: boolean | reviewerassignment$proposalArgs<ExtArgs>
    reviewer?: boolean | reviewerDefaultArgs<ExtArgs>
  }
  export type reviewerassignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paper?: boolean | reviewerassignment$paperArgs<ExtArgs>
    proposal?: boolean | reviewerassignment$proposalArgs<ExtArgs>
    reviewer?: boolean | reviewerDefaultArgs<ExtArgs>
  }
  export type reviewerassignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paper?: boolean | reviewerassignment$paperArgs<ExtArgs>
    proposal?: boolean | reviewerassignment$proposalArgs<ExtArgs>
    reviewer?: boolean | reviewerDefaultArgs<ExtArgs>
  }

  export type $reviewerassignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "reviewerassignment"
    objects: {
      paper: Prisma.$paperPayload<ExtArgs> | null
      proposal: Prisma.$proposalPayload<ExtArgs> | null
      reviewer: Prisma.$reviewerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      assignment_id: number
      reviewer_id: number
      proposal_id: number | null
      paper_id: number | null
      assigned_date: Date
      due_date: Date
      status: $Enums.AssignmentStatus
      completed_at: Date | null
      started_at: Date | null
    }, ExtArgs["result"]["reviewerassignment"]>
    composites: {}
  }

  type reviewerassignmentGetPayload<S extends boolean | null | undefined | reviewerassignmentDefaultArgs> = $Result.GetResult<Prisma.$reviewerassignmentPayload, S>

  type reviewerassignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<reviewerassignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewerassignmentCountAggregateInputType | true
    }

  export interface reviewerassignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['reviewerassignment'], meta: { name: 'reviewerassignment' } }
    /**
     * Find zero or one Reviewerassignment that matches the filter.
     * @param {reviewerassignmentFindUniqueArgs} args - Arguments to find a Reviewerassignment
     * @example
     * // Get one Reviewerassignment
     * const reviewerassignment = await prisma.reviewerassignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends reviewerassignmentFindUniqueArgs>(args: SelectSubset<T, reviewerassignmentFindUniqueArgs<ExtArgs>>): Prisma__reviewerassignmentClient<$Result.GetResult<Prisma.$reviewerassignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Reviewerassignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {reviewerassignmentFindUniqueOrThrowArgs} args - Arguments to find a Reviewerassignment
     * @example
     * // Get one Reviewerassignment
     * const reviewerassignment = await prisma.reviewerassignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends reviewerassignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, reviewerassignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__reviewerassignmentClient<$Result.GetResult<Prisma.$reviewerassignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reviewerassignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewerassignmentFindFirstArgs} args - Arguments to find a Reviewerassignment
     * @example
     * // Get one Reviewerassignment
     * const reviewerassignment = await prisma.reviewerassignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends reviewerassignmentFindFirstArgs>(args?: SelectSubset<T, reviewerassignmentFindFirstArgs<ExtArgs>>): Prisma__reviewerassignmentClient<$Result.GetResult<Prisma.$reviewerassignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reviewerassignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewerassignmentFindFirstOrThrowArgs} args - Arguments to find a Reviewerassignment
     * @example
     * // Get one Reviewerassignment
     * const reviewerassignment = await prisma.reviewerassignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends reviewerassignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, reviewerassignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__reviewerassignmentClient<$Result.GetResult<Prisma.$reviewerassignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reviewerassignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewerassignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviewerassignments
     * const reviewerassignments = await prisma.reviewerassignment.findMany()
     * 
     * // Get first 10 Reviewerassignments
     * const reviewerassignments = await prisma.reviewerassignment.findMany({ take: 10 })
     * 
     * // Only select the `assignment_id`
     * const reviewerassignmentWithAssignment_idOnly = await prisma.reviewerassignment.findMany({ select: { assignment_id: true } })
     * 
     */
    findMany<T extends reviewerassignmentFindManyArgs>(args?: SelectSubset<T, reviewerassignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewerassignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Reviewerassignment.
     * @param {reviewerassignmentCreateArgs} args - Arguments to create a Reviewerassignment.
     * @example
     * // Create one Reviewerassignment
     * const Reviewerassignment = await prisma.reviewerassignment.create({
     *   data: {
     *     // ... data to create a Reviewerassignment
     *   }
     * })
     * 
     */
    create<T extends reviewerassignmentCreateArgs>(args: SelectSubset<T, reviewerassignmentCreateArgs<ExtArgs>>): Prisma__reviewerassignmentClient<$Result.GetResult<Prisma.$reviewerassignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reviewerassignments.
     * @param {reviewerassignmentCreateManyArgs} args - Arguments to create many Reviewerassignments.
     * @example
     * // Create many Reviewerassignments
     * const reviewerassignment = await prisma.reviewerassignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends reviewerassignmentCreateManyArgs>(args?: SelectSubset<T, reviewerassignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviewerassignments and returns the data saved in the database.
     * @param {reviewerassignmentCreateManyAndReturnArgs} args - Arguments to create many Reviewerassignments.
     * @example
     * // Create many Reviewerassignments
     * const reviewerassignment = await prisma.reviewerassignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviewerassignments and only return the `assignment_id`
     * const reviewerassignmentWithAssignment_idOnly = await prisma.reviewerassignment.createManyAndReturn({
     *   select: { assignment_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends reviewerassignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, reviewerassignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewerassignmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Reviewerassignment.
     * @param {reviewerassignmentDeleteArgs} args - Arguments to delete one Reviewerassignment.
     * @example
     * // Delete one Reviewerassignment
     * const Reviewerassignment = await prisma.reviewerassignment.delete({
     *   where: {
     *     // ... filter to delete one Reviewerassignment
     *   }
     * })
     * 
     */
    delete<T extends reviewerassignmentDeleteArgs>(args: SelectSubset<T, reviewerassignmentDeleteArgs<ExtArgs>>): Prisma__reviewerassignmentClient<$Result.GetResult<Prisma.$reviewerassignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Reviewerassignment.
     * @param {reviewerassignmentUpdateArgs} args - Arguments to update one Reviewerassignment.
     * @example
     * // Update one Reviewerassignment
     * const reviewerassignment = await prisma.reviewerassignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends reviewerassignmentUpdateArgs>(args: SelectSubset<T, reviewerassignmentUpdateArgs<ExtArgs>>): Prisma__reviewerassignmentClient<$Result.GetResult<Prisma.$reviewerassignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reviewerassignments.
     * @param {reviewerassignmentDeleteManyArgs} args - Arguments to filter Reviewerassignments to delete.
     * @example
     * // Delete a few Reviewerassignments
     * const { count } = await prisma.reviewerassignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends reviewerassignmentDeleteManyArgs>(args?: SelectSubset<T, reviewerassignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviewerassignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewerassignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviewerassignments
     * const reviewerassignment = await prisma.reviewerassignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends reviewerassignmentUpdateManyArgs>(args: SelectSubset<T, reviewerassignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviewerassignments and returns the data updated in the database.
     * @param {reviewerassignmentUpdateManyAndReturnArgs} args - Arguments to update many Reviewerassignments.
     * @example
     * // Update many Reviewerassignments
     * const reviewerassignment = await prisma.reviewerassignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reviewerassignments and only return the `assignment_id`
     * const reviewerassignmentWithAssignment_idOnly = await prisma.reviewerassignment.updateManyAndReturn({
     *   select: { assignment_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends reviewerassignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, reviewerassignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewerassignmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Reviewerassignment.
     * @param {reviewerassignmentUpsertArgs} args - Arguments to update or create a Reviewerassignment.
     * @example
     * // Update or create a Reviewerassignment
     * const reviewerassignment = await prisma.reviewerassignment.upsert({
     *   create: {
     *     // ... data to create a Reviewerassignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reviewerassignment we want to update
     *   }
     * })
     */
    upsert<T extends reviewerassignmentUpsertArgs>(args: SelectSubset<T, reviewerassignmentUpsertArgs<ExtArgs>>): Prisma__reviewerassignmentClient<$Result.GetResult<Prisma.$reviewerassignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reviewerassignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewerassignmentCountArgs} args - Arguments to filter Reviewerassignments to count.
     * @example
     * // Count the number of Reviewerassignments
     * const count = await prisma.reviewerassignment.count({
     *   where: {
     *     // ... the filter for the Reviewerassignments we want to count
     *   }
     * })
    **/
    count<T extends reviewerassignmentCountArgs>(
      args?: Subset<T, reviewerassignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewerassignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reviewerassignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewerassignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewerassignmentAggregateArgs>(args: Subset<T, ReviewerassignmentAggregateArgs>): Prisma.PrismaPromise<GetReviewerassignmentAggregateType<T>>

    /**
     * Group by Reviewerassignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewerassignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends reviewerassignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: reviewerassignmentGroupByArgs['orderBy'] }
        : { orderBy?: reviewerassignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, reviewerassignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewerassignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the reviewerassignment model
   */
  readonly fields: reviewerassignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for reviewerassignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__reviewerassignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    paper<T extends reviewerassignment$paperArgs<ExtArgs> = {}>(args?: Subset<T, reviewerassignment$paperArgs<ExtArgs>>): Prisma__paperClient<$Result.GetResult<Prisma.$paperPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    proposal<T extends reviewerassignment$proposalArgs<ExtArgs> = {}>(args?: Subset<T, reviewerassignment$proposalArgs<ExtArgs>>): Prisma__proposalClient<$Result.GetResult<Prisma.$proposalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    reviewer<T extends reviewerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, reviewerDefaultArgs<ExtArgs>>): Prisma__reviewerClient<$Result.GetResult<Prisma.$reviewerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the reviewerassignment model
   */
  interface reviewerassignmentFieldRefs {
    readonly assignment_id: FieldRef<"reviewerassignment", 'Int'>
    readonly reviewer_id: FieldRef<"reviewerassignment", 'Int'>
    readonly proposal_id: FieldRef<"reviewerassignment", 'Int'>
    readonly paper_id: FieldRef<"reviewerassignment", 'Int'>
    readonly assigned_date: FieldRef<"reviewerassignment", 'DateTime'>
    readonly due_date: FieldRef<"reviewerassignment", 'DateTime'>
    readonly status: FieldRef<"reviewerassignment", 'AssignmentStatus'>
    readonly completed_at: FieldRef<"reviewerassignment", 'DateTime'>
    readonly started_at: FieldRef<"reviewerassignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * reviewerassignment findUnique
   */
  export type reviewerassignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewerassignment
     */
    select?: reviewerassignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewerassignment
     */
    omit?: reviewerassignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewerassignmentInclude<ExtArgs> | null
    /**
     * Filter, which reviewerassignment to fetch.
     */
    where: reviewerassignmentWhereUniqueInput
  }

  /**
   * reviewerassignment findUniqueOrThrow
   */
  export type reviewerassignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewerassignment
     */
    select?: reviewerassignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewerassignment
     */
    omit?: reviewerassignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewerassignmentInclude<ExtArgs> | null
    /**
     * Filter, which reviewerassignment to fetch.
     */
    where: reviewerassignmentWhereUniqueInput
  }

  /**
   * reviewerassignment findFirst
   */
  export type reviewerassignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewerassignment
     */
    select?: reviewerassignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewerassignment
     */
    omit?: reviewerassignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewerassignmentInclude<ExtArgs> | null
    /**
     * Filter, which reviewerassignment to fetch.
     */
    where?: reviewerassignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviewerassignments to fetch.
     */
    orderBy?: reviewerassignmentOrderByWithRelationInput | reviewerassignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reviewerassignments.
     */
    cursor?: reviewerassignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviewerassignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviewerassignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reviewerassignments.
     */
    distinct?: ReviewerassignmentScalarFieldEnum | ReviewerassignmentScalarFieldEnum[]
  }

  /**
   * reviewerassignment findFirstOrThrow
   */
  export type reviewerassignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewerassignment
     */
    select?: reviewerassignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewerassignment
     */
    omit?: reviewerassignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewerassignmentInclude<ExtArgs> | null
    /**
     * Filter, which reviewerassignment to fetch.
     */
    where?: reviewerassignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviewerassignments to fetch.
     */
    orderBy?: reviewerassignmentOrderByWithRelationInput | reviewerassignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reviewerassignments.
     */
    cursor?: reviewerassignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviewerassignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviewerassignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reviewerassignments.
     */
    distinct?: ReviewerassignmentScalarFieldEnum | ReviewerassignmentScalarFieldEnum[]
  }

  /**
   * reviewerassignment findMany
   */
  export type reviewerassignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewerassignment
     */
    select?: reviewerassignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewerassignment
     */
    omit?: reviewerassignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewerassignmentInclude<ExtArgs> | null
    /**
     * Filter, which reviewerassignments to fetch.
     */
    where?: reviewerassignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviewerassignments to fetch.
     */
    orderBy?: reviewerassignmentOrderByWithRelationInput | reviewerassignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reviewerassignments.
     */
    cursor?: reviewerassignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviewerassignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviewerassignments.
     */
    skip?: number
    distinct?: ReviewerassignmentScalarFieldEnum | ReviewerassignmentScalarFieldEnum[]
  }

  /**
   * reviewerassignment create
   */
  export type reviewerassignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewerassignment
     */
    select?: reviewerassignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewerassignment
     */
    omit?: reviewerassignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewerassignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a reviewerassignment.
     */
    data: XOR<reviewerassignmentCreateInput, reviewerassignmentUncheckedCreateInput>
  }

  /**
   * reviewerassignment createMany
   */
  export type reviewerassignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many reviewerassignments.
     */
    data: reviewerassignmentCreateManyInput | reviewerassignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * reviewerassignment createManyAndReturn
   */
  export type reviewerassignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewerassignment
     */
    select?: reviewerassignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the reviewerassignment
     */
    omit?: reviewerassignmentOmit<ExtArgs> | null
    /**
     * The data used to create many reviewerassignments.
     */
    data: reviewerassignmentCreateManyInput | reviewerassignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewerassignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * reviewerassignment update
   */
  export type reviewerassignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewerassignment
     */
    select?: reviewerassignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewerassignment
     */
    omit?: reviewerassignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewerassignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a reviewerassignment.
     */
    data: XOR<reviewerassignmentUpdateInput, reviewerassignmentUncheckedUpdateInput>
    /**
     * Choose, which reviewerassignment to update.
     */
    where: reviewerassignmentWhereUniqueInput
  }

  /**
   * reviewerassignment updateMany
   */
  export type reviewerassignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update reviewerassignments.
     */
    data: XOR<reviewerassignmentUpdateManyMutationInput, reviewerassignmentUncheckedUpdateManyInput>
    /**
     * Filter which reviewerassignments to update
     */
    where?: reviewerassignmentWhereInput
    /**
     * Limit how many reviewerassignments to update.
     */
    limit?: number
  }

  /**
   * reviewerassignment updateManyAndReturn
   */
  export type reviewerassignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewerassignment
     */
    select?: reviewerassignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the reviewerassignment
     */
    omit?: reviewerassignmentOmit<ExtArgs> | null
    /**
     * The data used to update reviewerassignments.
     */
    data: XOR<reviewerassignmentUpdateManyMutationInput, reviewerassignmentUncheckedUpdateManyInput>
    /**
     * Filter which reviewerassignments to update
     */
    where?: reviewerassignmentWhereInput
    /**
     * Limit how many reviewerassignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewerassignmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * reviewerassignment upsert
   */
  export type reviewerassignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewerassignment
     */
    select?: reviewerassignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewerassignment
     */
    omit?: reviewerassignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewerassignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the reviewerassignment to update in case it exists.
     */
    where: reviewerassignmentWhereUniqueInput
    /**
     * In case the reviewerassignment found by the `where` argument doesn't exist, create a new reviewerassignment with this data.
     */
    create: XOR<reviewerassignmentCreateInput, reviewerassignmentUncheckedCreateInput>
    /**
     * In case the reviewerassignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<reviewerassignmentUpdateInput, reviewerassignmentUncheckedUpdateInput>
  }

  /**
   * reviewerassignment delete
   */
  export type reviewerassignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewerassignment
     */
    select?: reviewerassignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewerassignment
     */
    omit?: reviewerassignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewerassignmentInclude<ExtArgs> | null
    /**
     * Filter which reviewerassignment to delete.
     */
    where: reviewerassignmentWhereUniqueInput
  }

  /**
   * reviewerassignment deleteMany
   */
  export type reviewerassignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reviewerassignments to delete
     */
    where?: reviewerassignmentWhereInput
    /**
     * Limit how many reviewerassignments to delete.
     */
    limit?: number
  }

  /**
   * reviewerassignment.paper
   */
  export type reviewerassignment$paperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paper
     */
    select?: paperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paper
     */
    omit?: paperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paperInclude<ExtArgs> | null
    where?: paperWhereInput
  }

  /**
   * reviewerassignment.proposal
   */
  export type reviewerassignment$proposalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proposal
     */
    select?: proposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proposal
     */
    omit?: proposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proposalInclude<ExtArgs> | null
    where?: proposalWhereInput
  }

  /**
   * reviewerassignment without action
   */
  export type reviewerassignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewerassignment
     */
    select?: reviewerassignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewerassignment
     */
    omit?: reviewerassignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewerassignmentInclude<ExtArgs> | null
  }


  /**
   * Model userdomain
   */

  export type AggregateUserdomain = {
    _count: UserdomainCountAggregateOutputType | null
    _avg: UserdomainAvgAggregateOutputType | null
    _sum: UserdomainSumAggregateOutputType | null
    _min: UserdomainMinAggregateOutputType | null
    _max: UserdomainMaxAggregateOutputType | null
  }

  export type UserdomainAvgAggregateOutputType = {
    user_id: number | null
    domain_id: number | null
  }

  export type UserdomainSumAggregateOutputType = {
    user_id: number | null
    domain_id: number | null
  }

  export type UserdomainMinAggregateOutputType = {
    user_id: number | null
    domain_id: number | null
  }

  export type UserdomainMaxAggregateOutputType = {
    user_id: number | null
    domain_id: number | null
  }

  export type UserdomainCountAggregateOutputType = {
    user_id: number
    domain_id: number
    _all: number
  }


  export type UserdomainAvgAggregateInputType = {
    user_id?: true
    domain_id?: true
  }

  export type UserdomainSumAggregateInputType = {
    user_id?: true
    domain_id?: true
  }

  export type UserdomainMinAggregateInputType = {
    user_id?: true
    domain_id?: true
  }

  export type UserdomainMaxAggregateInputType = {
    user_id?: true
    domain_id?: true
  }

  export type UserdomainCountAggregateInputType = {
    user_id?: true
    domain_id?: true
    _all?: true
  }

  export type UserdomainAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userdomain to aggregate.
     */
    where?: userdomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userdomains to fetch.
     */
    orderBy?: userdomainOrderByWithRelationInput | userdomainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userdomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userdomains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userdomains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned userdomains
    **/
    _count?: true | UserdomainCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserdomainAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserdomainSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserdomainMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserdomainMaxAggregateInputType
  }

  export type GetUserdomainAggregateType<T extends UserdomainAggregateArgs> = {
        [P in keyof T & keyof AggregateUserdomain]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserdomain[P]>
      : GetScalarType<T[P], AggregateUserdomain[P]>
  }




  export type userdomainGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userdomainWhereInput
    orderBy?: userdomainOrderByWithAggregationInput | userdomainOrderByWithAggregationInput[]
    by: UserdomainScalarFieldEnum[] | UserdomainScalarFieldEnum
    having?: userdomainScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserdomainCountAggregateInputType | true
    _avg?: UserdomainAvgAggregateInputType
    _sum?: UserdomainSumAggregateInputType
    _min?: UserdomainMinAggregateInputType
    _max?: UserdomainMaxAggregateInputType
  }

  export type UserdomainGroupByOutputType = {
    user_id: number
    domain_id: number
    _count: UserdomainCountAggregateOutputType | null
    _avg: UserdomainAvgAggregateOutputType | null
    _sum: UserdomainSumAggregateOutputType | null
    _min: UserdomainMinAggregateOutputType | null
    _max: UserdomainMaxAggregateOutputType | null
  }

  type GetUserdomainGroupByPayload<T extends userdomainGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserdomainGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserdomainGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserdomainGroupByOutputType[P]>
            : GetScalarType<T[P], UserdomainGroupByOutputType[P]>
        }
      >
    >


  export type userdomainSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    domain_id?: boolean
    domain?: boolean | domainDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userdomain"]>

  export type userdomainSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    domain_id?: boolean
    domain?: boolean | domainDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userdomain"]>

  export type userdomainSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    domain_id?: boolean
    domain?: boolean | domainDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userdomain"]>

  export type userdomainSelectScalar = {
    user_id?: boolean
    domain_id?: boolean
  }

  export type userdomainOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_id" | "domain_id", ExtArgs["result"]["userdomain"]>
  export type userdomainInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domain?: boolean | domainDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type userdomainIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domain?: boolean | domainDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type userdomainIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domain?: boolean | domainDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $userdomainPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "userdomain"
    objects: {
      domain: Prisma.$domainPayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: number
      domain_id: number
    }, ExtArgs["result"]["userdomain"]>
    composites: {}
  }

  type userdomainGetPayload<S extends boolean | null | undefined | userdomainDefaultArgs> = $Result.GetResult<Prisma.$userdomainPayload, S>

  type userdomainCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userdomainFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserdomainCountAggregateInputType | true
    }

  export interface userdomainDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['userdomain'], meta: { name: 'userdomain' } }
    /**
     * Find zero or one Userdomain that matches the filter.
     * @param {userdomainFindUniqueArgs} args - Arguments to find a Userdomain
     * @example
     * // Get one Userdomain
     * const userdomain = await prisma.userdomain.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userdomainFindUniqueArgs>(args: SelectSubset<T, userdomainFindUniqueArgs<ExtArgs>>): Prisma__userdomainClient<$Result.GetResult<Prisma.$userdomainPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Userdomain that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userdomainFindUniqueOrThrowArgs} args - Arguments to find a Userdomain
     * @example
     * // Get one Userdomain
     * const userdomain = await prisma.userdomain.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userdomainFindUniqueOrThrowArgs>(args: SelectSubset<T, userdomainFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userdomainClient<$Result.GetResult<Prisma.$userdomainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Userdomain that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userdomainFindFirstArgs} args - Arguments to find a Userdomain
     * @example
     * // Get one Userdomain
     * const userdomain = await prisma.userdomain.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userdomainFindFirstArgs>(args?: SelectSubset<T, userdomainFindFirstArgs<ExtArgs>>): Prisma__userdomainClient<$Result.GetResult<Prisma.$userdomainPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Userdomain that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userdomainFindFirstOrThrowArgs} args - Arguments to find a Userdomain
     * @example
     * // Get one Userdomain
     * const userdomain = await prisma.userdomain.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userdomainFindFirstOrThrowArgs>(args?: SelectSubset<T, userdomainFindFirstOrThrowArgs<ExtArgs>>): Prisma__userdomainClient<$Result.GetResult<Prisma.$userdomainPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Userdomains that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userdomainFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Userdomains
     * const userdomains = await prisma.userdomain.findMany()
     * 
     * // Get first 10 Userdomains
     * const userdomains = await prisma.userdomain.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const userdomainWithUser_idOnly = await prisma.userdomain.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends userdomainFindManyArgs>(args?: SelectSubset<T, userdomainFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userdomainPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Userdomain.
     * @param {userdomainCreateArgs} args - Arguments to create a Userdomain.
     * @example
     * // Create one Userdomain
     * const Userdomain = await prisma.userdomain.create({
     *   data: {
     *     // ... data to create a Userdomain
     *   }
     * })
     * 
     */
    create<T extends userdomainCreateArgs>(args: SelectSubset<T, userdomainCreateArgs<ExtArgs>>): Prisma__userdomainClient<$Result.GetResult<Prisma.$userdomainPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Userdomains.
     * @param {userdomainCreateManyArgs} args - Arguments to create many Userdomains.
     * @example
     * // Create many Userdomains
     * const userdomain = await prisma.userdomain.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userdomainCreateManyArgs>(args?: SelectSubset<T, userdomainCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Userdomains and returns the data saved in the database.
     * @param {userdomainCreateManyAndReturnArgs} args - Arguments to create many Userdomains.
     * @example
     * // Create many Userdomains
     * const userdomain = await prisma.userdomain.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Userdomains and only return the `user_id`
     * const userdomainWithUser_idOnly = await prisma.userdomain.createManyAndReturn({
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends userdomainCreateManyAndReturnArgs>(args?: SelectSubset<T, userdomainCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userdomainPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Userdomain.
     * @param {userdomainDeleteArgs} args - Arguments to delete one Userdomain.
     * @example
     * // Delete one Userdomain
     * const Userdomain = await prisma.userdomain.delete({
     *   where: {
     *     // ... filter to delete one Userdomain
     *   }
     * })
     * 
     */
    delete<T extends userdomainDeleteArgs>(args: SelectSubset<T, userdomainDeleteArgs<ExtArgs>>): Prisma__userdomainClient<$Result.GetResult<Prisma.$userdomainPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Userdomain.
     * @param {userdomainUpdateArgs} args - Arguments to update one Userdomain.
     * @example
     * // Update one Userdomain
     * const userdomain = await prisma.userdomain.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userdomainUpdateArgs>(args: SelectSubset<T, userdomainUpdateArgs<ExtArgs>>): Prisma__userdomainClient<$Result.GetResult<Prisma.$userdomainPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Userdomains.
     * @param {userdomainDeleteManyArgs} args - Arguments to filter Userdomains to delete.
     * @example
     * // Delete a few Userdomains
     * const { count } = await prisma.userdomain.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userdomainDeleteManyArgs>(args?: SelectSubset<T, userdomainDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Userdomains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userdomainUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Userdomains
     * const userdomain = await prisma.userdomain.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userdomainUpdateManyArgs>(args: SelectSubset<T, userdomainUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Userdomains and returns the data updated in the database.
     * @param {userdomainUpdateManyAndReturnArgs} args - Arguments to update many Userdomains.
     * @example
     * // Update many Userdomains
     * const userdomain = await prisma.userdomain.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Userdomains and only return the `user_id`
     * const userdomainWithUser_idOnly = await prisma.userdomain.updateManyAndReturn({
     *   select: { user_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends userdomainUpdateManyAndReturnArgs>(args: SelectSubset<T, userdomainUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userdomainPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Userdomain.
     * @param {userdomainUpsertArgs} args - Arguments to update or create a Userdomain.
     * @example
     * // Update or create a Userdomain
     * const userdomain = await prisma.userdomain.upsert({
     *   create: {
     *     // ... data to create a Userdomain
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Userdomain we want to update
     *   }
     * })
     */
    upsert<T extends userdomainUpsertArgs>(args: SelectSubset<T, userdomainUpsertArgs<ExtArgs>>): Prisma__userdomainClient<$Result.GetResult<Prisma.$userdomainPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Userdomains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userdomainCountArgs} args - Arguments to filter Userdomains to count.
     * @example
     * // Count the number of Userdomains
     * const count = await prisma.userdomain.count({
     *   where: {
     *     // ... the filter for the Userdomains we want to count
     *   }
     * })
    **/
    count<T extends userdomainCountArgs>(
      args?: Subset<T, userdomainCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserdomainCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Userdomain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserdomainAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserdomainAggregateArgs>(args: Subset<T, UserdomainAggregateArgs>): Prisma.PrismaPromise<GetUserdomainAggregateType<T>>

    /**
     * Group by Userdomain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userdomainGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userdomainGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userdomainGroupByArgs['orderBy'] }
        : { orderBy?: userdomainGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userdomainGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserdomainGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the userdomain model
   */
  readonly fields: userdomainFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for userdomain.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userdomainClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    domain<T extends domainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, domainDefaultArgs<ExtArgs>>): Prisma__domainClient<$Result.GetResult<Prisma.$domainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the userdomain model
   */
  interface userdomainFieldRefs {
    readonly user_id: FieldRef<"userdomain", 'Int'>
    readonly domain_id: FieldRef<"userdomain", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * userdomain findUnique
   */
  export type userdomainFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userdomain
     */
    select?: userdomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userdomain
     */
    omit?: userdomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userdomainInclude<ExtArgs> | null
    /**
     * Filter, which userdomain to fetch.
     */
    where: userdomainWhereUniqueInput
  }

  /**
   * userdomain findUniqueOrThrow
   */
  export type userdomainFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userdomain
     */
    select?: userdomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userdomain
     */
    omit?: userdomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userdomainInclude<ExtArgs> | null
    /**
     * Filter, which userdomain to fetch.
     */
    where: userdomainWhereUniqueInput
  }

  /**
   * userdomain findFirst
   */
  export type userdomainFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userdomain
     */
    select?: userdomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userdomain
     */
    omit?: userdomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userdomainInclude<ExtArgs> | null
    /**
     * Filter, which userdomain to fetch.
     */
    where?: userdomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userdomains to fetch.
     */
    orderBy?: userdomainOrderByWithRelationInput | userdomainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userdomains.
     */
    cursor?: userdomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userdomains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userdomains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userdomains.
     */
    distinct?: UserdomainScalarFieldEnum | UserdomainScalarFieldEnum[]
  }

  /**
   * userdomain findFirstOrThrow
   */
  export type userdomainFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userdomain
     */
    select?: userdomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userdomain
     */
    omit?: userdomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userdomainInclude<ExtArgs> | null
    /**
     * Filter, which userdomain to fetch.
     */
    where?: userdomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userdomains to fetch.
     */
    orderBy?: userdomainOrderByWithRelationInput | userdomainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userdomains.
     */
    cursor?: userdomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userdomains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userdomains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userdomains.
     */
    distinct?: UserdomainScalarFieldEnum | UserdomainScalarFieldEnum[]
  }

  /**
   * userdomain findMany
   */
  export type userdomainFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userdomain
     */
    select?: userdomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userdomain
     */
    omit?: userdomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userdomainInclude<ExtArgs> | null
    /**
     * Filter, which userdomains to fetch.
     */
    where?: userdomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userdomains to fetch.
     */
    orderBy?: userdomainOrderByWithRelationInput | userdomainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing userdomains.
     */
    cursor?: userdomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userdomains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userdomains.
     */
    skip?: number
    distinct?: UserdomainScalarFieldEnum | UserdomainScalarFieldEnum[]
  }

  /**
   * userdomain create
   */
  export type userdomainCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userdomain
     */
    select?: userdomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userdomain
     */
    omit?: userdomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userdomainInclude<ExtArgs> | null
    /**
     * The data needed to create a userdomain.
     */
    data: XOR<userdomainCreateInput, userdomainUncheckedCreateInput>
  }

  /**
   * userdomain createMany
   */
  export type userdomainCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many userdomains.
     */
    data: userdomainCreateManyInput | userdomainCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * userdomain createManyAndReturn
   */
  export type userdomainCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userdomain
     */
    select?: userdomainSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the userdomain
     */
    omit?: userdomainOmit<ExtArgs> | null
    /**
     * The data used to create many userdomains.
     */
    data: userdomainCreateManyInput | userdomainCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userdomainIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * userdomain update
   */
  export type userdomainUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userdomain
     */
    select?: userdomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userdomain
     */
    omit?: userdomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userdomainInclude<ExtArgs> | null
    /**
     * The data needed to update a userdomain.
     */
    data: XOR<userdomainUpdateInput, userdomainUncheckedUpdateInput>
    /**
     * Choose, which userdomain to update.
     */
    where: userdomainWhereUniqueInput
  }

  /**
   * userdomain updateMany
   */
  export type userdomainUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update userdomains.
     */
    data: XOR<userdomainUpdateManyMutationInput, userdomainUncheckedUpdateManyInput>
    /**
     * Filter which userdomains to update
     */
    where?: userdomainWhereInput
    /**
     * Limit how many userdomains to update.
     */
    limit?: number
  }

  /**
   * userdomain updateManyAndReturn
   */
  export type userdomainUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userdomain
     */
    select?: userdomainSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the userdomain
     */
    omit?: userdomainOmit<ExtArgs> | null
    /**
     * The data used to update userdomains.
     */
    data: XOR<userdomainUpdateManyMutationInput, userdomainUncheckedUpdateManyInput>
    /**
     * Filter which userdomains to update
     */
    where?: userdomainWhereInput
    /**
     * Limit how many userdomains to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userdomainIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * userdomain upsert
   */
  export type userdomainUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userdomain
     */
    select?: userdomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userdomain
     */
    omit?: userdomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userdomainInclude<ExtArgs> | null
    /**
     * The filter to search for the userdomain to update in case it exists.
     */
    where: userdomainWhereUniqueInput
    /**
     * In case the userdomain found by the `where` argument doesn't exist, create a new userdomain with this data.
     */
    create: XOR<userdomainCreateInput, userdomainUncheckedCreateInput>
    /**
     * In case the userdomain was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userdomainUpdateInput, userdomainUncheckedUpdateInput>
  }

  /**
   * userdomain delete
   */
  export type userdomainDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userdomain
     */
    select?: userdomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userdomain
     */
    omit?: userdomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userdomainInclude<ExtArgs> | null
    /**
     * Filter which userdomain to delete.
     */
    where: userdomainWhereUniqueInput
  }

  /**
   * userdomain deleteMany
   */
  export type userdomainDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userdomains to delete
     */
    where?: userdomainWhereInput
    /**
     * Limit how many userdomains to delete.
     */
    limit?: number
  }

  /**
   * userdomain without action
   */
  export type userdomainDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userdomain
     */
    select?: userdomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userdomain
     */
    omit?: userdomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userdomainInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    user_id: 'user_id',
    name: 'name',
    email: 'email',
    password: 'password',
    profile_image: 'profile_image',
    role: 'role',
    isVerified: 'isVerified',
    isMainAdmin: 'isMainAdmin',
    verifyToken: 'verifyToken',
    created_at: 'created_at'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    admin_id: 'admin_id',
    user_id: 'user_id'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const DepartmentScalarFieldEnum: {
    department_id: 'department_id',
    department_name: 'department_name'
  };

  export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


  export const DomainScalarFieldEnum: {
    domain_id: 'domain_id',
    domain_name: 'domain_name'
  };

  export type DomainScalarFieldEnum = (typeof DomainScalarFieldEnum)[keyof typeof DomainScalarFieldEnum]


  export const DepartmentdomainScalarFieldEnum: {
    department_id: 'department_id',
    domain_id: 'domain_id'
  };

  export type DepartmentdomainScalarFieldEnum = (typeof DepartmentdomainScalarFieldEnum)[keyof typeof DepartmentdomainScalarFieldEnum]


  export const GeneraluserScalarFieldEnum: {
    generaluser_id: 'generaluser_id',
    user_id: 'user_id'
  };

  export type GeneraluserScalarFieldEnum = (typeof GeneraluserScalarFieldEnum)[keyof typeof GeneraluserScalarFieldEnum]


  export const StudentScalarFieldEnum: {
    student_id: 'student_id',
    roll_number: 'roll_number',
    department_id: 'department_id',
    user_id: 'user_id'
  };

  export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


  export const TeacherScalarFieldEnum: {
    teacher_id: 'teacher_id',
    designation: 'designation',
    department_id: 'department_id',
    user_id: 'user_id',
    isReviewer: 'isReviewer'
  };

  export type TeacherScalarFieldEnum = (typeof TeacherScalarFieldEnum)[keyof typeof TeacherScalarFieldEnum]


  export const ReviewerScalarFieldEnum: {
    reviewer_id: 'reviewer_id',
    teacher_id: 'teacher_id',
    status: 'status'
  };

  export type ReviewerScalarFieldEnum = (typeof ReviewerScalarFieldEnum)[keyof typeof ReviewerScalarFieldEnum]


  export const TeamScalarFieldEnum: {
    team_id: 'team_id',
    team_name: 'team_name',
    team_description: 'team_description',
    domain_id: 'domain_id',
    status: 'status',
    visibility: 'visibility',
    max_members: 'max_members',
    isHiring: 'isHiring',
    created_at: 'created_at',
    created_by_user_id: 'created_by_user_id'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const TeammemberScalarFieldEnum: {
    team_id: 'team_id',
    user_id: 'user_id',
    role_in_team: 'role_in_team'
  };

  export type TeammemberScalarFieldEnum = (typeof TeammemberScalarFieldEnum)[keyof typeof TeammemberScalarFieldEnum]


  export const TeamapplicationScalarFieldEnum: {
    application_id: 'application_id',
    team_id: 'team_id',
    student_id: 'student_id',
    status: 'status',
    applied_at: 'applied_at'
  };

  export type TeamapplicationScalarFieldEnum = (typeof TeamapplicationScalarFieldEnum)[keyof typeof TeamapplicationScalarFieldEnum]


  export const TeamcommentScalarFieldEnum: {
    comment_id: 'comment_id',
    team_id: 'team_id',
    user_id: 'user_id',
    comment: 'comment',
    created_at: 'created_at'
  };

  export type TeamcommentScalarFieldEnum = (typeof TeamcommentScalarFieldEnum)[keyof typeof TeamcommentScalarFieldEnum]


  export const PaperScalarFieldEnum: {
    paper_id: 'paper_id',
    title: 'title',
    abstract: 'abstract',
    status: 'status',
    team_id: 'team_id',
    submitted_by: 'submitted_by',
    pdf_path: 'pdf_path',
    file_size: 'file_size',
    created_at: 'created_at',
    aggregated_decided_at: 'aggregated_decided_at',
    aggregated_decision: 'aggregated_decision'
  };

  export type PaperScalarFieldEnum = (typeof PaperScalarFieldEnum)[keyof typeof PaperScalarFieldEnum]


  export const ProposalScalarFieldEnum: {
    proposal_id: 'proposal_id',
    title: 'title',
    abstract: 'abstract',
    status: 'status',
    team_id: 'team_id',
    submitted_by: 'submitted_by',
    pdf_path: 'pdf_path',
    file_size: 'file_size',
    created_at: 'created_at',
    aggregated_decided_at: 'aggregated_decided_at',
    aggregated_decision: 'aggregated_decision'
  };

  export type ProposalScalarFieldEnum = (typeof ProposalScalarFieldEnum)[keyof typeof ProposalScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    review_id: 'review_id',
    reviewer_id: 'reviewer_id',
    proposal_id: 'proposal_id',
    paper_id: 'paper_id',
    comments: 'comments',
    score: 'score',
    reviewed_at: 'reviewed_at',
    attachment_path: 'attachment_path',
    decision: 'decision'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const ReviewerassignmentScalarFieldEnum: {
    assignment_id: 'assignment_id',
    reviewer_id: 'reviewer_id',
    proposal_id: 'proposal_id',
    paper_id: 'paper_id',
    assigned_date: 'assigned_date',
    due_date: 'due_date',
    status: 'status',
    completed_at: 'completed_at',
    started_at: 'started_at'
  };

  export type ReviewerassignmentScalarFieldEnum = (typeof ReviewerassignmentScalarFieldEnum)[keyof typeof ReviewerassignmentScalarFieldEnum]


  export const UserdomainScalarFieldEnum: {
    user_id: 'user_id',
    domain_id: 'domain_id'
  };

  export type UserdomainScalarFieldEnum = (typeof UserdomainScalarFieldEnum)[keyof typeof UserdomainScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'ReviewerStatus'
   */
  export type EnumReviewerStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReviewerStatus'>
    


  /**
   * Reference to a field of type 'ReviewerStatus[]'
   */
  export type ListEnumReviewerStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReviewerStatus[]'>
    


  /**
   * Reference to a field of type 'TeamStatus'
   */
  export type EnumTeamStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TeamStatus'>
    


  /**
   * Reference to a field of type 'TeamStatus[]'
   */
  export type ListEnumTeamStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TeamStatus[]'>
    


  /**
   * Reference to a field of type 'TeamVisibility'
   */
  export type EnumTeamVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TeamVisibility'>
    


  /**
   * Reference to a field of type 'TeamVisibility[]'
   */
  export type ListEnumTeamVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TeamVisibility[]'>
    


  /**
   * Reference to a field of type 'TeamRole'
   */
  export type EnumTeamRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TeamRole'>
    


  /**
   * Reference to a field of type 'TeamRole[]'
   */
  export type ListEnumTeamRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TeamRole[]'>
    


  /**
   * Reference to a field of type 'ApplicationStatus'
   */
  export type EnumApplicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicationStatus'>
    


  /**
   * Reference to a field of type 'ApplicationStatus[]'
   */
  export type ListEnumApplicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicationStatus[]'>
    


  /**
   * Reference to a field of type 'PaperStatus'
   */
  export type EnumPaperStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaperStatus'>
    


  /**
   * Reference to a field of type 'PaperStatus[]'
   */
  export type ListEnumPaperStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaperStatus[]'>
    


  /**
   * Reference to a field of type 'ReviewDecision'
   */
  export type EnumReviewDecisionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReviewDecision'>
    


  /**
   * Reference to a field of type 'ReviewDecision[]'
   */
  export type ListEnumReviewDecisionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReviewDecision[]'>
    


  /**
   * Reference to a field of type 'AssignmentStatus'
   */
  export type EnumAssignmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssignmentStatus'>
    


  /**
   * Reference to a field of type 'AssignmentStatus[]'
   */
  export type ListEnumAssignmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssignmentStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type userWhereInput = {
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    user_id?: IntFilter<"user"> | number
    name?: StringNullableFilter<"user"> | string | null
    email?: StringNullableFilter<"user"> | string | null
    password?: StringNullableFilter<"user"> | string | null
    profile_image?: StringNullableFilter<"user"> | string | null
    role?: EnumRoleNullableFilter<"user"> | $Enums.Role | null
    isVerified?: BoolFilter<"user"> | boolean
    isMainAdmin?: BoolFilter<"user"> | boolean
    verifyToken?: StringNullableFilter<"user"> | string | null
    created_at?: DateTimeFilter<"user"> | Date | string
    admin?: AdminListRelationFilter
    generaluser?: GeneraluserListRelationFilter
    student?: StudentListRelationFilter
    teacher?: TeacherListRelationFilter
    team?: TeamListRelationFilter
    teamcomment?: TeamcommentListRelationFilter
    teammember?: TeammemberListRelationFilter
    userdomain?: UserdomainListRelationFilter
  }

  export type userOrderByWithRelationInput = {
    user_id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    profile_image?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    isMainAdmin?: SortOrder
    verifyToken?: SortOrderInput | SortOrder
    created_at?: SortOrder
    admin?: adminOrderByRelationAggregateInput
    generaluser?: generaluserOrderByRelationAggregateInput
    student?: studentOrderByRelationAggregateInput
    teacher?: teacherOrderByRelationAggregateInput
    team?: teamOrderByRelationAggregateInput
    teamcomment?: teamcommentOrderByRelationAggregateInput
    teammember?: teammemberOrderByRelationAggregateInput
    userdomain?: userdomainOrderByRelationAggregateInput
  }

  export type userWhereUniqueInput = Prisma.AtLeast<{
    user_id?: number
    email?: string
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    name?: StringNullableFilter<"user"> | string | null
    password?: StringNullableFilter<"user"> | string | null
    profile_image?: StringNullableFilter<"user"> | string | null
    role?: EnumRoleNullableFilter<"user"> | $Enums.Role | null
    isVerified?: BoolFilter<"user"> | boolean
    isMainAdmin?: BoolFilter<"user"> | boolean
    verifyToken?: StringNullableFilter<"user"> | string | null
    created_at?: DateTimeFilter<"user"> | Date | string
    admin?: AdminListRelationFilter
    generaluser?: GeneraluserListRelationFilter
    student?: StudentListRelationFilter
    teacher?: TeacherListRelationFilter
    team?: TeamListRelationFilter
    teamcomment?: TeamcommentListRelationFilter
    teammember?: TeammemberListRelationFilter
    userdomain?: UserdomainListRelationFilter
  }, "user_id" | "email">

  export type userOrderByWithAggregationInput = {
    user_id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    profile_image?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    isMainAdmin?: SortOrder
    verifyToken?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: userCountOrderByAggregateInput
    _avg?: userAvgOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
    _sum?: userSumOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    OR?: userScalarWhereWithAggregatesInput[]
    NOT?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    user_id?: IntWithAggregatesFilter<"user"> | number
    name?: StringNullableWithAggregatesFilter<"user"> | string | null
    email?: StringNullableWithAggregatesFilter<"user"> | string | null
    password?: StringNullableWithAggregatesFilter<"user"> | string | null
    profile_image?: StringNullableWithAggregatesFilter<"user"> | string | null
    role?: EnumRoleNullableWithAggregatesFilter<"user"> | $Enums.Role | null
    isVerified?: BoolWithAggregatesFilter<"user"> | boolean
    isMainAdmin?: BoolWithAggregatesFilter<"user"> | boolean
    verifyToken?: StringNullableWithAggregatesFilter<"user"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"user"> | Date | string
  }

  export type adminWhereInput = {
    AND?: adminWhereInput | adminWhereInput[]
    OR?: adminWhereInput[]
    NOT?: adminWhereInput | adminWhereInput[]
    admin_id?: IntFilter<"admin"> | number
    user_id?: IntNullableFilter<"admin"> | number | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }

  export type adminOrderByWithRelationInput = {
    admin_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
  }

  export type adminWhereUniqueInput = Prisma.AtLeast<{
    admin_id?: number
    AND?: adminWhereInput | adminWhereInput[]
    OR?: adminWhereInput[]
    NOT?: adminWhereInput | adminWhereInput[]
    user_id?: IntNullableFilter<"admin"> | number | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }, "admin_id">

  export type adminOrderByWithAggregationInput = {
    admin_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    _count?: adminCountOrderByAggregateInput
    _avg?: adminAvgOrderByAggregateInput
    _max?: adminMaxOrderByAggregateInput
    _min?: adminMinOrderByAggregateInput
    _sum?: adminSumOrderByAggregateInput
  }

  export type adminScalarWhereWithAggregatesInput = {
    AND?: adminScalarWhereWithAggregatesInput | adminScalarWhereWithAggregatesInput[]
    OR?: adminScalarWhereWithAggregatesInput[]
    NOT?: adminScalarWhereWithAggregatesInput | adminScalarWhereWithAggregatesInput[]
    admin_id?: IntWithAggregatesFilter<"admin"> | number
    user_id?: IntNullableWithAggregatesFilter<"admin"> | number | null
  }

  export type departmentWhereInput = {
    AND?: departmentWhereInput | departmentWhereInput[]
    OR?: departmentWhereInput[]
    NOT?: departmentWhereInput | departmentWhereInput[]
    department_id?: IntFilter<"department"> | number
    department_name?: StringNullableFilter<"department"> | string | null
    departmentdomain?: DepartmentdomainListRelationFilter
    students?: StudentListRelationFilter
    teachers?: TeacherListRelationFilter
  }

  export type departmentOrderByWithRelationInput = {
    department_id?: SortOrder
    department_name?: SortOrderInput | SortOrder
    departmentdomain?: departmentdomainOrderByRelationAggregateInput
    students?: studentOrderByRelationAggregateInput
    teachers?: teacherOrderByRelationAggregateInput
  }

  export type departmentWhereUniqueInput = Prisma.AtLeast<{
    department_id?: number
    department_name?: string
    AND?: departmentWhereInput | departmentWhereInput[]
    OR?: departmentWhereInput[]
    NOT?: departmentWhereInput | departmentWhereInput[]
    departmentdomain?: DepartmentdomainListRelationFilter
    students?: StudentListRelationFilter
    teachers?: TeacherListRelationFilter
  }, "department_id" | "department_name">

  export type departmentOrderByWithAggregationInput = {
    department_id?: SortOrder
    department_name?: SortOrderInput | SortOrder
    _count?: departmentCountOrderByAggregateInput
    _avg?: departmentAvgOrderByAggregateInput
    _max?: departmentMaxOrderByAggregateInput
    _min?: departmentMinOrderByAggregateInput
    _sum?: departmentSumOrderByAggregateInput
  }

  export type departmentScalarWhereWithAggregatesInput = {
    AND?: departmentScalarWhereWithAggregatesInput | departmentScalarWhereWithAggregatesInput[]
    OR?: departmentScalarWhereWithAggregatesInput[]
    NOT?: departmentScalarWhereWithAggregatesInput | departmentScalarWhereWithAggregatesInput[]
    department_id?: IntWithAggregatesFilter<"department"> | number
    department_name?: StringNullableWithAggregatesFilter<"department"> | string | null
  }

  export type domainWhereInput = {
    AND?: domainWhereInput | domainWhereInput[]
    OR?: domainWhereInput[]
    NOT?: domainWhereInput | domainWhereInput[]
    domain_id?: IntFilter<"domain"> | number
    domain_name?: StringNullableFilter<"domain"> | string | null
    departmentdomain?: DepartmentdomainListRelationFilter
    team?: TeamListRelationFilter
    userdomain?: UserdomainListRelationFilter
  }

  export type domainOrderByWithRelationInput = {
    domain_id?: SortOrder
    domain_name?: SortOrderInput | SortOrder
    departmentdomain?: departmentdomainOrderByRelationAggregateInput
    team?: teamOrderByRelationAggregateInput
    userdomain?: userdomainOrderByRelationAggregateInput
  }

  export type domainWhereUniqueInput = Prisma.AtLeast<{
    domain_id?: number
    domain_name?: string
    AND?: domainWhereInput | domainWhereInput[]
    OR?: domainWhereInput[]
    NOT?: domainWhereInput | domainWhereInput[]
    departmentdomain?: DepartmentdomainListRelationFilter
    team?: TeamListRelationFilter
    userdomain?: UserdomainListRelationFilter
  }, "domain_id" | "domain_name">

  export type domainOrderByWithAggregationInput = {
    domain_id?: SortOrder
    domain_name?: SortOrderInput | SortOrder
    _count?: domainCountOrderByAggregateInput
    _avg?: domainAvgOrderByAggregateInput
    _max?: domainMaxOrderByAggregateInput
    _min?: domainMinOrderByAggregateInput
    _sum?: domainSumOrderByAggregateInput
  }

  export type domainScalarWhereWithAggregatesInput = {
    AND?: domainScalarWhereWithAggregatesInput | domainScalarWhereWithAggregatesInput[]
    OR?: domainScalarWhereWithAggregatesInput[]
    NOT?: domainScalarWhereWithAggregatesInput | domainScalarWhereWithAggregatesInput[]
    domain_id?: IntWithAggregatesFilter<"domain"> | number
    domain_name?: StringNullableWithAggregatesFilter<"domain"> | string | null
  }

  export type departmentdomainWhereInput = {
    AND?: departmentdomainWhereInput | departmentdomainWhereInput[]
    OR?: departmentdomainWhereInput[]
    NOT?: departmentdomainWhereInput | departmentdomainWhereInput[]
    department_id?: IntFilter<"departmentdomain"> | number
    domain_id?: IntFilter<"departmentdomain"> | number
    department?: XOR<DepartmentScalarRelationFilter, departmentWhereInput>
    domain?: XOR<DomainScalarRelationFilter, domainWhereInput>
  }

  export type departmentdomainOrderByWithRelationInput = {
    department_id?: SortOrder
    domain_id?: SortOrder
    department?: departmentOrderByWithRelationInput
    domain?: domainOrderByWithRelationInput
  }

  export type departmentdomainWhereUniqueInput = Prisma.AtLeast<{
    department_id_domain_id?: departmentdomainDepartment_idDomain_idCompoundUniqueInput
    AND?: departmentdomainWhereInput | departmentdomainWhereInput[]
    OR?: departmentdomainWhereInput[]
    NOT?: departmentdomainWhereInput | departmentdomainWhereInput[]
    department_id?: IntFilter<"departmentdomain"> | number
    domain_id?: IntFilter<"departmentdomain"> | number
    department?: XOR<DepartmentScalarRelationFilter, departmentWhereInput>
    domain?: XOR<DomainScalarRelationFilter, domainWhereInput>
  }, "department_id_domain_id">

  export type departmentdomainOrderByWithAggregationInput = {
    department_id?: SortOrder
    domain_id?: SortOrder
    _count?: departmentdomainCountOrderByAggregateInput
    _avg?: departmentdomainAvgOrderByAggregateInput
    _max?: departmentdomainMaxOrderByAggregateInput
    _min?: departmentdomainMinOrderByAggregateInput
    _sum?: departmentdomainSumOrderByAggregateInput
  }

  export type departmentdomainScalarWhereWithAggregatesInput = {
    AND?: departmentdomainScalarWhereWithAggregatesInput | departmentdomainScalarWhereWithAggregatesInput[]
    OR?: departmentdomainScalarWhereWithAggregatesInput[]
    NOT?: departmentdomainScalarWhereWithAggregatesInput | departmentdomainScalarWhereWithAggregatesInput[]
    department_id?: IntWithAggregatesFilter<"departmentdomain"> | number
    domain_id?: IntWithAggregatesFilter<"departmentdomain"> | number
  }

  export type generaluserWhereInput = {
    AND?: generaluserWhereInput | generaluserWhereInput[]
    OR?: generaluserWhereInput[]
    NOT?: generaluserWhereInput | generaluserWhereInput[]
    generaluser_id?: IntFilter<"generaluser"> | number
    user_id?: IntNullableFilter<"generaluser"> | number | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }

  export type generaluserOrderByWithRelationInput = {
    generaluser_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
  }

  export type generaluserWhereUniqueInput = Prisma.AtLeast<{
    generaluser_id?: number
    AND?: generaluserWhereInput | generaluserWhereInput[]
    OR?: generaluserWhereInput[]
    NOT?: generaluserWhereInput | generaluserWhereInput[]
    user_id?: IntNullableFilter<"generaluser"> | number | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }, "generaluser_id">

  export type generaluserOrderByWithAggregationInput = {
    generaluser_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    _count?: generaluserCountOrderByAggregateInput
    _avg?: generaluserAvgOrderByAggregateInput
    _max?: generaluserMaxOrderByAggregateInput
    _min?: generaluserMinOrderByAggregateInput
    _sum?: generaluserSumOrderByAggregateInput
  }

  export type generaluserScalarWhereWithAggregatesInput = {
    AND?: generaluserScalarWhereWithAggregatesInput | generaluserScalarWhereWithAggregatesInput[]
    OR?: generaluserScalarWhereWithAggregatesInput[]
    NOT?: generaluserScalarWhereWithAggregatesInput | generaluserScalarWhereWithAggregatesInput[]
    generaluser_id?: IntWithAggregatesFilter<"generaluser"> | number
    user_id?: IntNullableWithAggregatesFilter<"generaluser"> | number | null
  }

  export type studentWhereInput = {
    AND?: studentWhereInput | studentWhereInput[]
    OR?: studentWhereInput[]
    NOT?: studentWhereInput | studentWhereInput[]
    student_id?: IntFilter<"student"> | number
    roll_number?: StringNullableFilter<"student"> | string | null
    department_id?: IntNullableFilter<"student"> | number | null
    user_id?: IntNullableFilter<"student"> | number | null
    department?: XOR<DepartmentNullableScalarRelationFilter, departmentWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    teamapplication?: TeamapplicationListRelationFilter
  }

  export type studentOrderByWithRelationInput = {
    student_id?: SortOrder
    roll_number?: SortOrderInput | SortOrder
    department_id?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    department?: departmentOrderByWithRelationInput
    user?: userOrderByWithRelationInput
    teamapplication?: teamapplicationOrderByRelationAggregateInput
  }

  export type studentWhereUniqueInput = Prisma.AtLeast<{
    student_id?: number
    AND?: studentWhereInput | studentWhereInput[]
    OR?: studentWhereInput[]
    NOT?: studentWhereInput | studentWhereInput[]
    roll_number?: StringNullableFilter<"student"> | string | null
    department_id?: IntNullableFilter<"student"> | number | null
    user_id?: IntNullableFilter<"student"> | number | null
    department?: XOR<DepartmentNullableScalarRelationFilter, departmentWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    teamapplication?: TeamapplicationListRelationFilter
  }, "student_id">

  export type studentOrderByWithAggregationInput = {
    student_id?: SortOrder
    roll_number?: SortOrderInput | SortOrder
    department_id?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    _count?: studentCountOrderByAggregateInput
    _avg?: studentAvgOrderByAggregateInput
    _max?: studentMaxOrderByAggregateInput
    _min?: studentMinOrderByAggregateInput
    _sum?: studentSumOrderByAggregateInput
  }

  export type studentScalarWhereWithAggregatesInput = {
    AND?: studentScalarWhereWithAggregatesInput | studentScalarWhereWithAggregatesInput[]
    OR?: studentScalarWhereWithAggregatesInput[]
    NOT?: studentScalarWhereWithAggregatesInput | studentScalarWhereWithAggregatesInput[]
    student_id?: IntWithAggregatesFilter<"student"> | number
    roll_number?: StringNullableWithAggregatesFilter<"student"> | string | null
    department_id?: IntNullableWithAggregatesFilter<"student"> | number | null
    user_id?: IntNullableWithAggregatesFilter<"student"> | number | null
  }

  export type teacherWhereInput = {
    AND?: teacherWhereInput | teacherWhereInput[]
    OR?: teacherWhereInput[]
    NOT?: teacherWhereInput | teacherWhereInput[]
    teacher_id?: IntFilter<"teacher"> | number
    designation?: StringNullableFilter<"teacher"> | string | null
    department_id?: IntNullableFilter<"teacher"> | number | null
    user_id?: IntNullableFilter<"teacher"> | number | null
    isReviewer?: BoolFilter<"teacher"> | boolean
    paper?: PaperListRelationFilter
    proposal?: ProposalListRelationFilter
    reviewer?: XOR<ReviewerNullableScalarRelationFilter, reviewerWhereInput> | null
    department?: XOR<DepartmentNullableScalarRelationFilter, departmentWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }

  export type teacherOrderByWithRelationInput = {
    teacher_id?: SortOrder
    designation?: SortOrderInput | SortOrder
    department_id?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    isReviewer?: SortOrder
    paper?: paperOrderByRelationAggregateInput
    proposal?: proposalOrderByRelationAggregateInput
    reviewer?: reviewerOrderByWithRelationInput
    department?: departmentOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type teacherWhereUniqueInput = Prisma.AtLeast<{
    teacher_id?: number
    AND?: teacherWhereInput | teacherWhereInput[]
    OR?: teacherWhereInput[]
    NOT?: teacherWhereInput | teacherWhereInput[]
    designation?: StringNullableFilter<"teacher"> | string | null
    department_id?: IntNullableFilter<"teacher"> | number | null
    user_id?: IntNullableFilter<"teacher"> | number | null
    isReviewer?: BoolFilter<"teacher"> | boolean
    paper?: PaperListRelationFilter
    proposal?: ProposalListRelationFilter
    reviewer?: XOR<ReviewerNullableScalarRelationFilter, reviewerWhereInput> | null
    department?: XOR<DepartmentNullableScalarRelationFilter, departmentWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }, "teacher_id">

  export type teacherOrderByWithAggregationInput = {
    teacher_id?: SortOrder
    designation?: SortOrderInput | SortOrder
    department_id?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    isReviewer?: SortOrder
    _count?: teacherCountOrderByAggregateInput
    _avg?: teacherAvgOrderByAggregateInput
    _max?: teacherMaxOrderByAggregateInput
    _min?: teacherMinOrderByAggregateInput
    _sum?: teacherSumOrderByAggregateInput
  }

  export type teacherScalarWhereWithAggregatesInput = {
    AND?: teacherScalarWhereWithAggregatesInput | teacherScalarWhereWithAggregatesInput[]
    OR?: teacherScalarWhereWithAggregatesInput[]
    NOT?: teacherScalarWhereWithAggregatesInput | teacherScalarWhereWithAggregatesInput[]
    teacher_id?: IntWithAggregatesFilter<"teacher"> | number
    designation?: StringNullableWithAggregatesFilter<"teacher"> | string | null
    department_id?: IntNullableWithAggregatesFilter<"teacher"> | number | null
    user_id?: IntNullableWithAggregatesFilter<"teacher"> | number | null
    isReviewer?: BoolWithAggregatesFilter<"teacher"> | boolean
  }

  export type reviewerWhereInput = {
    AND?: reviewerWhereInput | reviewerWhereInput[]
    OR?: reviewerWhereInput[]
    NOT?: reviewerWhereInput | reviewerWhereInput[]
    reviewer_id?: IntFilter<"reviewer"> | number
    teacher_id?: IntNullableFilter<"reviewer"> | number | null
    status?: EnumReviewerStatusNullableFilter<"reviewer"> | $Enums.ReviewerStatus | null
    review?: ReviewListRelationFilter
    teacher?: XOR<TeacherNullableScalarRelationFilter, teacherWhereInput> | null
    reviewerassignment?: ReviewerassignmentListRelationFilter
  }

  export type reviewerOrderByWithRelationInput = {
    reviewer_id?: SortOrder
    teacher_id?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    review?: reviewOrderByRelationAggregateInput
    teacher?: teacherOrderByWithRelationInput
    reviewerassignment?: reviewerassignmentOrderByRelationAggregateInput
  }

  export type reviewerWhereUniqueInput = Prisma.AtLeast<{
    reviewer_id?: number
    teacher_id?: number
    AND?: reviewerWhereInput | reviewerWhereInput[]
    OR?: reviewerWhereInput[]
    NOT?: reviewerWhereInput | reviewerWhereInput[]
    status?: EnumReviewerStatusNullableFilter<"reviewer"> | $Enums.ReviewerStatus | null
    review?: ReviewListRelationFilter
    teacher?: XOR<TeacherNullableScalarRelationFilter, teacherWhereInput> | null
    reviewerassignment?: ReviewerassignmentListRelationFilter
  }, "reviewer_id" | "teacher_id">

  export type reviewerOrderByWithAggregationInput = {
    reviewer_id?: SortOrder
    teacher_id?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    _count?: reviewerCountOrderByAggregateInput
    _avg?: reviewerAvgOrderByAggregateInput
    _max?: reviewerMaxOrderByAggregateInput
    _min?: reviewerMinOrderByAggregateInput
    _sum?: reviewerSumOrderByAggregateInput
  }

  export type reviewerScalarWhereWithAggregatesInput = {
    AND?: reviewerScalarWhereWithAggregatesInput | reviewerScalarWhereWithAggregatesInput[]
    OR?: reviewerScalarWhereWithAggregatesInput[]
    NOT?: reviewerScalarWhereWithAggregatesInput | reviewerScalarWhereWithAggregatesInput[]
    reviewer_id?: IntWithAggregatesFilter<"reviewer"> | number
    teacher_id?: IntNullableWithAggregatesFilter<"reviewer"> | number | null
    status?: EnumReviewerStatusNullableWithAggregatesFilter<"reviewer"> | $Enums.ReviewerStatus | null
  }

  export type teamWhereInput = {
    AND?: teamWhereInput | teamWhereInput[]
    OR?: teamWhereInput[]
    NOT?: teamWhereInput | teamWhereInput[]
    team_id?: IntFilter<"team"> | number
    team_name?: StringNullableFilter<"team"> | string | null
    team_description?: StringNullableFilter<"team"> | string | null
    domain_id?: IntNullableFilter<"team"> | number | null
    status?: EnumTeamStatusNullableFilter<"team"> | $Enums.TeamStatus | null
    visibility?: EnumTeamVisibilityNullableFilter<"team"> | $Enums.TeamVisibility | null
    max_members?: IntNullableFilter<"team"> | number | null
    isHiring?: BoolNullableFilter<"team"> | boolean | null
    created_at?: DateTimeFilter<"team"> | Date | string
    created_by_user_id?: IntNullableFilter<"team"> | number | null
    paper?: PaperListRelationFilter
    proposal?: ProposalListRelationFilter
    created_by_user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    domain?: XOR<DomainNullableScalarRelationFilter, domainWhereInput> | null
    teamapplication?: TeamapplicationListRelationFilter
    teamcomment?: TeamcommentListRelationFilter
    teammember?: TeammemberListRelationFilter
  }

  export type teamOrderByWithRelationInput = {
    team_id?: SortOrder
    team_name?: SortOrderInput | SortOrder
    team_description?: SortOrderInput | SortOrder
    domain_id?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    visibility?: SortOrderInput | SortOrder
    max_members?: SortOrderInput | SortOrder
    isHiring?: SortOrderInput | SortOrder
    created_at?: SortOrder
    created_by_user_id?: SortOrderInput | SortOrder
    paper?: paperOrderByRelationAggregateInput
    proposal?: proposalOrderByRelationAggregateInput
    created_by_user?: userOrderByWithRelationInput
    domain?: domainOrderByWithRelationInput
    teamapplication?: teamapplicationOrderByRelationAggregateInput
    teamcomment?: teamcommentOrderByRelationAggregateInput
    teammember?: teammemberOrderByRelationAggregateInput
  }

  export type teamWhereUniqueInput = Prisma.AtLeast<{
    team_id?: number
    AND?: teamWhereInput | teamWhereInput[]
    OR?: teamWhereInput[]
    NOT?: teamWhereInput | teamWhereInput[]
    team_name?: StringNullableFilter<"team"> | string | null
    team_description?: StringNullableFilter<"team"> | string | null
    domain_id?: IntNullableFilter<"team"> | number | null
    status?: EnumTeamStatusNullableFilter<"team"> | $Enums.TeamStatus | null
    visibility?: EnumTeamVisibilityNullableFilter<"team"> | $Enums.TeamVisibility | null
    max_members?: IntNullableFilter<"team"> | number | null
    isHiring?: BoolNullableFilter<"team"> | boolean | null
    created_at?: DateTimeFilter<"team"> | Date | string
    created_by_user_id?: IntNullableFilter<"team"> | number | null
    paper?: PaperListRelationFilter
    proposal?: ProposalListRelationFilter
    created_by_user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    domain?: XOR<DomainNullableScalarRelationFilter, domainWhereInput> | null
    teamapplication?: TeamapplicationListRelationFilter
    teamcomment?: TeamcommentListRelationFilter
    teammember?: TeammemberListRelationFilter
  }, "team_id">

  export type teamOrderByWithAggregationInput = {
    team_id?: SortOrder
    team_name?: SortOrderInput | SortOrder
    team_description?: SortOrderInput | SortOrder
    domain_id?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    visibility?: SortOrderInput | SortOrder
    max_members?: SortOrderInput | SortOrder
    isHiring?: SortOrderInput | SortOrder
    created_at?: SortOrder
    created_by_user_id?: SortOrderInput | SortOrder
    _count?: teamCountOrderByAggregateInput
    _avg?: teamAvgOrderByAggregateInput
    _max?: teamMaxOrderByAggregateInput
    _min?: teamMinOrderByAggregateInput
    _sum?: teamSumOrderByAggregateInput
  }

  export type teamScalarWhereWithAggregatesInput = {
    AND?: teamScalarWhereWithAggregatesInput | teamScalarWhereWithAggregatesInput[]
    OR?: teamScalarWhereWithAggregatesInput[]
    NOT?: teamScalarWhereWithAggregatesInput | teamScalarWhereWithAggregatesInput[]
    team_id?: IntWithAggregatesFilter<"team"> | number
    team_name?: StringNullableWithAggregatesFilter<"team"> | string | null
    team_description?: StringNullableWithAggregatesFilter<"team"> | string | null
    domain_id?: IntNullableWithAggregatesFilter<"team"> | number | null
    status?: EnumTeamStatusNullableWithAggregatesFilter<"team"> | $Enums.TeamStatus | null
    visibility?: EnumTeamVisibilityNullableWithAggregatesFilter<"team"> | $Enums.TeamVisibility | null
    max_members?: IntNullableWithAggregatesFilter<"team"> | number | null
    isHiring?: BoolNullableWithAggregatesFilter<"team"> | boolean | null
    created_at?: DateTimeWithAggregatesFilter<"team"> | Date | string
    created_by_user_id?: IntNullableWithAggregatesFilter<"team"> | number | null
  }

  export type teammemberWhereInput = {
    AND?: teammemberWhereInput | teammemberWhereInput[]
    OR?: teammemberWhereInput[]
    NOT?: teammemberWhereInput | teammemberWhereInput[]
    team_id?: IntFilter<"teammember"> | number
    user_id?: IntFilter<"teammember"> | number
    role_in_team?: EnumTeamRoleNullableFilter<"teammember"> | $Enums.TeamRole | null
    team?: XOR<TeamScalarRelationFilter, teamWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type teammemberOrderByWithRelationInput = {
    team_id?: SortOrder
    user_id?: SortOrder
    role_in_team?: SortOrderInput | SortOrder
    team?: teamOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type teammemberWhereUniqueInput = Prisma.AtLeast<{
    team_id_user_id?: teammemberTeam_idUser_idCompoundUniqueInput
    AND?: teammemberWhereInput | teammemberWhereInput[]
    OR?: teammemberWhereInput[]
    NOT?: teammemberWhereInput | teammemberWhereInput[]
    team_id?: IntFilter<"teammember"> | number
    user_id?: IntFilter<"teammember"> | number
    role_in_team?: EnumTeamRoleNullableFilter<"teammember"> | $Enums.TeamRole | null
    team?: XOR<TeamScalarRelationFilter, teamWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "team_id_user_id">

  export type teammemberOrderByWithAggregationInput = {
    team_id?: SortOrder
    user_id?: SortOrder
    role_in_team?: SortOrderInput | SortOrder
    _count?: teammemberCountOrderByAggregateInput
    _avg?: teammemberAvgOrderByAggregateInput
    _max?: teammemberMaxOrderByAggregateInput
    _min?: teammemberMinOrderByAggregateInput
    _sum?: teammemberSumOrderByAggregateInput
  }

  export type teammemberScalarWhereWithAggregatesInput = {
    AND?: teammemberScalarWhereWithAggregatesInput | teammemberScalarWhereWithAggregatesInput[]
    OR?: teammemberScalarWhereWithAggregatesInput[]
    NOT?: teammemberScalarWhereWithAggregatesInput | teammemberScalarWhereWithAggregatesInput[]
    team_id?: IntWithAggregatesFilter<"teammember"> | number
    user_id?: IntWithAggregatesFilter<"teammember"> | number
    role_in_team?: EnumTeamRoleNullableWithAggregatesFilter<"teammember"> | $Enums.TeamRole | null
  }

  export type teamapplicationWhereInput = {
    AND?: teamapplicationWhereInput | teamapplicationWhereInput[]
    OR?: teamapplicationWhereInput[]
    NOT?: teamapplicationWhereInput | teamapplicationWhereInput[]
    application_id?: IntFilter<"teamapplication"> | number
    team_id?: IntFilter<"teamapplication"> | number
    student_id?: IntFilter<"teamapplication"> | number
    status?: EnumApplicationStatusFilter<"teamapplication"> | $Enums.ApplicationStatus
    applied_at?: DateTimeFilter<"teamapplication"> | Date | string
    student?: XOR<StudentScalarRelationFilter, studentWhereInput>
    team?: XOR<TeamScalarRelationFilter, teamWhereInput>
  }

  export type teamapplicationOrderByWithRelationInput = {
    application_id?: SortOrder
    team_id?: SortOrder
    student_id?: SortOrder
    status?: SortOrder
    applied_at?: SortOrder
    student?: studentOrderByWithRelationInput
    team?: teamOrderByWithRelationInput
  }

  export type teamapplicationWhereUniqueInput = Prisma.AtLeast<{
    application_id?: number
    team_id_student_id?: teamapplicationTeam_idStudent_idCompoundUniqueInput
    AND?: teamapplicationWhereInput | teamapplicationWhereInput[]
    OR?: teamapplicationWhereInput[]
    NOT?: teamapplicationWhereInput | teamapplicationWhereInput[]
    team_id?: IntFilter<"teamapplication"> | number
    student_id?: IntFilter<"teamapplication"> | number
    status?: EnumApplicationStatusFilter<"teamapplication"> | $Enums.ApplicationStatus
    applied_at?: DateTimeFilter<"teamapplication"> | Date | string
    student?: XOR<StudentScalarRelationFilter, studentWhereInput>
    team?: XOR<TeamScalarRelationFilter, teamWhereInput>
  }, "application_id" | "team_id_student_id">

  export type teamapplicationOrderByWithAggregationInput = {
    application_id?: SortOrder
    team_id?: SortOrder
    student_id?: SortOrder
    status?: SortOrder
    applied_at?: SortOrder
    _count?: teamapplicationCountOrderByAggregateInput
    _avg?: teamapplicationAvgOrderByAggregateInput
    _max?: teamapplicationMaxOrderByAggregateInput
    _min?: teamapplicationMinOrderByAggregateInput
    _sum?: teamapplicationSumOrderByAggregateInput
  }

  export type teamapplicationScalarWhereWithAggregatesInput = {
    AND?: teamapplicationScalarWhereWithAggregatesInput | teamapplicationScalarWhereWithAggregatesInput[]
    OR?: teamapplicationScalarWhereWithAggregatesInput[]
    NOT?: teamapplicationScalarWhereWithAggregatesInput | teamapplicationScalarWhereWithAggregatesInput[]
    application_id?: IntWithAggregatesFilter<"teamapplication"> | number
    team_id?: IntWithAggregatesFilter<"teamapplication"> | number
    student_id?: IntWithAggregatesFilter<"teamapplication"> | number
    status?: EnumApplicationStatusWithAggregatesFilter<"teamapplication"> | $Enums.ApplicationStatus
    applied_at?: DateTimeWithAggregatesFilter<"teamapplication"> | Date | string
  }

  export type teamcommentWhereInput = {
    AND?: teamcommentWhereInput | teamcommentWhereInput[]
    OR?: teamcommentWhereInput[]
    NOT?: teamcommentWhereInput | teamcommentWhereInput[]
    comment_id?: IntFilter<"teamcomment"> | number
    team_id?: IntFilter<"teamcomment"> | number
    user_id?: IntFilter<"teamcomment"> | number
    comment?: StringFilter<"teamcomment"> | string
    created_at?: DateTimeFilter<"teamcomment"> | Date | string
    team?: XOR<TeamScalarRelationFilter, teamWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type teamcommentOrderByWithRelationInput = {
    comment_id?: SortOrder
    team_id?: SortOrder
    user_id?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
    team?: teamOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type teamcommentWhereUniqueInput = Prisma.AtLeast<{
    comment_id?: number
    AND?: teamcommentWhereInput | teamcommentWhereInput[]
    OR?: teamcommentWhereInput[]
    NOT?: teamcommentWhereInput | teamcommentWhereInput[]
    team_id?: IntFilter<"teamcomment"> | number
    user_id?: IntFilter<"teamcomment"> | number
    comment?: StringFilter<"teamcomment"> | string
    created_at?: DateTimeFilter<"teamcomment"> | Date | string
    team?: XOR<TeamScalarRelationFilter, teamWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "comment_id">

  export type teamcommentOrderByWithAggregationInput = {
    comment_id?: SortOrder
    team_id?: SortOrder
    user_id?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
    _count?: teamcommentCountOrderByAggregateInput
    _avg?: teamcommentAvgOrderByAggregateInput
    _max?: teamcommentMaxOrderByAggregateInput
    _min?: teamcommentMinOrderByAggregateInput
    _sum?: teamcommentSumOrderByAggregateInput
  }

  export type teamcommentScalarWhereWithAggregatesInput = {
    AND?: teamcommentScalarWhereWithAggregatesInput | teamcommentScalarWhereWithAggregatesInput[]
    OR?: teamcommentScalarWhereWithAggregatesInput[]
    NOT?: teamcommentScalarWhereWithAggregatesInput | teamcommentScalarWhereWithAggregatesInput[]
    comment_id?: IntWithAggregatesFilter<"teamcomment"> | number
    team_id?: IntWithAggregatesFilter<"teamcomment"> | number
    user_id?: IntWithAggregatesFilter<"teamcomment"> | number
    comment?: StringWithAggregatesFilter<"teamcomment"> | string
    created_at?: DateTimeWithAggregatesFilter<"teamcomment"> | Date | string
  }

  export type paperWhereInput = {
    AND?: paperWhereInput | paperWhereInput[]
    OR?: paperWhereInput[]
    NOT?: paperWhereInput | paperWhereInput[]
    paper_id?: IntFilter<"paper"> | number
    title?: StringNullableFilter<"paper"> | string | null
    abstract?: StringNullableFilter<"paper"> | string | null
    status?: EnumPaperStatusNullableFilter<"paper"> | $Enums.PaperStatus | null
    team_id?: IntNullableFilter<"paper"> | number | null
    submitted_by?: IntNullableFilter<"paper"> | number | null
    pdf_path?: StringNullableFilter<"paper"> | string | null
    file_size?: IntNullableFilter<"paper"> | number | null
    created_at?: DateTimeFilter<"paper"> | Date | string
    aggregated_decided_at?: DateTimeNullableFilter<"paper"> | Date | string | null
    aggregated_decision?: EnumReviewDecisionNullableFilter<"paper"> | $Enums.ReviewDecision | null
    teacher?: XOR<TeacherNullableScalarRelationFilter, teacherWhereInput> | null
    team?: XOR<TeamNullableScalarRelationFilter, teamWhereInput> | null
    review?: ReviewListRelationFilter
    reviewerassignment?: ReviewerassignmentListRelationFilter
  }

  export type paperOrderByWithRelationInput = {
    paper_id?: SortOrder
    title?: SortOrderInput | SortOrder
    abstract?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    team_id?: SortOrderInput | SortOrder
    submitted_by?: SortOrderInput | SortOrder
    pdf_path?: SortOrderInput | SortOrder
    file_size?: SortOrderInput | SortOrder
    created_at?: SortOrder
    aggregated_decided_at?: SortOrderInput | SortOrder
    aggregated_decision?: SortOrderInput | SortOrder
    teacher?: teacherOrderByWithRelationInput
    team?: teamOrderByWithRelationInput
    review?: reviewOrderByRelationAggregateInput
    reviewerassignment?: reviewerassignmentOrderByRelationAggregateInput
  }

  export type paperWhereUniqueInput = Prisma.AtLeast<{
    paper_id?: number
    AND?: paperWhereInput | paperWhereInput[]
    OR?: paperWhereInput[]
    NOT?: paperWhereInput | paperWhereInput[]
    title?: StringNullableFilter<"paper"> | string | null
    abstract?: StringNullableFilter<"paper"> | string | null
    status?: EnumPaperStatusNullableFilter<"paper"> | $Enums.PaperStatus | null
    team_id?: IntNullableFilter<"paper"> | number | null
    submitted_by?: IntNullableFilter<"paper"> | number | null
    pdf_path?: StringNullableFilter<"paper"> | string | null
    file_size?: IntNullableFilter<"paper"> | number | null
    created_at?: DateTimeFilter<"paper"> | Date | string
    aggregated_decided_at?: DateTimeNullableFilter<"paper"> | Date | string | null
    aggregated_decision?: EnumReviewDecisionNullableFilter<"paper"> | $Enums.ReviewDecision | null
    teacher?: XOR<TeacherNullableScalarRelationFilter, teacherWhereInput> | null
    team?: XOR<TeamNullableScalarRelationFilter, teamWhereInput> | null
    review?: ReviewListRelationFilter
    reviewerassignment?: ReviewerassignmentListRelationFilter
  }, "paper_id">

  export type paperOrderByWithAggregationInput = {
    paper_id?: SortOrder
    title?: SortOrderInput | SortOrder
    abstract?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    team_id?: SortOrderInput | SortOrder
    submitted_by?: SortOrderInput | SortOrder
    pdf_path?: SortOrderInput | SortOrder
    file_size?: SortOrderInput | SortOrder
    created_at?: SortOrder
    aggregated_decided_at?: SortOrderInput | SortOrder
    aggregated_decision?: SortOrderInput | SortOrder
    _count?: paperCountOrderByAggregateInput
    _avg?: paperAvgOrderByAggregateInput
    _max?: paperMaxOrderByAggregateInput
    _min?: paperMinOrderByAggregateInput
    _sum?: paperSumOrderByAggregateInput
  }

  export type paperScalarWhereWithAggregatesInput = {
    AND?: paperScalarWhereWithAggregatesInput | paperScalarWhereWithAggregatesInput[]
    OR?: paperScalarWhereWithAggregatesInput[]
    NOT?: paperScalarWhereWithAggregatesInput | paperScalarWhereWithAggregatesInput[]
    paper_id?: IntWithAggregatesFilter<"paper"> | number
    title?: StringNullableWithAggregatesFilter<"paper"> | string | null
    abstract?: StringNullableWithAggregatesFilter<"paper"> | string | null
    status?: EnumPaperStatusNullableWithAggregatesFilter<"paper"> | $Enums.PaperStatus | null
    team_id?: IntNullableWithAggregatesFilter<"paper"> | number | null
    submitted_by?: IntNullableWithAggregatesFilter<"paper"> | number | null
    pdf_path?: StringNullableWithAggregatesFilter<"paper"> | string | null
    file_size?: IntNullableWithAggregatesFilter<"paper"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"paper"> | Date | string
    aggregated_decided_at?: DateTimeNullableWithAggregatesFilter<"paper"> | Date | string | null
    aggregated_decision?: EnumReviewDecisionNullableWithAggregatesFilter<"paper"> | $Enums.ReviewDecision | null
  }

  export type proposalWhereInput = {
    AND?: proposalWhereInput | proposalWhereInput[]
    OR?: proposalWhereInput[]
    NOT?: proposalWhereInput | proposalWhereInput[]
    proposal_id?: IntFilter<"proposal"> | number
    title?: StringNullableFilter<"proposal"> | string | null
    abstract?: StringNullableFilter<"proposal"> | string | null
    status?: EnumPaperStatusNullableFilter<"proposal"> | $Enums.PaperStatus | null
    team_id?: IntNullableFilter<"proposal"> | number | null
    submitted_by?: IntNullableFilter<"proposal"> | number | null
    pdf_path?: StringNullableFilter<"proposal"> | string | null
    file_size?: IntNullableFilter<"proposal"> | number | null
    created_at?: DateTimeFilter<"proposal"> | Date | string
    aggregated_decided_at?: DateTimeNullableFilter<"proposal"> | Date | string | null
    aggregated_decision?: EnumReviewDecisionNullableFilter<"proposal"> | $Enums.ReviewDecision | null
    teacher?: XOR<TeacherNullableScalarRelationFilter, teacherWhereInput> | null
    team?: XOR<TeamNullableScalarRelationFilter, teamWhereInput> | null
    review?: ReviewListRelationFilter
    reviewerassignment?: ReviewerassignmentListRelationFilter
  }

  export type proposalOrderByWithRelationInput = {
    proposal_id?: SortOrder
    title?: SortOrderInput | SortOrder
    abstract?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    team_id?: SortOrderInput | SortOrder
    submitted_by?: SortOrderInput | SortOrder
    pdf_path?: SortOrderInput | SortOrder
    file_size?: SortOrderInput | SortOrder
    created_at?: SortOrder
    aggregated_decided_at?: SortOrderInput | SortOrder
    aggregated_decision?: SortOrderInput | SortOrder
    teacher?: teacherOrderByWithRelationInput
    team?: teamOrderByWithRelationInput
    review?: reviewOrderByRelationAggregateInput
    reviewerassignment?: reviewerassignmentOrderByRelationAggregateInput
  }

  export type proposalWhereUniqueInput = Prisma.AtLeast<{
    proposal_id?: number
    AND?: proposalWhereInput | proposalWhereInput[]
    OR?: proposalWhereInput[]
    NOT?: proposalWhereInput | proposalWhereInput[]
    title?: StringNullableFilter<"proposal"> | string | null
    abstract?: StringNullableFilter<"proposal"> | string | null
    status?: EnumPaperStatusNullableFilter<"proposal"> | $Enums.PaperStatus | null
    team_id?: IntNullableFilter<"proposal"> | number | null
    submitted_by?: IntNullableFilter<"proposal"> | number | null
    pdf_path?: StringNullableFilter<"proposal"> | string | null
    file_size?: IntNullableFilter<"proposal"> | number | null
    created_at?: DateTimeFilter<"proposal"> | Date | string
    aggregated_decided_at?: DateTimeNullableFilter<"proposal"> | Date | string | null
    aggregated_decision?: EnumReviewDecisionNullableFilter<"proposal"> | $Enums.ReviewDecision | null
    teacher?: XOR<TeacherNullableScalarRelationFilter, teacherWhereInput> | null
    team?: XOR<TeamNullableScalarRelationFilter, teamWhereInput> | null
    review?: ReviewListRelationFilter
    reviewerassignment?: ReviewerassignmentListRelationFilter
  }, "proposal_id">

  export type proposalOrderByWithAggregationInput = {
    proposal_id?: SortOrder
    title?: SortOrderInput | SortOrder
    abstract?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    team_id?: SortOrderInput | SortOrder
    submitted_by?: SortOrderInput | SortOrder
    pdf_path?: SortOrderInput | SortOrder
    file_size?: SortOrderInput | SortOrder
    created_at?: SortOrder
    aggregated_decided_at?: SortOrderInput | SortOrder
    aggregated_decision?: SortOrderInput | SortOrder
    _count?: proposalCountOrderByAggregateInput
    _avg?: proposalAvgOrderByAggregateInput
    _max?: proposalMaxOrderByAggregateInput
    _min?: proposalMinOrderByAggregateInput
    _sum?: proposalSumOrderByAggregateInput
  }

  export type proposalScalarWhereWithAggregatesInput = {
    AND?: proposalScalarWhereWithAggregatesInput | proposalScalarWhereWithAggregatesInput[]
    OR?: proposalScalarWhereWithAggregatesInput[]
    NOT?: proposalScalarWhereWithAggregatesInput | proposalScalarWhereWithAggregatesInput[]
    proposal_id?: IntWithAggregatesFilter<"proposal"> | number
    title?: StringNullableWithAggregatesFilter<"proposal"> | string | null
    abstract?: StringNullableWithAggregatesFilter<"proposal"> | string | null
    status?: EnumPaperStatusNullableWithAggregatesFilter<"proposal"> | $Enums.PaperStatus | null
    team_id?: IntNullableWithAggregatesFilter<"proposal"> | number | null
    submitted_by?: IntNullableWithAggregatesFilter<"proposal"> | number | null
    pdf_path?: StringNullableWithAggregatesFilter<"proposal"> | string | null
    file_size?: IntNullableWithAggregatesFilter<"proposal"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"proposal"> | Date | string
    aggregated_decided_at?: DateTimeNullableWithAggregatesFilter<"proposal"> | Date | string | null
    aggregated_decision?: EnumReviewDecisionNullableWithAggregatesFilter<"proposal"> | $Enums.ReviewDecision | null
  }

  export type reviewWhereInput = {
    AND?: reviewWhereInput | reviewWhereInput[]
    OR?: reviewWhereInput[]
    NOT?: reviewWhereInput | reviewWhereInput[]
    review_id?: IntFilter<"review"> | number
    reviewer_id?: IntNullableFilter<"review"> | number | null
    proposal_id?: IntNullableFilter<"review"> | number | null
    paper_id?: IntNullableFilter<"review"> | number | null
    comments?: StringNullableFilter<"review"> | string | null
    score?: IntNullableFilter<"review"> | number | null
    reviewed_at?: DateTimeFilter<"review"> | Date | string
    attachment_path?: StringNullableFilter<"review"> | string | null
    decision?: EnumReviewDecisionNullableFilter<"review"> | $Enums.ReviewDecision | null
    paper?: XOR<PaperNullableScalarRelationFilter, paperWhereInput> | null
    proposal?: XOR<ProposalNullableScalarRelationFilter, proposalWhereInput> | null
    reviewer?: XOR<ReviewerNullableScalarRelationFilter, reviewerWhereInput> | null
  }

  export type reviewOrderByWithRelationInput = {
    review_id?: SortOrder
    reviewer_id?: SortOrderInput | SortOrder
    proposal_id?: SortOrderInput | SortOrder
    paper_id?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    reviewed_at?: SortOrder
    attachment_path?: SortOrderInput | SortOrder
    decision?: SortOrderInput | SortOrder
    paper?: paperOrderByWithRelationInput
    proposal?: proposalOrderByWithRelationInput
    reviewer?: reviewerOrderByWithRelationInput
  }

  export type reviewWhereUniqueInput = Prisma.AtLeast<{
    review_id?: number
    AND?: reviewWhereInput | reviewWhereInput[]
    OR?: reviewWhereInput[]
    NOT?: reviewWhereInput | reviewWhereInput[]
    reviewer_id?: IntNullableFilter<"review"> | number | null
    proposal_id?: IntNullableFilter<"review"> | number | null
    paper_id?: IntNullableFilter<"review"> | number | null
    comments?: StringNullableFilter<"review"> | string | null
    score?: IntNullableFilter<"review"> | number | null
    reviewed_at?: DateTimeFilter<"review"> | Date | string
    attachment_path?: StringNullableFilter<"review"> | string | null
    decision?: EnumReviewDecisionNullableFilter<"review"> | $Enums.ReviewDecision | null
    paper?: XOR<PaperNullableScalarRelationFilter, paperWhereInput> | null
    proposal?: XOR<ProposalNullableScalarRelationFilter, proposalWhereInput> | null
    reviewer?: XOR<ReviewerNullableScalarRelationFilter, reviewerWhereInput> | null
  }, "review_id">

  export type reviewOrderByWithAggregationInput = {
    review_id?: SortOrder
    reviewer_id?: SortOrderInput | SortOrder
    proposal_id?: SortOrderInput | SortOrder
    paper_id?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    reviewed_at?: SortOrder
    attachment_path?: SortOrderInput | SortOrder
    decision?: SortOrderInput | SortOrder
    _count?: reviewCountOrderByAggregateInput
    _avg?: reviewAvgOrderByAggregateInput
    _max?: reviewMaxOrderByAggregateInput
    _min?: reviewMinOrderByAggregateInput
    _sum?: reviewSumOrderByAggregateInput
  }

  export type reviewScalarWhereWithAggregatesInput = {
    AND?: reviewScalarWhereWithAggregatesInput | reviewScalarWhereWithAggregatesInput[]
    OR?: reviewScalarWhereWithAggregatesInput[]
    NOT?: reviewScalarWhereWithAggregatesInput | reviewScalarWhereWithAggregatesInput[]
    review_id?: IntWithAggregatesFilter<"review"> | number
    reviewer_id?: IntNullableWithAggregatesFilter<"review"> | number | null
    proposal_id?: IntNullableWithAggregatesFilter<"review"> | number | null
    paper_id?: IntNullableWithAggregatesFilter<"review"> | number | null
    comments?: StringNullableWithAggregatesFilter<"review"> | string | null
    score?: IntNullableWithAggregatesFilter<"review"> | number | null
    reviewed_at?: DateTimeWithAggregatesFilter<"review"> | Date | string
    attachment_path?: StringNullableWithAggregatesFilter<"review"> | string | null
    decision?: EnumReviewDecisionNullableWithAggregatesFilter<"review"> | $Enums.ReviewDecision | null
  }

  export type reviewerassignmentWhereInput = {
    AND?: reviewerassignmentWhereInput | reviewerassignmentWhereInput[]
    OR?: reviewerassignmentWhereInput[]
    NOT?: reviewerassignmentWhereInput | reviewerassignmentWhereInput[]
    assignment_id?: IntFilter<"reviewerassignment"> | number
    reviewer_id?: IntFilter<"reviewerassignment"> | number
    proposal_id?: IntNullableFilter<"reviewerassignment"> | number | null
    paper_id?: IntNullableFilter<"reviewerassignment"> | number | null
    assigned_date?: DateTimeFilter<"reviewerassignment"> | Date | string
    due_date?: DateTimeFilter<"reviewerassignment"> | Date | string
    status?: EnumAssignmentStatusFilter<"reviewerassignment"> | $Enums.AssignmentStatus
    completed_at?: DateTimeNullableFilter<"reviewerassignment"> | Date | string | null
    started_at?: DateTimeNullableFilter<"reviewerassignment"> | Date | string | null
    paper?: XOR<PaperNullableScalarRelationFilter, paperWhereInput> | null
    proposal?: XOR<ProposalNullableScalarRelationFilter, proposalWhereInput> | null
    reviewer?: XOR<ReviewerScalarRelationFilter, reviewerWhereInput>
  }

  export type reviewerassignmentOrderByWithRelationInput = {
    assignment_id?: SortOrder
    reviewer_id?: SortOrder
    proposal_id?: SortOrderInput | SortOrder
    paper_id?: SortOrderInput | SortOrder
    assigned_date?: SortOrder
    due_date?: SortOrder
    status?: SortOrder
    completed_at?: SortOrderInput | SortOrder
    started_at?: SortOrderInput | SortOrder
    paper?: paperOrderByWithRelationInput
    proposal?: proposalOrderByWithRelationInput
    reviewer?: reviewerOrderByWithRelationInput
  }

  export type reviewerassignmentWhereUniqueInput = Prisma.AtLeast<{
    assignment_id?: number
    AND?: reviewerassignmentWhereInput | reviewerassignmentWhereInput[]
    OR?: reviewerassignmentWhereInput[]
    NOT?: reviewerassignmentWhereInput | reviewerassignmentWhereInput[]
    reviewer_id?: IntFilter<"reviewerassignment"> | number
    proposal_id?: IntNullableFilter<"reviewerassignment"> | number | null
    paper_id?: IntNullableFilter<"reviewerassignment"> | number | null
    assigned_date?: DateTimeFilter<"reviewerassignment"> | Date | string
    due_date?: DateTimeFilter<"reviewerassignment"> | Date | string
    status?: EnumAssignmentStatusFilter<"reviewerassignment"> | $Enums.AssignmentStatus
    completed_at?: DateTimeNullableFilter<"reviewerassignment"> | Date | string | null
    started_at?: DateTimeNullableFilter<"reviewerassignment"> | Date | string | null
    paper?: XOR<PaperNullableScalarRelationFilter, paperWhereInput> | null
    proposal?: XOR<ProposalNullableScalarRelationFilter, proposalWhereInput> | null
    reviewer?: XOR<ReviewerScalarRelationFilter, reviewerWhereInput>
  }, "assignment_id">

  export type reviewerassignmentOrderByWithAggregationInput = {
    assignment_id?: SortOrder
    reviewer_id?: SortOrder
    proposal_id?: SortOrderInput | SortOrder
    paper_id?: SortOrderInput | SortOrder
    assigned_date?: SortOrder
    due_date?: SortOrder
    status?: SortOrder
    completed_at?: SortOrderInput | SortOrder
    started_at?: SortOrderInput | SortOrder
    _count?: reviewerassignmentCountOrderByAggregateInput
    _avg?: reviewerassignmentAvgOrderByAggregateInput
    _max?: reviewerassignmentMaxOrderByAggregateInput
    _min?: reviewerassignmentMinOrderByAggregateInput
    _sum?: reviewerassignmentSumOrderByAggregateInput
  }

  export type reviewerassignmentScalarWhereWithAggregatesInput = {
    AND?: reviewerassignmentScalarWhereWithAggregatesInput | reviewerassignmentScalarWhereWithAggregatesInput[]
    OR?: reviewerassignmentScalarWhereWithAggregatesInput[]
    NOT?: reviewerassignmentScalarWhereWithAggregatesInput | reviewerassignmentScalarWhereWithAggregatesInput[]
    assignment_id?: IntWithAggregatesFilter<"reviewerassignment"> | number
    reviewer_id?: IntWithAggregatesFilter<"reviewerassignment"> | number
    proposal_id?: IntNullableWithAggregatesFilter<"reviewerassignment"> | number | null
    paper_id?: IntNullableWithAggregatesFilter<"reviewerassignment"> | number | null
    assigned_date?: DateTimeWithAggregatesFilter<"reviewerassignment"> | Date | string
    due_date?: DateTimeWithAggregatesFilter<"reviewerassignment"> | Date | string
    status?: EnumAssignmentStatusWithAggregatesFilter<"reviewerassignment"> | $Enums.AssignmentStatus
    completed_at?: DateTimeNullableWithAggregatesFilter<"reviewerassignment"> | Date | string | null
    started_at?: DateTimeNullableWithAggregatesFilter<"reviewerassignment"> | Date | string | null
  }

  export type userdomainWhereInput = {
    AND?: userdomainWhereInput | userdomainWhereInput[]
    OR?: userdomainWhereInput[]
    NOT?: userdomainWhereInput | userdomainWhereInput[]
    user_id?: IntFilter<"userdomain"> | number
    domain_id?: IntFilter<"userdomain"> | number
    domain?: XOR<DomainScalarRelationFilter, domainWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type userdomainOrderByWithRelationInput = {
    user_id?: SortOrder
    domain_id?: SortOrder
    domain?: domainOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type userdomainWhereUniqueInput = Prisma.AtLeast<{
    user_id_domain_id?: userdomainUser_idDomain_idCompoundUniqueInput
    AND?: userdomainWhereInput | userdomainWhereInput[]
    OR?: userdomainWhereInput[]
    NOT?: userdomainWhereInput | userdomainWhereInput[]
    user_id?: IntFilter<"userdomain"> | number
    domain_id?: IntFilter<"userdomain"> | number
    domain?: XOR<DomainScalarRelationFilter, domainWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "user_id_domain_id">

  export type userdomainOrderByWithAggregationInput = {
    user_id?: SortOrder
    domain_id?: SortOrder
    _count?: userdomainCountOrderByAggregateInput
    _avg?: userdomainAvgOrderByAggregateInput
    _max?: userdomainMaxOrderByAggregateInput
    _min?: userdomainMinOrderByAggregateInput
    _sum?: userdomainSumOrderByAggregateInput
  }

  export type userdomainScalarWhereWithAggregatesInput = {
    AND?: userdomainScalarWhereWithAggregatesInput | userdomainScalarWhereWithAggregatesInput[]
    OR?: userdomainScalarWhereWithAggregatesInput[]
    NOT?: userdomainScalarWhereWithAggregatesInput | userdomainScalarWhereWithAggregatesInput[]
    user_id?: IntWithAggregatesFilter<"userdomain"> | number
    domain_id?: IntWithAggregatesFilter<"userdomain"> | number
  }

  export type userCreateInput = {
    name?: string | null
    email?: string | null
    password?: string | null
    profile_image?: string | null
    role?: $Enums.Role | null
    isVerified?: boolean
    isMainAdmin?: boolean
    verifyToken?: string | null
    created_at?: Date | string
    admin?: adminCreateNestedManyWithoutUserInput
    generaluser?: generaluserCreateNestedManyWithoutUserInput
    student?: studentCreateNestedManyWithoutUserInput
    teacher?: teacherCreateNestedManyWithoutUserInput
    team?: teamCreateNestedManyWithoutCreated_by_userInput
    teamcomment?: teamcommentCreateNestedManyWithoutUserInput
    teammember?: teammemberCreateNestedManyWithoutUserInput
    userdomain?: userdomainCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateInput = {
    user_id?: number
    name?: string | null
    email?: string | null
    password?: string | null
    profile_image?: string | null
    role?: $Enums.Role | null
    isVerified?: boolean
    isMainAdmin?: boolean
    verifyToken?: string | null
    created_at?: Date | string
    admin?: adminUncheckedCreateNestedManyWithoutUserInput
    generaluser?: generaluserUncheckedCreateNestedManyWithoutUserInput
    student?: studentUncheckedCreateNestedManyWithoutUserInput
    teacher?: teacherUncheckedCreateNestedManyWithoutUserInput
    team?: teamUncheckedCreateNestedManyWithoutCreated_by_userInput
    teamcomment?: teamcommentUncheckedCreateNestedManyWithoutUserInput
    teammember?: teammemberUncheckedCreateNestedManyWithoutUserInput
    userdomain?: userdomainUncheckedCreateNestedManyWithoutUserInput
  }

  export type userUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isMainAdmin?: BoolFieldUpdateOperationsInput | boolean
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: adminUpdateManyWithoutUserNestedInput
    generaluser?: generaluserUpdateManyWithoutUserNestedInput
    student?: studentUpdateManyWithoutUserNestedInput
    teacher?: teacherUpdateManyWithoutUserNestedInput
    team?: teamUpdateManyWithoutCreated_by_userNestedInput
    teamcomment?: teamcommentUpdateManyWithoutUserNestedInput
    teammember?: teammemberUpdateManyWithoutUserNestedInput
    userdomain?: userdomainUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isMainAdmin?: BoolFieldUpdateOperationsInput | boolean
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: adminUncheckedUpdateManyWithoutUserNestedInput
    generaluser?: generaluserUncheckedUpdateManyWithoutUserNestedInput
    student?: studentUncheckedUpdateManyWithoutUserNestedInput
    teacher?: teacherUncheckedUpdateManyWithoutUserNestedInput
    team?: teamUncheckedUpdateManyWithoutCreated_by_userNestedInput
    teamcomment?: teamcommentUncheckedUpdateManyWithoutUserNestedInput
    teammember?: teammemberUncheckedUpdateManyWithoutUserNestedInput
    userdomain?: userdomainUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateManyInput = {
    user_id?: number
    name?: string | null
    email?: string | null
    password?: string | null
    profile_image?: string | null
    role?: $Enums.Role | null
    isVerified?: boolean
    isMainAdmin?: boolean
    verifyToken?: string | null
    created_at?: Date | string
  }

  export type userUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isMainAdmin?: BoolFieldUpdateOperationsInput | boolean
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userUncheckedUpdateManyInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isMainAdmin?: BoolFieldUpdateOperationsInput | boolean
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type adminCreateInput = {
    user?: userCreateNestedOneWithoutAdminInput
  }

  export type adminUncheckedCreateInput = {
    admin_id?: number
    user_id?: number | null
  }

  export type adminUpdateInput = {
    user?: userUpdateOneWithoutAdminNestedInput
  }

  export type adminUncheckedUpdateInput = {
    admin_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type adminCreateManyInput = {
    admin_id?: number
    user_id?: number | null
  }

  export type adminUpdateManyMutationInput = {

  }

  export type adminUncheckedUpdateManyInput = {
    admin_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type departmentCreateInput = {
    department_name?: string | null
    departmentdomain?: departmentdomainCreateNestedManyWithoutDepartmentInput
    students?: studentCreateNestedManyWithoutDepartmentInput
    teachers?: teacherCreateNestedManyWithoutDepartmentInput
  }

  export type departmentUncheckedCreateInput = {
    department_id?: number
    department_name?: string | null
    departmentdomain?: departmentdomainUncheckedCreateNestedManyWithoutDepartmentInput
    students?: studentUncheckedCreateNestedManyWithoutDepartmentInput
    teachers?: teacherUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type departmentUpdateInput = {
    department_name?: NullableStringFieldUpdateOperationsInput | string | null
    departmentdomain?: departmentdomainUpdateManyWithoutDepartmentNestedInput
    students?: studentUpdateManyWithoutDepartmentNestedInput
    teachers?: teacherUpdateManyWithoutDepartmentNestedInput
  }

  export type departmentUncheckedUpdateInput = {
    department_id?: IntFieldUpdateOperationsInput | number
    department_name?: NullableStringFieldUpdateOperationsInput | string | null
    departmentdomain?: departmentdomainUncheckedUpdateManyWithoutDepartmentNestedInput
    students?: studentUncheckedUpdateManyWithoutDepartmentNestedInput
    teachers?: teacherUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type departmentCreateManyInput = {
    department_id?: number
    department_name?: string | null
  }

  export type departmentUpdateManyMutationInput = {
    department_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type departmentUncheckedUpdateManyInput = {
    department_id?: IntFieldUpdateOperationsInput | number
    department_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type domainCreateInput = {
    domain_name?: string | null
    departmentdomain?: departmentdomainCreateNestedManyWithoutDomainInput
    team?: teamCreateNestedManyWithoutDomainInput
    userdomain?: userdomainCreateNestedManyWithoutDomainInput
  }

  export type domainUncheckedCreateInput = {
    domain_id?: number
    domain_name?: string | null
    departmentdomain?: departmentdomainUncheckedCreateNestedManyWithoutDomainInput
    team?: teamUncheckedCreateNestedManyWithoutDomainInput
    userdomain?: userdomainUncheckedCreateNestedManyWithoutDomainInput
  }

  export type domainUpdateInput = {
    domain_name?: NullableStringFieldUpdateOperationsInput | string | null
    departmentdomain?: departmentdomainUpdateManyWithoutDomainNestedInput
    team?: teamUpdateManyWithoutDomainNestedInput
    userdomain?: userdomainUpdateManyWithoutDomainNestedInput
  }

  export type domainUncheckedUpdateInput = {
    domain_id?: IntFieldUpdateOperationsInput | number
    domain_name?: NullableStringFieldUpdateOperationsInput | string | null
    departmentdomain?: departmentdomainUncheckedUpdateManyWithoutDomainNestedInput
    team?: teamUncheckedUpdateManyWithoutDomainNestedInput
    userdomain?: userdomainUncheckedUpdateManyWithoutDomainNestedInput
  }

  export type domainCreateManyInput = {
    domain_id?: number
    domain_name?: string | null
  }

  export type domainUpdateManyMutationInput = {
    domain_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type domainUncheckedUpdateManyInput = {
    domain_id?: IntFieldUpdateOperationsInput | number
    domain_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type departmentdomainCreateInput = {
    department: departmentCreateNestedOneWithoutDepartmentdomainInput
    domain: domainCreateNestedOneWithoutDepartmentdomainInput
  }

  export type departmentdomainUncheckedCreateInput = {
    department_id: number
    domain_id: number
  }

  export type departmentdomainUpdateInput = {
    department?: departmentUpdateOneRequiredWithoutDepartmentdomainNestedInput
    domain?: domainUpdateOneRequiredWithoutDepartmentdomainNestedInput
  }

  export type departmentdomainUncheckedUpdateInput = {
    department_id?: IntFieldUpdateOperationsInput | number
    domain_id?: IntFieldUpdateOperationsInput | number
  }

  export type departmentdomainCreateManyInput = {
    department_id: number
    domain_id: number
  }

  export type departmentdomainUpdateManyMutationInput = {

  }

  export type departmentdomainUncheckedUpdateManyInput = {
    department_id?: IntFieldUpdateOperationsInput | number
    domain_id?: IntFieldUpdateOperationsInput | number
  }

  export type generaluserCreateInput = {
    user?: userCreateNestedOneWithoutGeneraluserInput
  }

  export type generaluserUncheckedCreateInput = {
    generaluser_id?: number
    user_id?: number | null
  }

  export type generaluserUpdateInput = {
    user?: userUpdateOneWithoutGeneraluserNestedInput
  }

  export type generaluserUncheckedUpdateInput = {
    generaluser_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type generaluserCreateManyInput = {
    generaluser_id?: number
    user_id?: number | null
  }

  export type generaluserUpdateManyMutationInput = {

  }

  export type generaluserUncheckedUpdateManyInput = {
    generaluser_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type studentCreateInput = {
    roll_number?: string | null
    department?: departmentCreateNestedOneWithoutStudentsInput
    user?: userCreateNestedOneWithoutStudentInput
    teamapplication?: teamapplicationCreateNestedManyWithoutStudentInput
  }

  export type studentUncheckedCreateInput = {
    student_id?: number
    roll_number?: string | null
    department_id?: number | null
    user_id?: number | null
    teamapplication?: teamapplicationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type studentUpdateInput = {
    roll_number?: NullableStringFieldUpdateOperationsInput | string | null
    department?: departmentUpdateOneWithoutStudentsNestedInput
    user?: userUpdateOneWithoutStudentNestedInput
    teamapplication?: teamapplicationUpdateManyWithoutStudentNestedInput
  }

  export type studentUncheckedUpdateInput = {
    student_id?: IntFieldUpdateOperationsInput | number
    roll_number?: NullableStringFieldUpdateOperationsInput | string | null
    department_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    teamapplication?: teamapplicationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type studentCreateManyInput = {
    student_id?: number
    roll_number?: string | null
    department_id?: number | null
    user_id?: number | null
  }

  export type studentUpdateManyMutationInput = {
    roll_number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type studentUncheckedUpdateManyInput = {
    student_id?: IntFieldUpdateOperationsInput | number
    roll_number?: NullableStringFieldUpdateOperationsInput | string | null
    department_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type teacherCreateInput = {
    designation?: string | null
    isReviewer?: boolean
    paper?: paperCreateNestedManyWithoutTeacherInput
    proposal?: proposalCreateNestedManyWithoutTeacherInput
    reviewer?: reviewerCreateNestedOneWithoutTeacherInput
    department?: departmentCreateNestedOneWithoutTeachersInput
    user?: userCreateNestedOneWithoutTeacherInput
  }

  export type teacherUncheckedCreateInput = {
    teacher_id?: number
    designation?: string | null
    department_id?: number | null
    user_id?: number | null
    isReviewer?: boolean
    paper?: paperUncheckedCreateNestedManyWithoutTeacherInput
    proposal?: proposalUncheckedCreateNestedManyWithoutTeacherInput
    reviewer?: reviewerUncheckedCreateNestedOneWithoutTeacherInput
  }

  export type teacherUpdateInput = {
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    isReviewer?: BoolFieldUpdateOperationsInput | boolean
    paper?: paperUpdateManyWithoutTeacherNestedInput
    proposal?: proposalUpdateManyWithoutTeacherNestedInput
    reviewer?: reviewerUpdateOneWithoutTeacherNestedInput
    department?: departmentUpdateOneWithoutTeachersNestedInput
    user?: userUpdateOneWithoutTeacherNestedInput
  }

  export type teacherUncheckedUpdateInput = {
    teacher_id?: IntFieldUpdateOperationsInput | number
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    department_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    isReviewer?: BoolFieldUpdateOperationsInput | boolean
    paper?: paperUncheckedUpdateManyWithoutTeacherNestedInput
    proposal?: proposalUncheckedUpdateManyWithoutTeacherNestedInput
    reviewer?: reviewerUncheckedUpdateOneWithoutTeacherNestedInput
  }

  export type teacherCreateManyInput = {
    teacher_id?: number
    designation?: string | null
    department_id?: number | null
    user_id?: number | null
    isReviewer?: boolean
  }

  export type teacherUpdateManyMutationInput = {
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    isReviewer?: BoolFieldUpdateOperationsInput | boolean
  }

  export type teacherUncheckedUpdateManyInput = {
    teacher_id?: IntFieldUpdateOperationsInput | number
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    department_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    isReviewer?: BoolFieldUpdateOperationsInput | boolean
  }

  export type reviewerCreateInput = {
    status?: $Enums.ReviewerStatus | null
    review?: reviewCreateNestedManyWithoutReviewerInput
    teacher?: teacherCreateNestedOneWithoutReviewerInput
    reviewerassignment?: reviewerassignmentCreateNestedManyWithoutReviewerInput
  }

  export type reviewerUncheckedCreateInput = {
    reviewer_id?: number
    teacher_id?: number | null
    status?: $Enums.ReviewerStatus | null
    review?: reviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewerassignment?: reviewerassignmentUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type reviewerUpdateInput = {
    status?: NullableEnumReviewerStatusFieldUpdateOperationsInput | $Enums.ReviewerStatus | null
    review?: reviewUpdateManyWithoutReviewerNestedInput
    teacher?: teacherUpdateOneWithoutReviewerNestedInput
    reviewerassignment?: reviewerassignmentUpdateManyWithoutReviewerNestedInput
  }

  export type reviewerUncheckedUpdateInput = {
    reviewer_id?: IntFieldUpdateOperationsInput | number
    teacher_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumReviewerStatusFieldUpdateOperationsInput | $Enums.ReviewerStatus | null
    review?: reviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewerassignment?: reviewerassignmentUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type reviewerCreateManyInput = {
    reviewer_id?: number
    teacher_id?: number | null
    status?: $Enums.ReviewerStatus | null
  }

  export type reviewerUpdateManyMutationInput = {
    status?: NullableEnumReviewerStatusFieldUpdateOperationsInput | $Enums.ReviewerStatus | null
  }

  export type reviewerUncheckedUpdateManyInput = {
    reviewer_id?: IntFieldUpdateOperationsInput | number
    teacher_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumReviewerStatusFieldUpdateOperationsInput | $Enums.ReviewerStatus | null
  }

  export type teamCreateInput = {
    team_name?: string | null
    team_description?: string | null
    status?: $Enums.TeamStatus | null
    visibility?: $Enums.TeamVisibility | null
    max_members?: number | null
    isHiring?: boolean | null
    created_at?: Date | string
    paper?: paperCreateNestedManyWithoutTeamInput
    proposal?: proposalCreateNestedManyWithoutTeamInput
    created_by_user?: userCreateNestedOneWithoutTeamInput
    domain?: domainCreateNestedOneWithoutTeamInput
    teamapplication?: teamapplicationCreateNestedManyWithoutTeamInput
    teamcomment?: teamcommentCreateNestedManyWithoutTeamInput
    teammember?: teammemberCreateNestedManyWithoutTeamInput
  }

  export type teamUncheckedCreateInput = {
    team_id?: number
    team_name?: string | null
    team_description?: string | null
    domain_id?: number | null
    status?: $Enums.TeamStatus | null
    visibility?: $Enums.TeamVisibility | null
    max_members?: number | null
    isHiring?: boolean | null
    created_at?: Date | string
    created_by_user_id?: number | null
    paper?: paperUncheckedCreateNestedManyWithoutTeamInput
    proposal?: proposalUncheckedCreateNestedManyWithoutTeamInput
    teamapplication?: teamapplicationUncheckedCreateNestedManyWithoutTeamInput
    teamcomment?: teamcommentUncheckedCreateNestedManyWithoutTeamInput
    teammember?: teammemberUncheckedCreateNestedManyWithoutTeamInput
  }

  export type teamUpdateInput = {
    team_name?: NullableStringFieldUpdateOperationsInput | string | null
    team_description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumTeamStatusFieldUpdateOperationsInput | $Enums.TeamStatus | null
    visibility?: NullableEnumTeamVisibilityFieldUpdateOperationsInput | $Enums.TeamVisibility | null
    max_members?: NullableIntFieldUpdateOperationsInput | number | null
    isHiring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    paper?: paperUpdateManyWithoutTeamNestedInput
    proposal?: proposalUpdateManyWithoutTeamNestedInput
    created_by_user?: userUpdateOneWithoutTeamNestedInput
    domain?: domainUpdateOneWithoutTeamNestedInput
    teamapplication?: teamapplicationUpdateManyWithoutTeamNestedInput
    teamcomment?: teamcommentUpdateManyWithoutTeamNestedInput
    teammember?: teammemberUpdateManyWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateInput = {
    team_id?: IntFieldUpdateOperationsInput | number
    team_name?: NullableStringFieldUpdateOperationsInput | string | null
    team_description?: NullableStringFieldUpdateOperationsInput | string | null
    domain_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumTeamStatusFieldUpdateOperationsInput | $Enums.TeamStatus | null
    visibility?: NullableEnumTeamVisibilityFieldUpdateOperationsInput | $Enums.TeamVisibility | null
    max_members?: NullableIntFieldUpdateOperationsInput | number | null
    isHiring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    paper?: paperUncheckedUpdateManyWithoutTeamNestedInput
    proposal?: proposalUncheckedUpdateManyWithoutTeamNestedInput
    teamapplication?: teamapplicationUncheckedUpdateManyWithoutTeamNestedInput
    teamcomment?: teamcommentUncheckedUpdateManyWithoutTeamNestedInput
    teammember?: teammemberUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type teamCreateManyInput = {
    team_id?: number
    team_name?: string | null
    team_description?: string | null
    domain_id?: number | null
    status?: $Enums.TeamStatus | null
    visibility?: $Enums.TeamVisibility | null
    max_members?: number | null
    isHiring?: boolean | null
    created_at?: Date | string
    created_by_user_id?: number | null
  }

  export type teamUpdateManyMutationInput = {
    team_name?: NullableStringFieldUpdateOperationsInput | string | null
    team_description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumTeamStatusFieldUpdateOperationsInput | $Enums.TeamStatus | null
    visibility?: NullableEnumTeamVisibilityFieldUpdateOperationsInput | $Enums.TeamVisibility | null
    max_members?: NullableIntFieldUpdateOperationsInput | number | null
    isHiring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type teamUncheckedUpdateManyInput = {
    team_id?: IntFieldUpdateOperationsInput | number
    team_name?: NullableStringFieldUpdateOperationsInput | string | null
    team_description?: NullableStringFieldUpdateOperationsInput | string | null
    domain_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumTeamStatusFieldUpdateOperationsInput | $Enums.TeamStatus | null
    visibility?: NullableEnumTeamVisibilityFieldUpdateOperationsInput | $Enums.TeamVisibility | null
    max_members?: NullableIntFieldUpdateOperationsInput | number | null
    isHiring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by_user_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type teammemberCreateInput = {
    role_in_team?: $Enums.TeamRole | null
    team: teamCreateNestedOneWithoutTeammemberInput
    user: userCreateNestedOneWithoutTeammemberInput
  }

  export type teammemberUncheckedCreateInput = {
    team_id: number
    user_id: number
    role_in_team?: $Enums.TeamRole | null
  }

  export type teammemberUpdateInput = {
    role_in_team?: NullableEnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole | null
    team?: teamUpdateOneRequiredWithoutTeammemberNestedInput
    user?: userUpdateOneRequiredWithoutTeammemberNestedInput
  }

  export type teammemberUncheckedUpdateInput = {
    team_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    role_in_team?: NullableEnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole | null
  }

  export type teammemberCreateManyInput = {
    team_id: number
    user_id: number
    role_in_team?: $Enums.TeamRole | null
  }

  export type teammemberUpdateManyMutationInput = {
    role_in_team?: NullableEnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole | null
  }

  export type teammemberUncheckedUpdateManyInput = {
    team_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    role_in_team?: NullableEnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole | null
  }

  export type teamapplicationCreateInput = {
    status?: $Enums.ApplicationStatus
    applied_at?: Date | string
    student: studentCreateNestedOneWithoutTeamapplicationInput
    team: teamCreateNestedOneWithoutTeamapplicationInput
  }

  export type teamapplicationUncheckedCreateInput = {
    application_id?: number
    team_id: number
    student_id: number
    status?: $Enums.ApplicationStatus
    applied_at?: Date | string
  }

  export type teamapplicationUpdateInput = {
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    applied_at?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: studentUpdateOneRequiredWithoutTeamapplicationNestedInput
    team?: teamUpdateOneRequiredWithoutTeamapplicationNestedInput
  }

  export type teamapplicationUncheckedUpdateInput = {
    application_id?: IntFieldUpdateOperationsInput | number
    team_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    applied_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type teamapplicationCreateManyInput = {
    application_id?: number
    team_id: number
    student_id: number
    status?: $Enums.ApplicationStatus
    applied_at?: Date | string
  }

  export type teamapplicationUpdateManyMutationInput = {
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    applied_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type teamapplicationUncheckedUpdateManyInput = {
    application_id?: IntFieldUpdateOperationsInput | number
    team_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    applied_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type teamcommentCreateInput = {
    comment: string
    created_at?: Date | string
    team: teamCreateNestedOneWithoutTeamcommentInput
    user: userCreateNestedOneWithoutTeamcommentInput
  }

  export type teamcommentUncheckedCreateInput = {
    comment_id?: number
    team_id: number
    user_id: number
    comment: string
    created_at?: Date | string
  }

  export type teamcommentUpdateInput = {
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: teamUpdateOneRequiredWithoutTeamcommentNestedInput
    user?: userUpdateOneRequiredWithoutTeamcommentNestedInput
  }

  export type teamcommentUncheckedUpdateInput = {
    comment_id?: IntFieldUpdateOperationsInput | number
    team_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type teamcommentCreateManyInput = {
    comment_id?: number
    team_id: number
    user_id: number
    comment: string
    created_at?: Date | string
  }

  export type teamcommentUpdateManyMutationInput = {
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type teamcommentUncheckedUpdateManyInput = {
    comment_id?: IntFieldUpdateOperationsInput | number
    team_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paperCreateInput = {
    title?: string | null
    abstract?: string | null
    status?: $Enums.PaperStatus | null
    pdf_path?: string | null
    file_size?: number | null
    created_at?: Date | string
    aggregated_decided_at?: Date | string | null
    aggregated_decision?: $Enums.ReviewDecision | null
    teacher?: teacherCreateNestedOneWithoutPaperInput
    team?: teamCreateNestedOneWithoutPaperInput
    review?: reviewCreateNestedManyWithoutPaperInput
    reviewerassignment?: reviewerassignmentCreateNestedManyWithoutPaperInput
  }

  export type paperUncheckedCreateInput = {
    paper_id?: number
    title?: string | null
    abstract?: string | null
    status?: $Enums.PaperStatus | null
    team_id?: number | null
    submitted_by?: number | null
    pdf_path?: string | null
    file_size?: number | null
    created_at?: Date | string
    aggregated_decided_at?: Date | string | null
    aggregated_decision?: $Enums.ReviewDecision | null
    review?: reviewUncheckedCreateNestedManyWithoutPaperInput
    reviewerassignment?: reviewerassignmentUncheckedCreateNestedManyWithoutPaperInput
  }

  export type paperUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumPaperStatusFieldUpdateOperationsInput | $Enums.PaperStatus | null
    pdf_path?: NullableStringFieldUpdateOperationsInput | string | null
    file_size?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    aggregated_decided_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aggregated_decision?: NullableEnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision | null
    teacher?: teacherUpdateOneWithoutPaperNestedInput
    team?: teamUpdateOneWithoutPaperNestedInput
    review?: reviewUpdateManyWithoutPaperNestedInput
    reviewerassignment?: reviewerassignmentUpdateManyWithoutPaperNestedInput
  }

  export type paperUncheckedUpdateInput = {
    paper_id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumPaperStatusFieldUpdateOperationsInput | $Enums.PaperStatus | null
    team_id?: NullableIntFieldUpdateOperationsInput | number | null
    submitted_by?: NullableIntFieldUpdateOperationsInput | number | null
    pdf_path?: NullableStringFieldUpdateOperationsInput | string | null
    file_size?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    aggregated_decided_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aggregated_decision?: NullableEnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision | null
    review?: reviewUncheckedUpdateManyWithoutPaperNestedInput
    reviewerassignment?: reviewerassignmentUncheckedUpdateManyWithoutPaperNestedInput
  }

  export type paperCreateManyInput = {
    paper_id?: number
    title?: string | null
    abstract?: string | null
    status?: $Enums.PaperStatus | null
    team_id?: number | null
    submitted_by?: number | null
    pdf_path?: string | null
    file_size?: number | null
    created_at?: Date | string
    aggregated_decided_at?: Date | string | null
    aggregated_decision?: $Enums.ReviewDecision | null
  }

  export type paperUpdateManyMutationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumPaperStatusFieldUpdateOperationsInput | $Enums.PaperStatus | null
    pdf_path?: NullableStringFieldUpdateOperationsInput | string | null
    file_size?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    aggregated_decided_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aggregated_decision?: NullableEnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision | null
  }

  export type paperUncheckedUpdateManyInput = {
    paper_id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumPaperStatusFieldUpdateOperationsInput | $Enums.PaperStatus | null
    team_id?: NullableIntFieldUpdateOperationsInput | number | null
    submitted_by?: NullableIntFieldUpdateOperationsInput | number | null
    pdf_path?: NullableStringFieldUpdateOperationsInput | string | null
    file_size?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    aggregated_decided_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aggregated_decision?: NullableEnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision | null
  }

  export type proposalCreateInput = {
    title?: string | null
    abstract?: string | null
    status?: $Enums.PaperStatus | null
    pdf_path?: string | null
    file_size?: number | null
    created_at?: Date | string
    aggregated_decided_at?: Date | string | null
    aggregated_decision?: $Enums.ReviewDecision | null
    teacher?: teacherCreateNestedOneWithoutProposalInput
    team?: teamCreateNestedOneWithoutProposalInput
    review?: reviewCreateNestedManyWithoutProposalInput
    reviewerassignment?: reviewerassignmentCreateNestedManyWithoutProposalInput
  }

  export type proposalUncheckedCreateInput = {
    proposal_id?: number
    title?: string | null
    abstract?: string | null
    status?: $Enums.PaperStatus | null
    team_id?: number | null
    submitted_by?: number | null
    pdf_path?: string | null
    file_size?: number | null
    created_at?: Date | string
    aggregated_decided_at?: Date | string | null
    aggregated_decision?: $Enums.ReviewDecision | null
    review?: reviewUncheckedCreateNestedManyWithoutProposalInput
    reviewerassignment?: reviewerassignmentUncheckedCreateNestedManyWithoutProposalInput
  }

  export type proposalUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumPaperStatusFieldUpdateOperationsInput | $Enums.PaperStatus | null
    pdf_path?: NullableStringFieldUpdateOperationsInput | string | null
    file_size?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    aggregated_decided_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aggregated_decision?: NullableEnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision | null
    teacher?: teacherUpdateOneWithoutProposalNestedInput
    team?: teamUpdateOneWithoutProposalNestedInput
    review?: reviewUpdateManyWithoutProposalNestedInput
    reviewerassignment?: reviewerassignmentUpdateManyWithoutProposalNestedInput
  }

  export type proposalUncheckedUpdateInput = {
    proposal_id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumPaperStatusFieldUpdateOperationsInput | $Enums.PaperStatus | null
    team_id?: NullableIntFieldUpdateOperationsInput | number | null
    submitted_by?: NullableIntFieldUpdateOperationsInput | number | null
    pdf_path?: NullableStringFieldUpdateOperationsInput | string | null
    file_size?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    aggregated_decided_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aggregated_decision?: NullableEnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision | null
    review?: reviewUncheckedUpdateManyWithoutProposalNestedInput
    reviewerassignment?: reviewerassignmentUncheckedUpdateManyWithoutProposalNestedInput
  }

  export type proposalCreateManyInput = {
    proposal_id?: number
    title?: string | null
    abstract?: string | null
    status?: $Enums.PaperStatus | null
    team_id?: number | null
    submitted_by?: number | null
    pdf_path?: string | null
    file_size?: number | null
    created_at?: Date | string
    aggregated_decided_at?: Date | string | null
    aggregated_decision?: $Enums.ReviewDecision | null
  }

  export type proposalUpdateManyMutationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumPaperStatusFieldUpdateOperationsInput | $Enums.PaperStatus | null
    pdf_path?: NullableStringFieldUpdateOperationsInput | string | null
    file_size?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    aggregated_decided_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aggregated_decision?: NullableEnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision | null
  }

  export type proposalUncheckedUpdateManyInput = {
    proposal_id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumPaperStatusFieldUpdateOperationsInput | $Enums.PaperStatus | null
    team_id?: NullableIntFieldUpdateOperationsInput | number | null
    submitted_by?: NullableIntFieldUpdateOperationsInput | number | null
    pdf_path?: NullableStringFieldUpdateOperationsInput | string | null
    file_size?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    aggregated_decided_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aggregated_decision?: NullableEnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision | null
  }

  export type reviewCreateInput = {
    comments?: string | null
    score?: number | null
    reviewed_at?: Date | string
    attachment_path?: string | null
    decision?: $Enums.ReviewDecision | null
    paper?: paperCreateNestedOneWithoutReviewInput
    proposal?: proposalCreateNestedOneWithoutReviewInput
    reviewer?: reviewerCreateNestedOneWithoutReviewInput
  }

  export type reviewUncheckedCreateInput = {
    review_id?: number
    reviewer_id?: number | null
    proposal_id?: number | null
    paper_id?: number | null
    comments?: string | null
    score?: number | null
    reviewed_at?: Date | string
    attachment_path?: string | null
    decision?: $Enums.ReviewDecision | null
  }

  export type reviewUpdateInput = {
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    reviewed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    attachment_path?: NullableStringFieldUpdateOperationsInput | string | null
    decision?: NullableEnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision | null
    paper?: paperUpdateOneWithoutReviewNestedInput
    proposal?: proposalUpdateOneWithoutReviewNestedInput
    reviewer?: reviewerUpdateOneWithoutReviewNestedInput
  }

  export type reviewUncheckedUpdateInput = {
    review_id?: IntFieldUpdateOperationsInput | number
    reviewer_id?: NullableIntFieldUpdateOperationsInput | number | null
    proposal_id?: NullableIntFieldUpdateOperationsInput | number | null
    paper_id?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    reviewed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    attachment_path?: NullableStringFieldUpdateOperationsInput | string | null
    decision?: NullableEnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision | null
  }

  export type reviewCreateManyInput = {
    review_id?: number
    reviewer_id?: number | null
    proposal_id?: number | null
    paper_id?: number | null
    comments?: string | null
    score?: number | null
    reviewed_at?: Date | string
    attachment_path?: string | null
    decision?: $Enums.ReviewDecision | null
  }

  export type reviewUpdateManyMutationInput = {
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    reviewed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    attachment_path?: NullableStringFieldUpdateOperationsInput | string | null
    decision?: NullableEnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision | null
  }

  export type reviewUncheckedUpdateManyInput = {
    review_id?: IntFieldUpdateOperationsInput | number
    reviewer_id?: NullableIntFieldUpdateOperationsInput | number | null
    proposal_id?: NullableIntFieldUpdateOperationsInput | number | null
    paper_id?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    reviewed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    attachment_path?: NullableStringFieldUpdateOperationsInput | string | null
    decision?: NullableEnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision | null
  }

  export type reviewerassignmentCreateInput = {
    assigned_date?: Date | string
    due_date: Date | string
    status?: $Enums.AssignmentStatus
    completed_at?: Date | string | null
    started_at?: Date | string | null
    paper?: paperCreateNestedOneWithoutReviewerassignmentInput
    proposal?: proposalCreateNestedOneWithoutReviewerassignmentInput
    reviewer: reviewerCreateNestedOneWithoutReviewerassignmentInput
  }

  export type reviewerassignmentUncheckedCreateInput = {
    assignment_id?: number
    reviewer_id: number
    proposal_id?: number | null
    paper_id?: number | null
    assigned_date?: Date | string
    due_date: Date | string
    status?: $Enums.AssignmentStatus
    completed_at?: Date | string | null
    started_at?: Date | string | null
  }

  export type reviewerassignmentUpdateInput = {
    assigned_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paper?: paperUpdateOneWithoutReviewerassignmentNestedInput
    proposal?: proposalUpdateOneWithoutReviewerassignmentNestedInput
    reviewer?: reviewerUpdateOneRequiredWithoutReviewerassignmentNestedInput
  }

  export type reviewerassignmentUncheckedUpdateInput = {
    assignment_id?: IntFieldUpdateOperationsInput | number
    reviewer_id?: IntFieldUpdateOperationsInput | number
    proposal_id?: NullableIntFieldUpdateOperationsInput | number | null
    paper_id?: NullableIntFieldUpdateOperationsInput | number | null
    assigned_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reviewerassignmentCreateManyInput = {
    assignment_id?: number
    reviewer_id: number
    proposal_id?: number | null
    paper_id?: number | null
    assigned_date?: Date | string
    due_date: Date | string
    status?: $Enums.AssignmentStatus
    completed_at?: Date | string | null
    started_at?: Date | string | null
  }

  export type reviewerassignmentUpdateManyMutationInput = {
    assigned_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reviewerassignmentUncheckedUpdateManyInput = {
    assignment_id?: IntFieldUpdateOperationsInput | number
    reviewer_id?: IntFieldUpdateOperationsInput | number
    proposal_id?: NullableIntFieldUpdateOperationsInput | number | null
    paper_id?: NullableIntFieldUpdateOperationsInput | number | null
    assigned_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userdomainCreateInput = {
    domain: domainCreateNestedOneWithoutUserdomainInput
    user: userCreateNestedOneWithoutUserdomainInput
  }

  export type userdomainUncheckedCreateInput = {
    user_id: number
    domain_id: number
  }

  export type userdomainUpdateInput = {
    domain?: domainUpdateOneRequiredWithoutUserdomainNestedInput
    user?: userUpdateOneRequiredWithoutUserdomainNestedInput
  }

  export type userdomainUncheckedUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    domain_id?: IntFieldUpdateOperationsInput | number
  }

  export type userdomainCreateManyInput = {
    user_id: number
    domain_id: number
  }

  export type userdomainUpdateManyMutationInput = {

  }

  export type userdomainUncheckedUpdateManyInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    domain_id?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumRoleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableFilter<$PrismaModel> | $Enums.Role | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AdminListRelationFilter = {
    every?: adminWhereInput
    some?: adminWhereInput
    none?: adminWhereInput
  }

  export type GeneraluserListRelationFilter = {
    every?: generaluserWhereInput
    some?: generaluserWhereInput
    none?: generaluserWhereInput
  }

  export type StudentListRelationFilter = {
    every?: studentWhereInput
    some?: studentWhereInput
    none?: studentWhereInput
  }

  export type TeacherListRelationFilter = {
    every?: teacherWhereInput
    some?: teacherWhereInput
    none?: teacherWhereInput
  }

  export type TeamListRelationFilter = {
    every?: teamWhereInput
    some?: teamWhereInput
    none?: teamWhereInput
  }

  export type TeamcommentListRelationFilter = {
    every?: teamcommentWhereInput
    some?: teamcommentWhereInput
    none?: teamcommentWhereInput
  }

  export type TeammemberListRelationFilter = {
    every?: teammemberWhereInput
    some?: teammemberWhereInput
    none?: teammemberWhereInput
  }

  export type UserdomainListRelationFilter = {
    every?: userdomainWhereInput
    some?: userdomainWhereInput
    none?: userdomainWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type adminOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type generaluserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type studentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type teacherOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type teamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type teamcommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type teammemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userdomainOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userCountOrderByAggregateInput = {
    user_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    profile_image?: SortOrder
    role?: SortOrder
    isVerified?: SortOrder
    isMainAdmin?: SortOrder
    verifyToken?: SortOrder
    created_at?: SortOrder
  }

  export type userAvgOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    user_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    profile_image?: SortOrder
    role?: SortOrder
    isVerified?: SortOrder
    isMainAdmin?: SortOrder
    verifyToken?: SortOrder
    created_at?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    user_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    profile_image?: SortOrder
    role?: SortOrder
    isVerified?: SortOrder
    isMainAdmin?: SortOrder
    verifyToken?: SortOrder
    created_at?: SortOrder
  }

  export type userSumOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumRoleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableWithAggregatesFilter<$PrismaModel> | $Enums.Role | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRoleNullableFilter<$PrismaModel>
    _max?: NestedEnumRoleNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: userWhereInput | null
    isNot?: userWhereInput | null
  }

  export type adminCountOrderByAggregateInput = {
    admin_id?: SortOrder
    user_id?: SortOrder
  }

  export type adminAvgOrderByAggregateInput = {
    admin_id?: SortOrder
    user_id?: SortOrder
  }

  export type adminMaxOrderByAggregateInput = {
    admin_id?: SortOrder
    user_id?: SortOrder
  }

  export type adminMinOrderByAggregateInput = {
    admin_id?: SortOrder
    user_id?: SortOrder
  }

  export type adminSumOrderByAggregateInput = {
    admin_id?: SortOrder
    user_id?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DepartmentdomainListRelationFilter = {
    every?: departmentdomainWhereInput
    some?: departmentdomainWhereInput
    none?: departmentdomainWhereInput
  }

  export type departmentdomainOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type departmentCountOrderByAggregateInput = {
    department_id?: SortOrder
    department_name?: SortOrder
  }

  export type departmentAvgOrderByAggregateInput = {
    department_id?: SortOrder
  }

  export type departmentMaxOrderByAggregateInput = {
    department_id?: SortOrder
    department_name?: SortOrder
  }

  export type departmentMinOrderByAggregateInput = {
    department_id?: SortOrder
    department_name?: SortOrder
  }

  export type departmentSumOrderByAggregateInput = {
    department_id?: SortOrder
  }

  export type domainCountOrderByAggregateInput = {
    domain_id?: SortOrder
    domain_name?: SortOrder
  }

  export type domainAvgOrderByAggregateInput = {
    domain_id?: SortOrder
  }

  export type domainMaxOrderByAggregateInput = {
    domain_id?: SortOrder
    domain_name?: SortOrder
  }

  export type domainMinOrderByAggregateInput = {
    domain_id?: SortOrder
    domain_name?: SortOrder
  }

  export type domainSumOrderByAggregateInput = {
    domain_id?: SortOrder
  }

  export type DepartmentScalarRelationFilter = {
    is?: departmentWhereInput
    isNot?: departmentWhereInput
  }

  export type DomainScalarRelationFilter = {
    is?: domainWhereInput
    isNot?: domainWhereInput
  }

  export type departmentdomainDepartment_idDomain_idCompoundUniqueInput = {
    department_id: number
    domain_id: number
  }

  export type departmentdomainCountOrderByAggregateInput = {
    department_id?: SortOrder
    domain_id?: SortOrder
  }

  export type departmentdomainAvgOrderByAggregateInput = {
    department_id?: SortOrder
    domain_id?: SortOrder
  }

  export type departmentdomainMaxOrderByAggregateInput = {
    department_id?: SortOrder
    domain_id?: SortOrder
  }

  export type departmentdomainMinOrderByAggregateInput = {
    department_id?: SortOrder
    domain_id?: SortOrder
  }

  export type departmentdomainSumOrderByAggregateInput = {
    department_id?: SortOrder
    domain_id?: SortOrder
  }

  export type generaluserCountOrderByAggregateInput = {
    generaluser_id?: SortOrder
    user_id?: SortOrder
  }

  export type generaluserAvgOrderByAggregateInput = {
    generaluser_id?: SortOrder
    user_id?: SortOrder
  }

  export type generaluserMaxOrderByAggregateInput = {
    generaluser_id?: SortOrder
    user_id?: SortOrder
  }

  export type generaluserMinOrderByAggregateInput = {
    generaluser_id?: SortOrder
    user_id?: SortOrder
  }

  export type generaluserSumOrderByAggregateInput = {
    generaluser_id?: SortOrder
    user_id?: SortOrder
  }

  export type DepartmentNullableScalarRelationFilter = {
    is?: departmentWhereInput | null
    isNot?: departmentWhereInput | null
  }

  export type TeamapplicationListRelationFilter = {
    every?: teamapplicationWhereInput
    some?: teamapplicationWhereInput
    none?: teamapplicationWhereInput
  }

  export type teamapplicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type studentCountOrderByAggregateInput = {
    student_id?: SortOrder
    roll_number?: SortOrder
    department_id?: SortOrder
    user_id?: SortOrder
  }

  export type studentAvgOrderByAggregateInput = {
    student_id?: SortOrder
    department_id?: SortOrder
    user_id?: SortOrder
  }

  export type studentMaxOrderByAggregateInput = {
    student_id?: SortOrder
    roll_number?: SortOrder
    department_id?: SortOrder
    user_id?: SortOrder
  }

  export type studentMinOrderByAggregateInput = {
    student_id?: SortOrder
    roll_number?: SortOrder
    department_id?: SortOrder
    user_id?: SortOrder
  }

  export type studentSumOrderByAggregateInput = {
    student_id?: SortOrder
    department_id?: SortOrder
    user_id?: SortOrder
  }

  export type PaperListRelationFilter = {
    every?: paperWhereInput
    some?: paperWhereInput
    none?: paperWhereInput
  }

  export type ProposalListRelationFilter = {
    every?: proposalWhereInput
    some?: proposalWhereInput
    none?: proposalWhereInput
  }

  export type ReviewerNullableScalarRelationFilter = {
    is?: reviewerWhereInput | null
    isNot?: reviewerWhereInput | null
  }

  export type paperOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type proposalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type teacherCountOrderByAggregateInput = {
    teacher_id?: SortOrder
    designation?: SortOrder
    department_id?: SortOrder
    user_id?: SortOrder
    isReviewer?: SortOrder
  }

  export type teacherAvgOrderByAggregateInput = {
    teacher_id?: SortOrder
    department_id?: SortOrder
    user_id?: SortOrder
  }

  export type teacherMaxOrderByAggregateInput = {
    teacher_id?: SortOrder
    designation?: SortOrder
    department_id?: SortOrder
    user_id?: SortOrder
    isReviewer?: SortOrder
  }

  export type teacherMinOrderByAggregateInput = {
    teacher_id?: SortOrder
    designation?: SortOrder
    department_id?: SortOrder
    user_id?: SortOrder
    isReviewer?: SortOrder
  }

  export type teacherSumOrderByAggregateInput = {
    teacher_id?: SortOrder
    department_id?: SortOrder
    user_id?: SortOrder
  }

  export type EnumReviewerStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewerStatus | EnumReviewerStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ReviewerStatus[] | ListEnumReviewerStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ReviewerStatus[] | ListEnumReviewerStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumReviewerStatusNullableFilter<$PrismaModel> | $Enums.ReviewerStatus | null
  }

  export type ReviewListRelationFilter = {
    every?: reviewWhereInput
    some?: reviewWhereInput
    none?: reviewWhereInput
  }

  export type TeacherNullableScalarRelationFilter = {
    is?: teacherWhereInput | null
    isNot?: teacherWhereInput | null
  }

  export type ReviewerassignmentListRelationFilter = {
    every?: reviewerassignmentWhereInput
    some?: reviewerassignmentWhereInput
    none?: reviewerassignmentWhereInput
  }

  export type reviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type reviewerassignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type reviewerCountOrderByAggregateInput = {
    reviewer_id?: SortOrder
    teacher_id?: SortOrder
    status?: SortOrder
  }

  export type reviewerAvgOrderByAggregateInput = {
    reviewer_id?: SortOrder
    teacher_id?: SortOrder
  }

  export type reviewerMaxOrderByAggregateInput = {
    reviewer_id?: SortOrder
    teacher_id?: SortOrder
    status?: SortOrder
  }

  export type reviewerMinOrderByAggregateInput = {
    reviewer_id?: SortOrder
    teacher_id?: SortOrder
    status?: SortOrder
  }

  export type reviewerSumOrderByAggregateInput = {
    reviewer_id?: SortOrder
    teacher_id?: SortOrder
  }

  export type EnumReviewerStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewerStatus | EnumReviewerStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ReviewerStatus[] | ListEnumReviewerStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ReviewerStatus[] | ListEnumReviewerStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumReviewerStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.ReviewerStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumReviewerStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumReviewerStatusNullableFilter<$PrismaModel>
  }

  export type EnumTeamStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamStatus | EnumTeamStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.TeamStatus[] | ListEnumTeamStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TeamStatus[] | ListEnumTeamStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTeamStatusNullableFilter<$PrismaModel> | $Enums.TeamStatus | null
  }

  export type EnumTeamVisibilityNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamVisibility | EnumTeamVisibilityFieldRefInput<$PrismaModel> | null
    in?: $Enums.TeamVisibility[] | ListEnumTeamVisibilityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TeamVisibility[] | ListEnumTeamVisibilityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTeamVisibilityNullableFilter<$PrismaModel> | $Enums.TeamVisibility | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type DomainNullableScalarRelationFilter = {
    is?: domainWhereInput | null
    isNot?: domainWhereInput | null
  }

  export type teamCountOrderByAggregateInput = {
    team_id?: SortOrder
    team_name?: SortOrder
    team_description?: SortOrder
    domain_id?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    max_members?: SortOrder
    isHiring?: SortOrder
    created_at?: SortOrder
    created_by_user_id?: SortOrder
  }

  export type teamAvgOrderByAggregateInput = {
    team_id?: SortOrder
    domain_id?: SortOrder
    max_members?: SortOrder
    created_by_user_id?: SortOrder
  }

  export type teamMaxOrderByAggregateInput = {
    team_id?: SortOrder
    team_name?: SortOrder
    team_description?: SortOrder
    domain_id?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    max_members?: SortOrder
    isHiring?: SortOrder
    created_at?: SortOrder
    created_by_user_id?: SortOrder
  }

  export type teamMinOrderByAggregateInput = {
    team_id?: SortOrder
    team_name?: SortOrder
    team_description?: SortOrder
    domain_id?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    max_members?: SortOrder
    isHiring?: SortOrder
    created_at?: SortOrder
    created_by_user_id?: SortOrder
  }

  export type teamSumOrderByAggregateInput = {
    team_id?: SortOrder
    domain_id?: SortOrder
    max_members?: SortOrder
    created_by_user_id?: SortOrder
  }

  export type EnumTeamStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamStatus | EnumTeamStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.TeamStatus[] | ListEnumTeamStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TeamStatus[] | ListEnumTeamStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTeamStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.TeamStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTeamStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumTeamStatusNullableFilter<$PrismaModel>
  }

  export type EnumTeamVisibilityNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamVisibility | EnumTeamVisibilityFieldRefInput<$PrismaModel> | null
    in?: $Enums.TeamVisibility[] | ListEnumTeamVisibilityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TeamVisibility[] | ListEnumTeamVisibilityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTeamVisibilityNullableWithAggregatesFilter<$PrismaModel> | $Enums.TeamVisibility | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTeamVisibilityNullableFilter<$PrismaModel>
    _max?: NestedEnumTeamVisibilityNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type EnumTeamRoleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamRole | EnumTeamRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTeamRoleNullableFilter<$PrismaModel> | $Enums.TeamRole | null
  }

  export type TeamScalarRelationFilter = {
    is?: teamWhereInput
    isNot?: teamWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: userWhereInput
    isNot?: userWhereInput
  }

  export type teammemberTeam_idUser_idCompoundUniqueInput = {
    team_id: number
    user_id: number
  }

  export type teammemberCountOrderByAggregateInput = {
    team_id?: SortOrder
    user_id?: SortOrder
    role_in_team?: SortOrder
  }

  export type teammemberAvgOrderByAggregateInput = {
    team_id?: SortOrder
    user_id?: SortOrder
  }

  export type teammemberMaxOrderByAggregateInput = {
    team_id?: SortOrder
    user_id?: SortOrder
    role_in_team?: SortOrder
  }

  export type teammemberMinOrderByAggregateInput = {
    team_id?: SortOrder
    user_id?: SortOrder
    role_in_team?: SortOrder
  }

  export type teammemberSumOrderByAggregateInput = {
    team_id?: SortOrder
    user_id?: SortOrder
  }

  export type EnumTeamRoleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamRole | EnumTeamRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTeamRoleNullableWithAggregatesFilter<$PrismaModel> | $Enums.TeamRole | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTeamRoleNullableFilter<$PrismaModel>
    _max?: NestedEnumTeamRoleNullableFilter<$PrismaModel>
  }

  export type EnumApplicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusFilter<$PrismaModel> | $Enums.ApplicationStatus
  }

  export type StudentScalarRelationFilter = {
    is?: studentWhereInput
    isNot?: studentWhereInput
  }

  export type teamapplicationTeam_idStudent_idCompoundUniqueInput = {
    team_id: number
    student_id: number
  }

  export type teamapplicationCountOrderByAggregateInput = {
    application_id?: SortOrder
    team_id?: SortOrder
    student_id?: SortOrder
    status?: SortOrder
    applied_at?: SortOrder
  }

  export type teamapplicationAvgOrderByAggregateInput = {
    application_id?: SortOrder
    team_id?: SortOrder
    student_id?: SortOrder
  }

  export type teamapplicationMaxOrderByAggregateInput = {
    application_id?: SortOrder
    team_id?: SortOrder
    student_id?: SortOrder
    status?: SortOrder
    applied_at?: SortOrder
  }

  export type teamapplicationMinOrderByAggregateInput = {
    application_id?: SortOrder
    team_id?: SortOrder
    student_id?: SortOrder
    status?: SortOrder
    applied_at?: SortOrder
  }

  export type teamapplicationSumOrderByAggregateInput = {
    application_id?: SortOrder
    team_id?: SortOrder
    student_id?: SortOrder
  }

  export type EnumApplicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApplicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApplicationStatusFilter<$PrismaModel>
    _max?: NestedEnumApplicationStatusFilter<$PrismaModel>
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type teamcommentCountOrderByAggregateInput = {
    comment_id?: SortOrder
    team_id?: SortOrder
    user_id?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
  }

  export type teamcommentAvgOrderByAggregateInput = {
    comment_id?: SortOrder
    team_id?: SortOrder
    user_id?: SortOrder
  }

  export type teamcommentMaxOrderByAggregateInput = {
    comment_id?: SortOrder
    team_id?: SortOrder
    user_id?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
  }

  export type teamcommentMinOrderByAggregateInput = {
    comment_id?: SortOrder
    team_id?: SortOrder
    user_id?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
  }

  export type teamcommentSumOrderByAggregateInput = {
    comment_id?: SortOrder
    team_id?: SortOrder
    user_id?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumPaperStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaperStatus | EnumPaperStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaperStatus[] | ListEnumPaperStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaperStatus[] | ListEnumPaperStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaperStatusNullableFilter<$PrismaModel> | $Enums.PaperStatus | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumReviewDecisionNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewDecision | EnumReviewDecisionFieldRefInput<$PrismaModel> | null
    in?: $Enums.ReviewDecision[] | ListEnumReviewDecisionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ReviewDecision[] | ListEnumReviewDecisionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumReviewDecisionNullableFilter<$PrismaModel> | $Enums.ReviewDecision | null
  }

  export type TeamNullableScalarRelationFilter = {
    is?: teamWhereInput | null
    isNot?: teamWhereInput | null
  }

  export type paperCountOrderByAggregateInput = {
    paper_id?: SortOrder
    title?: SortOrder
    abstract?: SortOrder
    status?: SortOrder
    team_id?: SortOrder
    submitted_by?: SortOrder
    pdf_path?: SortOrder
    file_size?: SortOrder
    created_at?: SortOrder
    aggregated_decided_at?: SortOrder
    aggregated_decision?: SortOrder
  }

  export type paperAvgOrderByAggregateInput = {
    paper_id?: SortOrder
    team_id?: SortOrder
    submitted_by?: SortOrder
    file_size?: SortOrder
  }

  export type paperMaxOrderByAggregateInput = {
    paper_id?: SortOrder
    title?: SortOrder
    abstract?: SortOrder
    status?: SortOrder
    team_id?: SortOrder
    submitted_by?: SortOrder
    pdf_path?: SortOrder
    file_size?: SortOrder
    created_at?: SortOrder
    aggregated_decided_at?: SortOrder
    aggregated_decision?: SortOrder
  }

  export type paperMinOrderByAggregateInput = {
    paper_id?: SortOrder
    title?: SortOrder
    abstract?: SortOrder
    status?: SortOrder
    team_id?: SortOrder
    submitted_by?: SortOrder
    pdf_path?: SortOrder
    file_size?: SortOrder
    created_at?: SortOrder
    aggregated_decided_at?: SortOrder
    aggregated_decision?: SortOrder
  }

  export type paperSumOrderByAggregateInput = {
    paper_id?: SortOrder
    team_id?: SortOrder
    submitted_by?: SortOrder
    file_size?: SortOrder
  }

  export type EnumPaperStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaperStatus | EnumPaperStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaperStatus[] | ListEnumPaperStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaperStatus[] | ListEnumPaperStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaperStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaperStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaperStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumPaperStatusNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumReviewDecisionNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewDecision | EnumReviewDecisionFieldRefInput<$PrismaModel> | null
    in?: $Enums.ReviewDecision[] | ListEnumReviewDecisionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ReviewDecision[] | ListEnumReviewDecisionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumReviewDecisionNullableWithAggregatesFilter<$PrismaModel> | $Enums.ReviewDecision | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumReviewDecisionNullableFilter<$PrismaModel>
    _max?: NestedEnumReviewDecisionNullableFilter<$PrismaModel>
  }

  export type proposalCountOrderByAggregateInput = {
    proposal_id?: SortOrder
    title?: SortOrder
    abstract?: SortOrder
    status?: SortOrder
    team_id?: SortOrder
    submitted_by?: SortOrder
    pdf_path?: SortOrder
    file_size?: SortOrder
    created_at?: SortOrder
    aggregated_decided_at?: SortOrder
    aggregated_decision?: SortOrder
  }

  export type proposalAvgOrderByAggregateInput = {
    proposal_id?: SortOrder
    team_id?: SortOrder
    submitted_by?: SortOrder
    file_size?: SortOrder
  }

  export type proposalMaxOrderByAggregateInput = {
    proposal_id?: SortOrder
    title?: SortOrder
    abstract?: SortOrder
    status?: SortOrder
    team_id?: SortOrder
    submitted_by?: SortOrder
    pdf_path?: SortOrder
    file_size?: SortOrder
    created_at?: SortOrder
    aggregated_decided_at?: SortOrder
    aggregated_decision?: SortOrder
  }

  export type proposalMinOrderByAggregateInput = {
    proposal_id?: SortOrder
    title?: SortOrder
    abstract?: SortOrder
    status?: SortOrder
    team_id?: SortOrder
    submitted_by?: SortOrder
    pdf_path?: SortOrder
    file_size?: SortOrder
    created_at?: SortOrder
    aggregated_decided_at?: SortOrder
    aggregated_decision?: SortOrder
  }

  export type proposalSumOrderByAggregateInput = {
    proposal_id?: SortOrder
    team_id?: SortOrder
    submitted_by?: SortOrder
    file_size?: SortOrder
  }

  export type PaperNullableScalarRelationFilter = {
    is?: paperWhereInput | null
    isNot?: paperWhereInput | null
  }

  export type ProposalNullableScalarRelationFilter = {
    is?: proposalWhereInput | null
    isNot?: proposalWhereInput | null
  }

  export type reviewCountOrderByAggregateInput = {
    review_id?: SortOrder
    reviewer_id?: SortOrder
    proposal_id?: SortOrder
    paper_id?: SortOrder
    comments?: SortOrder
    score?: SortOrder
    reviewed_at?: SortOrder
    attachment_path?: SortOrder
    decision?: SortOrder
  }

  export type reviewAvgOrderByAggregateInput = {
    review_id?: SortOrder
    reviewer_id?: SortOrder
    proposal_id?: SortOrder
    paper_id?: SortOrder
    score?: SortOrder
  }

  export type reviewMaxOrderByAggregateInput = {
    review_id?: SortOrder
    reviewer_id?: SortOrder
    proposal_id?: SortOrder
    paper_id?: SortOrder
    comments?: SortOrder
    score?: SortOrder
    reviewed_at?: SortOrder
    attachment_path?: SortOrder
    decision?: SortOrder
  }

  export type reviewMinOrderByAggregateInput = {
    review_id?: SortOrder
    reviewer_id?: SortOrder
    proposal_id?: SortOrder
    paper_id?: SortOrder
    comments?: SortOrder
    score?: SortOrder
    reviewed_at?: SortOrder
    attachment_path?: SortOrder
    decision?: SortOrder
  }

  export type reviewSumOrderByAggregateInput = {
    review_id?: SortOrder
    reviewer_id?: SortOrder
    proposal_id?: SortOrder
    paper_id?: SortOrder
    score?: SortOrder
  }

  export type EnumAssignmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AssignmentStatus | EnumAssignmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssignmentStatusFilter<$PrismaModel> | $Enums.AssignmentStatus
  }

  export type ReviewerScalarRelationFilter = {
    is?: reviewerWhereInput
    isNot?: reviewerWhereInput
  }

  export type reviewerassignmentCountOrderByAggregateInput = {
    assignment_id?: SortOrder
    reviewer_id?: SortOrder
    proposal_id?: SortOrder
    paper_id?: SortOrder
    assigned_date?: SortOrder
    due_date?: SortOrder
    status?: SortOrder
    completed_at?: SortOrder
    started_at?: SortOrder
  }

  export type reviewerassignmentAvgOrderByAggregateInput = {
    assignment_id?: SortOrder
    reviewer_id?: SortOrder
    proposal_id?: SortOrder
    paper_id?: SortOrder
  }

  export type reviewerassignmentMaxOrderByAggregateInput = {
    assignment_id?: SortOrder
    reviewer_id?: SortOrder
    proposal_id?: SortOrder
    paper_id?: SortOrder
    assigned_date?: SortOrder
    due_date?: SortOrder
    status?: SortOrder
    completed_at?: SortOrder
    started_at?: SortOrder
  }

  export type reviewerassignmentMinOrderByAggregateInput = {
    assignment_id?: SortOrder
    reviewer_id?: SortOrder
    proposal_id?: SortOrder
    paper_id?: SortOrder
    assigned_date?: SortOrder
    due_date?: SortOrder
    status?: SortOrder
    completed_at?: SortOrder
    started_at?: SortOrder
  }

  export type reviewerassignmentSumOrderByAggregateInput = {
    assignment_id?: SortOrder
    reviewer_id?: SortOrder
    proposal_id?: SortOrder
    paper_id?: SortOrder
  }

  export type EnumAssignmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssignmentStatus | EnumAssignmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssignmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AssignmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssignmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAssignmentStatusFilter<$PrismaModel>
  }

  export type userdomainUser_idDomain_idCompoundUniqueInput = {
    user_id: number
    domain_id: number
  }

  export type userdomainCountOrderByAggregateInput = {
    user_id?: SortOrder
    domain_id?: SortOrder
  }

  export type userdomainAvgOrderByAggregateInput = {
    user_id?: SortOrder
    domain_id?: SortOrder
  }

  export type userdomainMaxOrderByAggregateInput = {
    user_id?: SortOrder
    domain_id?: SortOrder
  }

  export type userdomainMinOrderByAggregateInput = {
    user_id?: SortOrder
    domain_id?: SortOrder
  }

  export type userdomainSumOrderByAggregateInput = {
    user_id?: SortOrder
    domain_id?: SortOrder
  }

  export type adminCreateNestedManyWithoutUserInput = {
    create?: XOR<adminCreateWithoutUserInput, adminUncheckedCreateWithoutUserInput> | adminCreateWithoutUserInput[] | adminUncheckedCreateWithoutUserInput[]
    connectOrCreate?: adminCreateOrConnectWithoutUserInput | adminCreateOrConnectWithoutUserInput[]
    createMany?: adminCreateManyUserInputEnvelope
    connect?: adminWhereUniqueInput | adminWhereUniqueInput[]
  }

  export type generaluserCreateNestedManyWithoutUserInput = {
    create?: XOR<generaluserCreateWithoutUserInput, generaluserUncheckedCreateWithoutUserInput> | generaluserCreateWithoutUserInput[] | generaluserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: generaluserCreateOrConnectWithoutUserInput | generaluserCreateOrConnectWithoutUserInput[]
    createMany?: generaluserCreateManyUserInputEnvelope
    connect?: generaluserWhereUniqueInput | generaluserWhereUniqueInput[]
  }

  export type studentCreateNestedManyWithoutUserInput = {
    create?: XOR<studentCreateWithoutUserInput, studentUncheckedCreateWithoutUserInput> | studentCreateWithoutUserInput[] | studentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: studentCreateOrConnectWithoutUserInput | studentCreateOrConnectWithoutUserInput[]
    createMany?: studentCreateManyUserInputEnvelope
    connect?: studentWhereUniqueInput | studentWhereUniqueInput[]
  }

  export type teacherCreateNestedManyWithoutUserInput = {
    create?: XOR<teacherCreateWithoutUserInput, teacherUncheckedCreateWithoutUserInput> | teacherCreateWithoutUserInput[] | teacherUncheckedCreateWithoutUserInput[]
    connectOrCreate?: teacherCreateOrConnectWithoutUserInput | teacherCreateOrConnectWithoutUserInput[]
    createMany?: teacherCreateManyUserInputEnvelope
    connect?: teacherWhereUniqueInput | teacherWhereUniqueInput[]
  }

  export type teamCreateNestedManyWithoutCreated_by_userInput = {
    create?: XOR<teamCreateWithoutCreated_by_userInput, teamUncheckedCreateWithoutCreated_by_userInput> | teamCreateWithoutCreated_by_userInput[] | teamUncheckedCreateWithoutCreated_by_userInput[]
    connectOrCreate?: teamCreateOrConnectWithoutCreated_by_userInput | teamCreateOrConnectWithoutCreated_by_userInput[]
    createMany?: teamCreateManyCreated_by_userInputEnvelope
    connect?: teamWhereUniqueInput | teamWhereUniqueInput[]
  }

  export type teamcommentCreateNestedManyWithoutUserInput = {
    create?: XOR<teamcommentCreateWithoutUserInput, teamcommentUncheckedCreateWithoutUserInput> | teamcommentCreateWithoutUserInput[] | teamcommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: teamcommentCreateOrConnectWithoutUserInput | teamcommentCreateOrConnectWithoutUserInput[]
    createMany?: teamcommentCreateManyUserInputEnvelope
    connect?: teamcommentWhereUniqueInput | teamcommentWhereUniqueInput[]
  }

  export type teammemberCreateNestedManyWithoutUserInput = {
    create?: XOR<teammemberCreateWithoutUserInput, teammemberUncheckedCreateWithoutUserInput> | teammemberCreateWithoutUserInput[] | teammemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: teammemberCreateOrConnectWithoutUserInput | teammemberCreateOrConnectWithoutUserInput[]
    createMany?: teammemberCreateManyUserInputEnvelope
    connect?: teammemberWhereUniqueInput | teammemberWhereUniqueInput[]
  }

  export type userdomainCreateNestedManyWithoutUserInput = {
    create?: XOR<userdomainCreateWithoutUserInput, userdomainUncheckedCreateWithoutUserInput> | userdomainCreateWithoutUserInput[] | userdomainUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userdomainCreateOrConnectWithoutUserInput | userdomainCreateOrConnectWithoutUserInput[]
    createMany?: userdomainCreateManyUserInputEnvelope
    connect?: userdomainWhereUniqueInput | userdomainWhereUniqueInput[]
  }

  export type adminUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<adminCreateWithoutUserInput, adminUncheckedCreateWithoutUserInput> | adminCreateWithoutUserInput[] | adminUncheckedCreateWithoutUserInput[]
    connectOrCreate?: adminCreateOrConnectWithoutUserInput | adminCreateOrConnectWithoutUserInput[]
    createMany?: adminCreateManyUserInputEnvelope
    connect?: adminWhereUniqueInput | adminWhereUniqueInput[]
  }

  export type generaluserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<generaluserCreateWithoutUserInput, generaluserUncheckedCreateWithoutUserInput> | generaluserCreateWithoutUserInput[] | generaluserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: generaluserCreateOrConnectWithoutUserInput | generaluserCreateOrConnectWithoutUserInput[]
    createMany?: generaluserCreateManyUserInputEnvelope
    connect?: generaluserWhereUniqueInput | generaluserWhereUniqueInput[]
  }

  export type studentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<studentCreateWithoutUserInput, studentUncheckedCreateWithoutUserInput> | studentCreateWithoutUserInput[] | studentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: studentCreateOrConnectWithoutUserInput | studentCreateOrConnectWithoutUserInput[]
    createMany?: studentCreateManyUserInputEnvelope
    connect?: studentWhereUniqueInput | studentWhereUniqueInput[]
  }

  export type teacherUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<teacherCreateWithoutUserInput, teacherUncheckedCreateWithoutUserInput> | teacherCreateWithoutUserInput[] | teacherUncheckedCreateWithoutUserInput[]
    connectOrCreate?: teacherCreateOrConnectWithoutUserInput | teacherCreateOrConnectWithoutUserInput[]
    createMany?: teacherCreateManyUserInputEnvelope
    connect?: teacherWhereUniqueInput | teacherWhereUniqueInput[]
  }

  export type teamUncheckedCreateNestedManyWithoutCreated_by_userInput = {
    create?: XOR<teamCreateWithoutCreated_by_userInput, teamUncheckedCreateWithoutCreated_by_userInput> | teamCreateWithoutCreated_by_userInput[] | teamUncheckedCreateWithoutCreated_by_userInput[]
    connectOrCreate?: teamCreateOrConnectWithoutCreated_by_userInput | teamCreateOrConnectWithoutCreated_by_userInput[]
    createMany?: teamCreateManyCreated_by_userInputEnvelope
    connect?: teamWhereUniqueInput | teamWhereUniqueInput[]
  }

  export type teamcommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<teamcommentCreateWithoutUserInput, teamcommentUncheckedCreateWithoutUserInput> | teamcommentCreateWithoutUserInput[] | teamcommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: teamcommentCreateOrConnectWithoutUserInput | teamcommentCreateOrConnectWithoutUserInput[]
    createMany?: teamcommentCreateManyUserInputEnvelope
    connect?: teamcommentWhereUniqueInput | teamcommentWhereUniqueInput[]
  }

  export type teammemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<teammemberCreateWithoutUserInput, teammemberUncheckedCreateWithoutUserInput> | teammemberCreateWithoutUserInput[] | teammemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: teammemberCreateOrConnectWithoutUserInput | teammemberCreateOrConnectWithoutUserInput[]
    createMany?: teammemberCreateManyUserInputEnvelope
    connect?: teammemberWhereUniqueInput | teammemberWhereUniqueInput[]
  }

  export type userdomainUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<userdomainCreateWithoutUserInput, userdomainUncheckedCreateWithoutUserInput> | userdomainCreateWithoutUserInput[] | userdomainUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userdomainCreateOrConnectWithoutUserInput | userdomainCreateOrConnectWithoutUserInput[]
    createMany?: userdomainCreateManyUserInputEnvelope
    connect?: userdomainWhereUniqueInput | userdomainWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableEnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type adminUpdateManyWithoutUserNestedInput = {
    create?: XOR<adminCreateWithoutUserInput, adminUncheckedCreateWithoutUserInput> | adminCreateWithoutUserInput[] | adminUncheckedCreateWithoutUserInput[]
    connectOrCreate?: adminCreateOrConnectWithoutUserInput | adminCreateOrConnectWithoutUserInput[]
    upsert?: adminUpsertWithWhereUniqueWithoutUserInput | adminUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: adminCreateManyUserInputEnvelope
    set?: adminWhereUniqueInput | adminWhereUniqueInput[]
    disconnect?: adminWhereUniqueInput | adminWhereUniqueInput[]
    delete?: adminWhereUniqueInput | adminWhereUniqueInput[]
    connect?: adminWhereUniqueInput | adminWhereUniqueInput[]
    update?: adminUpdateWithWhereUniqueWithoutUserInput | adminUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: adminUpdateManyWithWhereWithoutUserInput | adminUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: adminScalarWhereInput | adminScalarWhereInput[]
  }

  export type generaluserUpdateManyWithoutUserNestedInput = {
    create?: XOR<generaluserCreateWithoutUserInput, generaluserUncheckedCreateWithoutUserInput> | generaluserCreateWithoutUserInput[] | generaluserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: generaluserCreateOrConnectWithoutUserInput | generaluserCreateOrConnectWithoutUserInput[]
    upsert?: generaluserUpsertWithWhereUniqueWithoutUserInput | generaluserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: generaluserCreateManyUserInputEnvelope
    set?: generaluserWhereUniqueInput | generaluserWhereUniqueInput[]
    disconnect?: generaluserWhereUniqueInput | generaluserWhereUniqueInput[]
    delete?: generaluserWhereUniqueInput | generaluserWhereUniqueInput[]
    connect?: generaluserWhereUniqueInput | generaluserWhereUniqueInput[]
    update?: generaluserUpdateWithWhereUniqueWithoutUserInput | generaluserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: generaluserUpdateManyWithWhereWithoutUserInput | generaluserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: generaluserScalarWhereInput | generaluserScalarWhereInput[]
  }

  export type studentUpdateManyWithoutUserNestedInput = {
    create?: XOR<studentCreateWithoutUserInput, studentUncheckedCreateWithoutUserInput> | studentCreateWithoutUserInput[] | studentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: studentCreateOrConnectWithoutUserInput | studentCreateOrConnectWithoutUserInput[]
    upsert?: studentUpsertWithWhereUniqueWithoutUserInput | studentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: studentCreateManyUserInputEnvelope
    set?: studentWhereUniqueInput | studentWhereUniqueInput[]
    disconnect?: studentWhereUniqueInput | studentWhereUniqueInput[]
    delete?: studentWhereUniqueInput | studentWhereUniqueInput[]
    connect?: studentWhereUniqueInput | studentWhereUniqueInput[]
    update?: studentUpdateWithWhereUniqueWithoutUserInput | studentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: studentUpdateManyWithWhereWithoutUserInput | studentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: studentScalarWhereInput | studentScalarWhereInput[]
  }

  export type teacherUpdateManyWithoutUserNestedInput = {
    create?: XOR<teacherCreateWithoutUserInput, teacherUncheckedCreateWithoutUserInput> | teacherCreateWithoutUserInput[] | teacherUncheckedCreateWithoutUserInput[]
    connectOrCreate?: teacherCreateOrConnectWithoutUserInput | teacherCreateOrConnectWithoutUserInput[]
    upsert?: teacherUpsertWithWhereUniqueWithoutUserInput | teacherUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: teacherCreateManyUserInputEnvelope
    set?: teacherWhereUniqueInput | teacherWhereUniqueInput[]
    disconnect?: teacherWhereUniqueInput | teacherWhereUniqueInput[]
    delete?: teacherWhereUniqueInput | teacherWhereUniqueInput[]
    connect?: teacherWhereUniqueInput | teacherWhereUniqueInput[]
    update?: teacherUpdateWithWhereUniqueWithoutUserInput | teacherUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: teacherUpdateManyWithWhereWithoutUserInput | teacherUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: teacherScalarWhereInput | teacherScalarWhereInput[]
  }

  export type teamUpdateManyWithoutCreated_by_userNestedInput = {
    create?: XOR<teamCreateWithoutCreated_by_userInput, teamUncheckedCreateWithoutCreated_by_userInput> | teamCreateWithoutCreated_by_userInput[] | teamUncheckedCreateWithoutCreated_by_userInput[]
    connectOrCreate?: teamCreateOrConnectWithoutCreated_by_userInput | teamCreateOrConnectWithoutCreated_by_userInput[]
    upsert?: teamUpsertWithWhereUniqueWithoutCreated_by_userInput | teamUpsertWithWhereUniqueWithoutCreated_by_userInput[]
    createMany?: teamCreateManyCreated_by_userInputEnvelope
    set?: teamWhereUniqueInput | teamWhereUniqueInput[]
    disconnect?: teamWhereUniqueInput | teamWhereUniqueInput[]
    delete?: teamWhereUniqueInput | teamWhereUniqueInput[]
    connect?: teamWhereUniqueInput | teamWhereUniqueInput[]
    update?: teamUpdateWithWhereUniqueWithoutCreated_by_userInput | teamUpdateWithWhereUniqueWithoutCreated_by_userInput[]
    updateMany?: teamUpdateManyWithWhereWithoutCreated_by_userInput | teamUpdateManyWithWhereWithoutCreated_by_userInput[]
    deleteMany?: teamScalarWhereInput | teamScalarWhereInput[]
  }

  export type teamcommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<teamcommentCreateWithoutUserInput, teamcommentUncheckedCreateWithoutUserInput> | teamcommentCreateWithoutUserInput[] | teamcommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: teamcommentCreateOrConnectWithoutUserInput | teamcommentCreateOrConnectWithoutUserInput[]
    upsert?: teamcommentUpsertWithWhereUniqueWithoutUserInput | teamcommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: teamcommentCreateManyUserInputEnvelope
    set?: teamcommentWhereUniqueInput | teamcommentWhereUniqueInput[]
    disconnect?: teamcommentWhereUniqueInput | teamcommentWhereUniqueInput[]
    delete?: teamcommentWhereUniqueInput | teamcommentWhereUniqueInput[]
    connect?: teamcommentWhereUniqueInput | teamcommentWhereUniqueInput[]
    update?: teamcommentUpdateWithWhereUniqueWithoutUserInput | teamcommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: teamcommentUpdateManyWithWhereWithoutUserInput | teamcommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: teamcommentScalarWhereInput | teamcommentScalarWhereInput[]
  }

  export type teammemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<teammemberCreateWithoutUserInput, teammemberUncheckedCreateWithoutUserInput> | teammemberCreateWithoutUserInput[] | teammemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: teammemberCreateOrConnectWithoutUserInput | teammemberCreateOrConnectWithoutUserInput[]
    upsert?: teammemberUpsertWithWhereUniqueWithoutUserInput | teammemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: teammemberCreateManyUserInputEnvelope
    set?: teammemberWhereUniqueInput | teammemberWhereUniqueInput[]
    disconnect?: teammemberWhereUniqueInput | teammemberWhereUniqueInput[]
    delete?: teammemberWhereUniqueInput | teammemberWhereUniqueInput[]
    connect?: teammemberWhereUniqueInput | teammemberWhereUniqueInput[]
    update?: teammemberUpdateWithWhereUniqueWithoutUserInput | teammemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: teammemberUpdateManyWithWhereWithoutUserInput | teammemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: teammemberScalarWhereInput | teammemberScalarWhereInput[]
  }

  export type userdomainUpdateManyWithoutUserNestedInput = {
    create?: XOR<userdomainCreateWithoutUserInput, userdomainUncheckedCreateWithoutUserInput> | userdomainCreateWithoutUserInput[] | userdomainUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userdomainCreateOrConnectWithoutUserInput | userdomainCreateOrConnectWithoutUserInput[]
    upsert?: userdomainUpsertWithWhereUniqueWithoutUserInput | userdomainUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: userdomainCreateManyUserInputEnvelope
    set?: userdomainWhereUniqueInput | userdomainWhereUniqueInput[]
    disconnect?: userdomainWhereUniqueInput | userdomainWhereUniqueInput[]
    delete?: userdomainWhereUniqueInput | userdomainWhereUniqueInput[]
    connect?: userdomainWhereUniqueInput | userdomainWhereUniqueInput[]
    update?: userdomainUpdateWithWhereUniqueWithoutUserInput | userdomainUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: userdomainUpdateManyWithWhereWithoutUserInput | userdomainUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: userdomainScalarWhereInput | userdomainScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type adminUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<adminCreateWithoutUserInput, adminUncheckedCreateWithoutUserInput> | adminCreateWithoutUserInput[] | adminUncheckedCreateWithoutUserInput[]
    connectOrCreate?: adminCreateOrConnectWithoutUserInput | adminCreateOrConnectWithoutUserInput[]
    upsert?: adminUpsertWithWhereUniqueWithoutUserInput | adminUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: adminCreateManyUserInputEnvelope
    set?: adminWhereUniqueInput | adminWhereUniqueInput[]
    disconnect?: adminWhereUniqueInput | adminWhereUniqueInput[]
    delete?: adminWhereUniqueInput | adminWhereUniqueInput[]
    connect?: adminWhereUniqueInput | adminWhereUniqueInput[]
    update?: adminUpdateWithWhereUniqueWithoutUserInput | adminUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: adminUpdateManyWithWhereWithoutUserInput | adminUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: adminScalarWhereInput | adminScalarWhereInput[]
  }

  export type generaluserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<generaluserCreateWithoutUserInput, generaluserUncheckedCreateWithoutUserInput> | generaluserCreateWithoutUserInput[] | generaluserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: generaluserCreateOrConnectWithoutUserInput | generaluserCreateOrConnectWithoutUserInput[]
    upsert?: generaluserUpsertWithWhereUniqueWithoutUserInput | generaluserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: generaluserCreateManyUserInputEnvelope
    set?: generaluserWhereUniqueInput | generaluserWhereUniqueInput[]
    disconnect?: generaluserWhereUniqueInput | generaluserWhereUniqueInput[]
    delete?: generaluserWhereUniqueInput | generaluserWhereUniqueInput[]
    connect?: generaluserWhereUniqueInput | generaluserWhereUniqueInput[]
    update?: generaluserUpdateWithWhereUniqueWithoutUserInput | generaluserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: generaluserUpdateManyWithWhereWithoutUserInput | generaluserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: generaluserScalarWhereInput | generaluserScalarWhereInput[]
  }

  export type studentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<studentCreateWithoutUserInput, studentUncheckedCreateWithoutUserInput> | studentCreateWithoutUserInput[] | studentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: studentCreateOrConnectWithoutUserInput | studentCreateOrConnectWithoutUserInput[]
    upsert?: studentUpsertWithWhereUniqueWithoutUserInput | studentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: studentCreateManyUserInputEnvelope
    set?: studentWhereUniqueInput | studentWhereUniqueInput[]
    disconnect?: studentWhereUniqueInput | studentWhereUniqueInput[]
    delete?: studentWhereUniqueInput | studentWhereUniqueInput[]
    connect?: studentWhereUniqueInput | studentWhereUniqueInput[]
    update?: studentUpdateWithWhereUniqueWithoutUserInput | studentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: studentUpdateManyWithWhereWithoutUserInput | studentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: studentScalarWhereInput | studentScalarWhereInput[]
  }

  export type teacherUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<teacherCreateWithoutUserInput, teacherUncheckedCreateWithoutUserInput> | teacherCreateWithoutUserInput[] | teacherUncheckedCreateWithoutUserInput[]
    connectOrCreate?: teacherCreateOrConnectWithoutUserInput | teacherCreateOrConnectWithoutUserInput[]
    upsert?: teacherUpsertWithWhereUniqueWithoutUserInput | teacherUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: teacherCreateManyUserInputEnvelope
    set?: teacherWhereUniqueInput | teacherWhereUniqueInput[]
    disconnect?: teacherWhereUniqueInput | teacherWhereUniqueInput[]
    delete?: teacherWhereUniqueInput | teacherWhereUniqueInput[]
    connect?: teacherWhereUniqueInput | teacherWhereUniqueInput[]
    update?: teacherUpdateWithWhereUniqueWithoutUserInput | teacherUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: teacherUpdateManyWithWhereWithoutUserInput | teacherUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: teacherScalarWhereInput | teacherScalarWhereInput[]
  }

  export type teamUncheckedUpdateManyWithoutCreated_by_userNestedInput = {
    create?: XOR<teamCreateWithoutCreated_by_userInput, teamUncheckedCreateWithoutCreated_by_userInput> | teamCreateWithoutCreated_by_userInput[] | teamUncheckedCreateWithoutCreated_by_userInput[]
    connectOrCreate?: teamCreateOrConnectWithoutCreated_by_userInput | teamCreateOrConnectWithoutCreated_by_userInput[]
    upsert?: teamUpsertWithWhereUniqueWithoutCreated_by_userInput | teamUpsertWithWhereUniqueWithoutCreated_by_userInput[]
    createMany?: teamCreateManyCreated_by_userInputEnvelope
    set?: teamWhereUniqueInput | teamWhereUniqueInput[]
    disconnect?: teamWhereUniqueInput | teamWhereUniqueInput[]
    delete?: teamWhereUniqueInput | teamWhereUniqueInput[]
    connect?: teamWhereUniqueInput | teamWhereUniqueInput[]
    update?: teamUpdateWithWhereUniqueWithoutCreated_by_userInput | teamUpdateWithWhereUniqueWithoutCreated_by_userInput[]
    updateMany?: teamUpdateManyWithWhereWithoutCreated_by_userInput | teamUpdateManyWithWhereWithoutCreated_by_userInput[]
    deleteMany?: teamScalarWhereInput | teamScalarWhereInput[]
  }

  export type teamcommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<teamcommentCreateWithoutUserInput, teamcommentUncheckedCreateWithoutUserInput> | teamcommentCreateWithoutUserInput[] | teamcommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: teamcommentCreateOrConnectWithoutUserInput | teamcommentCreateOrConnectWithoutUserInput[]
    upsert?: teamcommentUpsertWithWhereUniqueWithoutUserInput | teamcommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: teamcommentCreateManyUserInputEnvelope
    set?: teamcommentWhereUniqueInput | teamcommentWhereUniqueInput[]
    disconnect?: teamcommentWhereUniqueInput | teamcommentWhereUniqueInput[]
    delete?: teamcommentWhereUniqueInput | teamcommentWhereUniqueInput[]
    connect?: teamcommentWhereUniqueInput | teamcommentWhereUniqueInput[]
    update?: teamcommentUpdateWithWhereUniqueWithoutUserInput | teamcommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: teamcommentUpdateManyWithWhereWithoutUserInput | teamcommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: teamcommentScalarWhereInput | teamcommentScalarWhereInput[]
  }

  export type teammemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<teammemberCreateWithoutUserInput, teammemberUncheckedCreateWithoutUserInput> | teammemberCreateWithoutUserInput[] | teammemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: teammemberCreateOrConnectWithoutUserInput | teammemberCreateOrConnectWithoutUserInput[]
    upsert?: teammemberUpsertWithWhereUniqueWithoutUserInput | teammemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: teammemberCreateManyUserInputEnvelope
    set?: teammemberWhereUniqueInput | teammemberWhereUniqueInput[]
    disconnect?: teammemberWhereUniqueInput | teammemberWhereUniqueInput[]
    delete?: teammemberWhereUniqueInput | teammemberWhereUniqueInput[]
    connect?: teammemberWhereUniqueInput | teammemberWhereUniqueInput[]
    update?: teammemberUpdateWithWhereUniqueWithoutUserInput | teammemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: teammemberUpdateManyWithWhereWithoutUserInput | teammemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: teammemberScalarWhereInput | teammemberScalarWhereInput[]
  }

  export type userdomainUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<userdomainCreateWithoutUserInput, userdomainUncheckedCreateWithoutUserInput> | userdomainCreateWithoutUserInput[] | userdomainUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userdomainCreateOrConnectWithoutUserInput | userdomainCreateOrConnectWithoutUserInput[]
    upsert?: userdomainUpsertWithWhereUniqueWithoutUserInput | userdomainUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: userdomainCreateManyUserInputEnvelope
    set?: userdomainWhereUniqueInput | userdomainWhereUniqueInput[]
    disconnect?: userdomainWhereUniqueInput | userdomainWhereUniqueInput[]
    delete?: userdomainWhereUniqueInput | userdomainWhereUniqueInput[]
    connect?: userdomainWhereUniqueInput | userdomainWhereUniqueInput[]
    update?: userdomainUpdateWithWhereUniqueWithoutUserInput | userdomainUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: userdomainUpdateManyWithWhereWithoutUserInput | userdomainUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: userdomainScalarWhereInput | userdomainScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutAdminInput = {
    create?: XOR<userCreateWithoutAdminInput, userUncheckedCreateWithoutAdminInput>
    connectOrCreate?: userCreateOrConnectWithoutAdminInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneWithoutAdminNestedInput = {
    create?: XOR<userCreateWithoutAdminInput, userUncheckedCreateWithoutAdminInput>
    connectOrCreate?: userCreateOrConnectWithoutAdminInput
    upsert?: userUpsertWithoutAdminInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutAdminInput, userUpdateWithoutAdminInput>, userUncheckedUpdateWithoutAdminInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type departmentdomainCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<departmentdomainCreateWithoutDepartmentInput, departmentdomainUncheckedCreateWithoutDepartmentInput> | departmentdomainCreateWithoutDepartmentInput[] | departmentdomainUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: departmentdomainCreateOrConnectWithoutDepartmentInput | departmentdomainCreateOrConnectWithoutDepartmentInput[]
    createMany?: departmentdomainCreateManyDepartmentInputEnvelope
    connect?: departmentdomainWhereUniqueInput | departmentdomainWhereUniqueInput[]
  }

  export type studentCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<studentCreateWithoutDepartmentInput, studentUncheckedCreateWithoutDepartmentInput> | studentCreateWithoutDepartmentInput[] | studentUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: studentCreateOrConnectWithoutDepartmentInput | studentCreateOrConnectWithoutDepartmentInput[]
    createMany?: studentCreateManyDepartmentInputEnvelope
    connect?: studentWhereUniqueInput | studentWhereUniqueInput[]
  }

  export type teacherCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<teacherCreateWithoutDepartmentInput, teacherUncheckedCreateWithoutDepartmentInput> | teacherCreateWithoutDepartmentInput[] | teacherUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: teacherCreateOrConnectWithoutDepartmentInput | teacherCreateOrConnectWithoutDepartmentInput[]
    createMany?: teacherCreateManyDepartmentInputEnvelope
    connect?: teacherWhereUniqueInput | teacherWhereUniqueInput[]
  }

  export type departmentdomainUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<departmentdomainCreateWithoutDepartmentInput, departmentdomainUncheckedCreateWithoutDepartmentInput> | departmentdomainCreateWithoutDepartmentInput[] | departmentdomainUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: departmentdomainCreateOrConnectWithoutDepartmentInput | departmentdomainCreateOrConnectWithoutDepartmentInput[]
    createMany?: departmentdomainCreateManyDepartmentInputEnvelope
    connect?: departmentdomainWhereUniqueInput | departmentdomainWhereUniqueInput[]
  }

  export type studentUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<studentCreateWithoutDepartmentInput, studentUncheckedCreateWithoutDepartmentInput> | studentCreateWithoutDepartmentInput[] | studentUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: studentCreateOrConnectWithoutDepartmentInput | studentCreateOrConnectWithoutDepartmentInput[]
    createMany?: studentCreateManyDepartmentInputEnvelope
    connect?: studentWhereUniqueInput | studentWhereUniqueInput[]
  }

  export type teacherUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<teacherCreateWithoutDepartmentInput, teacherUncheckedCreateWithoutDepartmentInput> | teacherCreateWithoutDepartmentInput[] | teacherUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: teacherCreateOrConnectWithoutDepartmentInput | teacherCreateOrConnectWithoutDepartmentInput[]
    createMany?: teacherCreateManyDepartmentInputEnvelope
    connect?: teacherWhereUniqueInput | teacherWhereUniqueInput[]
  }

  export type departmentdomainUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<departmentdomainCreateWithoutDepartmentInput, departmentdomainUncheckedCreateWithoutDepartmentInput> | departmentdomainCreateWithoutDepartmentInput[] | departmentdomainUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: departmentdomainCreateOrConnectWithoutDepartmentInput | departmentdomainCreateOrConnectWithoutDepartmentInput[]
    upsert?: departmentdomainUpsertWithWhereUniqueWithoutDepartmentInput | departmentdomainUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: departmentdomainCreateManyDepartmentInputEnvelope
    set?: departmentdomainWhereUniqueInput | departmentdomainWhereUniqueInput[]
    disconnect?: departmentdomainWhereUniqueInput | departmentdomainWhereUniqueInput[]
    delete?: departmentdomainWhereUniqueInput | departmentdomainWhereUniqueInput[]
    connect?: departmentdomainWhereUniqueInput | departmentdomainWhereUniqueInput[]
    update?: departmentdomainUpdateWithWhereUniqueWithoutDepartmentInput | departmentdomainUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: departmentdomainUpdateManyWithWhereWithoutDepartmentInput | departmentdomainUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: departmentdomainScalarWhereInput | departmentdomainScalarWhereInput[]
  }

  export type studentUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<studentCreateWithoutDepartmentInput, studentUncheckedCreateWithoutDepartmentInput> | studentCreateWithoutDepartmentInput[] | studentUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: studentCreateOrConnectWithoutDepartmentInput | studentCreateOrConnectWithoutDepartmentInput[]
    upsert?: studentUpsertWithWhereUniqueWithoutDepartmentInput | studentUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: studentCreateManyDepartmentInputEnvelope
    set?: studentWhereUniqueInput | studentWhereUniqueInput[]
    disconnect?: studentWhereUniqueInput | studentWhereUniqueInput[]
    delete?: studentWhereUniqueInput | studentWhereUniqueInput[]
    connect?: studentWhereUniqueInput | studentWhereUniqueInput[]
    update?: studentUpdateWithWhereUniqueWithoutDepartmentInput | studentUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: studentUpdateManyWithWhereWithoutDepartmentInput | studentUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: studentScalarWhereInput | studentScalarWhereInput[]
  }

  export type teacherUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<teacherCreateWithoutDepartmentInput, teacherUncheckedCreateWithoutDepartmentInput> | teacherCreateWithoutDepartmentInput[] | teacherUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: teacherCreateOrConnectWithoutDepartmentInput | teacherCreateOrConnectWithoutDepartmentInput[]
    upsert?: teacherUpsertWithWhereUniqueWithoutDepartmentInput | teacherUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: teacherCreateManyDepartmentInputEnvelope
    set?: teacherWhereUniqueInput | teacherWhereUniqueInput[]
    disconnect?: teacherWhereUniqueInput | teacherWhereUniqueInput[]
    delete?: teacherWhereUniqueInput | teacherWhereUniqueInput[]
    connect?: teacherWhereUniqueInput | teacherWhereUniqueInput[]
    update?: teacherUpdateWithWhereUniqueWithoutDepartmentInput | teacherUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: teacherUpdateManyWithWhereWithoutDepartmentInput | teacherUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: teacherScalarWhereInput | teacherScalarWhereInput[]
  }

  export type departmentdomainUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<departmentdomainCreateWithoutDepartmentInput, departmentdomainUncheckedCreateWithoutDepartmentInput> | departmentdomainCreateWithoutDepartmentInput[] | departmentdomainUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: departmentdomainCreateOrConnectWithoutDepartmentInput | departmentdomainCreateOrConnectWithoutDepartmentInput[]
    upsert?: departmentdomainUpsertWithWhereUniqueWithoutDepartmentInput | departmentdomainUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: departmentdomainCreateManyDepartmentInputEnvelope
    set?: departmentdomainWhereUniqueInput | departmentdomainWhereUniqueInput[]
    disconnect?: departmentdomainWhereUniqueInput | departmentdomainWhereUniqueInput[]
    delete?: departmentdomainWhereUniqueInput | departmentdomainWhereUniqueInput[]
    connect?: departmentdomainWhereUniqueInput | departmentdomainWhereUniqueInput[]
    update?: departmentdomainUpdateWithWhereUniqueWithoutDepartmentInput | departmentdomainUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: departmentdomainUpdateManyWithWhereWithoutDepartmentInput | departmentdomainUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: departmentdomainScalarWhereInput | departmentdomainScalarWhereInput[]
  }

  export type studentUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<studentCreateWithoutDepartmentInput, studentUncheckedCreateWithoutDepartmentInput> | studentCreateWithoutDepartmentInput[] | studentUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: studentCreateOrConnectWithoutDepartmentInput | studentCreateOrConnectWithoutDepartmentInput[]
    upsert?: studentUpsertWithWhereUniqueWithoutDepartmentInput | studentUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: studentCreateManyDepartmentInputEnvelope
    set?: studentWhereUniqueInput | studentWhereUniqueInput[]
    disconnect?: studentWhereUniqueInput | studentWhereUniqueInput[]
    delete?: studentWhereUniqueInput | studentWhereUniqueInput[]
    connect?: studentWhereUniqueInput | studentWhereUniqueInput[]
    update?: studentUpdateWithWhereUniqueWithoutDepartmentInput | studentUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: studentUpdateManyWithWhereWithoutDepartmentInput | studentUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: studentScalarWhereInput | studentScalarWhereInput[]
  }

  export type teacherUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<teacherCreateWithoutDepartmentInput, teacherUncheckedCreateWithoutDepartmentInput> | teacherCreateWithoutDepartmentInput[] | teacherUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: teacherCreateOrConnectWithoutDepartmentInput | teacherCreateOrConnectWithoutDepartmentInput[]
    upsert?: teacherUpsertWithWhereUniqueWithoutDepartmentInput | teacherUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: teacherCreateManyDepartmentInputEnvelope
    set?: teacherWhereUniqueInput | teacherWhereUniqueInput[]
    disconnect?: teacherWhereUniqueInput | teacherWhereUniqueInput[]
    delete?: teacherWhereUniqueInput | teacherWhereUniqueInput[]
    connect?: teacherWhereUniqueInput | teacherWhereUniqueInput[]
    update?: teacherUpdateWithWhereUniqueWithoutDepartmentInput | teacherUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: teacherUpdateManyWithWhereWithoutDepartmentInput | teacherUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: teacherScalarWhereInput | teacherScalarWhereInput[]
  }

  export type departmentdomainCreateNestedManyWithoutDomainInput = {
    create?: XOR<departmentdomainCreateWithoutDomainInput, departmentdomainUncheckedCreateWithoutDomainInput> | departmentdomainCreateWithoutDomainInput[] | departmentdomainUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: departmentdomainCreateOrConnectWithoutDomainInput | departmentdomainCreateOrConnectWithoutDomainInput[]
    createMany?: departmentdomainCreateManyDomainInputEnvelope
    connect?: departmentdomainWhereUniqueInput | departmentdomainWhereUniqueInput[]
  }

  export type teamCreateNestedManyWithoutDomainInput = {
    create?: XOR<teamCreateWithoutDomainInput, teamUncheckedCreateWithoutDomainInput> | teamCreateWithoutDomainInput[] | teamUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: teamCreateOrConnectWithoutDomainInput | teamCreateOrConnectWithoutDomainInput[]
    createMany?: teamCreateManyDomainInputEnvelope
    connect?: teamWhereUniqueInput | teamWhereUniqueInput[]
  }

  export type userdomainCreateNestedManyWithoutDomainInput = {
    create?: XOR<userdomainCreateWithoutDomainInput, userdomainUncheckedCreateWithoutDomainInput> | userdomainCreateWithoutDomainInput[] | userdomainUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: userdomainCreateOrConnectWithoutDomainInput | userdomainCreateOrConnectWithoutDomainInput[]
    createMany?: userdomainCreateManyDomainInputEnvelope
    connect?: userdomainWhereUniqueInput | userdomainWhereUniqueInput[]
  }

  export type departmentdomainUncheckedCreateNestedManyWithoutDomainInput = {
    create?: XOR<departmentdomainCreateWithoutDomainInput, departmentdomainUncheckedCreateWithoutDomainInput> | departmentdomainCreateWithoutDomainInput[] | departmentdomainUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: departmentdomainCreateOrConnectWithoutDomainInput | departmentdomainCreateOrConnectWithoutDomainInput[]
    createMany?: departmentdomainCreateManyDomainInputEnvelope
    connect?: departmentdomainWhereUniqueInput | departmentdomainWhereUniqueInput[]
  }

  export type teamUncheckedCreateNestedManyWithoutDomainInput = {
    create?: XOR<teamCreateWithoutDomainInput, teamUncheckedCreateWithoutDomainInput> | teamCreateWithoutDomainInput[] | teamUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: teamCreateOrConnectWithoutDomainInput | teamCreateOrConnectWithoutDomainInput[]
    createMany?: teamCreateManyDomainInputEnvelope
    connect?: teamWhereUniqueInput | teamWhereUniqueInput[]
  }

  export type userdomainUncheckedCreateNestedManyWithoutDomainInput = {
    create?: XOR<userdomainCreateWithoutDomainInput, userdomainUncheckedCreateWithoutDomainInput> | userdomainCreateWithoutDomainInput[] | userdomainUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: userdomainCreateOrConnectWithoutDomainInput | userdomainCreateOrConnectWithoutDomainInput[]
    createMany?: userdomainCreateManyDomainInputEnvelope
    connect?: userdomainWhereUniqueInput | userdomainWhereUniqueInput[]
  }

  export type departmentdomainUpdateManyWithoutDomainNestedInput = {
    create?: XOR<departmentdomainCreateWithoutDomainInput, departmentdomainUncheckedCreateWithoutDomainInput> | departmentdomainCreateWithoutDomainInput[] | departmentdomainUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: departmentdomainCreateOrConnectWithoutDomainInput | departmentdomainCreateOrConnectWithoutDomainInput[]
    upsert?: departmentdomainUpsertWithWhereUniqueWithoutDomainInput | departmentdomainUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: departmentdomainCreateManyDomainInputEnvelope
    set?: departmentdomainWhereUniqueInput | departmentdomainWhereUniqueInput[]
    disconnect?: departmentdomainWhereUniqueInput | departmentdomainWhereUniqueInput[]
    delete?: departmentdomainWhereUniqueInput | departmentdomainWhereUniqueInput[]
    connect?: departmentdomainWhereUniqueInput | departmentdomainWhereUniqueInput[]
    update?: departmentdomainUpdateWithWhereUniqueWithoutDomainInput | departmentdomainUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: departmentdomainUpdateManyWithWhereWithoutDomainInput | departmentdomainUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: departmentdomainScalarWhereInput | departmentdomainScalarWhereInput[]
  }

  export type teamUpdateManyWithoutDomainNestedInput = {
    create?: XOR<teamCreateWithoutDomainInput, teamUncheckedCreateWithoutDomainInput> | teamCreateWithoutDomainInput[] | teamUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: teamCreateOrConnectWithoutDomainInput | teamCreateOrConnectWithoutDomainInput[]
    upsert?: teamUpsertWithWhereUniqueWithoutDomainInput | teamUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: teamCreateManyDomainInputEnvelope
    set?: teamWhereUniqueInput | teamWhereUniqueInput[]
    disconnect?: teamWhereUniqueInput | teamWhereUniqueInput[]
    delete?: teamWhereUniqueInput | teamWhereUniqueInput[]
    connect?: teamWhereUniqueInput | teamWhereUniqueInput[]
    update?: teamUpdateWithWhereUniqueWithoutDomainInput | teamUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: teamUpdateManyWithWhereWithoutDomainInput | teamUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: teamScalarWhereInput | teamScalarWhereInput[]
  }

  export type userdomainUpdateManyWithoutDomainNestedInput = {
    create?: XOR<userdomainCreateWithoutDomainInput, userdomainUncheckedCreateWithoutDomainInput> | userdomainCreateWithoutDomainInput[] | userdomainUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: userdomainCreateOrConnectWithoutDomainInput | userdomainCreateOrConnectWithoutDomainInput[]
    upsert?: userdomainUpsertWithWhereUniqueWithoutDomainInput | userdomainUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: userdomainCreateManyDomainInputEnvelope
    set?: userdomainWhereUniqueInput | userdomainWhereUniqueInput[]
    disconnect?: userdomainWhereUniqueInput | userdomainWhereUniqueInput[]
    delete?: userdomainWhereUniqueInput | userdomainWhereUniqueInput[]
    connect?: userdomainWhereUniqueInput | userdomainWhereUniqueInput[]
    update?: userdomainUpdateWithWhereUniqueWithoutDomainInput | userdomainUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: userdomainUpdateManyWithWhereWithoutDomainInput | userdomainUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: userdomainScalarWhereInput | userdomainScalarWhereInput[]
  }

  export type departmentdomainUncheckedUpdateManyWithoutDomainNestedInput = {
    create?: XOR<departmentdomainCreateWithoutDomainInput, departmentdomainUncheckedCreateWithoutDomainInput> | departmentdomainCreateWithoutDomainInput[] | departmentdomainUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: departmentdomainCreateOrConnectWithoutDomainInput | departmentdomainCreateOrConnectWithoutDomainInput[]
    upsert?: departmentdomainUpsertWithWhereUniqueWithoutDomainInput | departmentdomainUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: departmentdomainCreateManyDomainInputEnvelope
    set?: departmentdomainWhereUniqueInput | departmentdomainWhereUniqueInput[]
    disconnect?: departmentdomainWhereUniqueInput | departmentdomainWhereUniqueInput[]
    delete?: departmentdomainWhereUniqueInput | departmentdomainWhereUniqueInput[]
    connect?: departmentdomainWhereUniqueInput | departmentdomainWhereUniqueInput[]
    update?: departmentdomainUpdateWithWhereUniqueWithoutDomainInput | departmentdomainUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: departmentdomainUpdateManyWithWhereWithoutDomainInput | departmentdomainUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: departmentdomainScalarWhereInput | departmentdomainScalarWhereInput[]
  }

  export type teamUncheckedUpdateManyWithoutDomainNestedInput = {
    create?: XOR<teamCreateWithoutDomainInput, teamUncheckedCreateWithoutDomainInput> | teamCreateWithoutDomainInput[] | teamUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: teamCreateOrConnectWithoutDomainInput | teamCreateOrConnectWithoutDomainInput[]
    upsert?: teamUpsertWithWhereUniqueWithoutDomainInput | teamUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: teamCreateManyDomainInputEnvelope
    set?: teamWhereUniqueInput | teamWhereUniqueInput[]
    disconnect?: teamWhereUniqueInput | teamWhereUniqueInput[]
    delete?: teamWhereUniqueInput | teamWhereUniqueInput[]
    connect?: teamWhereUniqueInput | teamWhereUniqueInput[]
    update?: teamUpdateWithWhereUniqueWithoutDomainInput | teamUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: teamUpdateManyWithWhereWithoutDomainInput | teamUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: teamScalarWhereInput | teamScalarWhereInput[]
  }

  export type userdomainUncheckedUpdateManyWithoutDomainNestedInput = {
    create?: XOR<userdomainCreateWithoutDomainInput, userdomainUncheckedCreateWithoutDomainInput> | userdomainCreateWithoutDomainInput[] | userdomainUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: userdomainCreateOrConnectWithoutDomainInput | userdomainCreateOrConnectWithoutDomainInput[]
    upsert?: userdomainUpsertWithWhereUniqueWithoutDomainInput | userdomainUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: userdomainCreateManyDomainInputEnvelope
    set?: userdomainWhereUniqueInput | userdomainWhereUniqueInput[]
    disconnect?: userdomainWhereUniqueInput | userdomainWhereUniqueInput[]
    delete?: userdomainWhereUniqueInput | userdomainWhereUniqueInput[]
    connect?: userdomainWhereUniqueInput | userdomainWhereUniqueInput[]
    update?: userdomainUpdateWithWhereUniqueWithoutDomainInput | userdomainUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: userdomainUpdateManyWithWhereWithoutDomainInput | userdomainUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: userdomainScalarWhereInput | userdomainScalarWhereInput[]
  }

  export type departmentCreateNestedOneWithoutDepartmentdomainInput = {
    create?: XOR<departmentCreateWithoutDepartmentdomainInput, departmentUncheckedCreateWithoutDepartmentdomainInput>
    connectOrCreate?: departmentCreateOrConnectWithoutDepartmentdomainInput
    connect?: departmentWhereUniqueInput
  }

  export type domainCreateNestedOneWithoutDepartmentdomainInput = {
    create?: XOR<domainCreateWithoutDepartmentdomainInput, domainUncheckedCreateWithoutDepartmentdomainInput>
    connectOrCreate?: domainCreateOrConnectWithoutDepartmentdomainInput
    connect?: domainWhereUniqueInput
  }

  export type departmentUpdateOneRequiredWithoutDepartmentdomainNestedInput = {
    create?: XOR<departmentCreateWithoutDepartmentdomainInput, departmentUncheckedCreateWithoutDepartmentdomainInput>
    connectOrCreate?: departmentCreateOrConnectWithoutDepartmentdomainInput
    upsert?: departmentUpsertWithoutDepartmentdomainInput
    connect?: departmentWhereUniqueInput
    update?: XOR<XOR<departmentUpdateToOneWithWhereWithoutDepartmentdomainInput, departmentUpdateWithoutDepartmentdomainInput>, departmentUncheckedUpdateWithoutDepartmentdomainInput>
  }

  export type domainUpdateOneRequiredWithoutDepartmentdomainNestedInput = {
    create?: XOR<domainCreateWithoutDepartmentdomainInput, domainUncheckedCreateWithoutDepartmentdomainInput>
    connectOrCreate?: domainCreateOrConnectWithoutDepartmentdomainInput
    upsert?: domainUpsertWithoutDepartmentdomainInput
    connect?: domainWhereUniqueInput
    update?: XOR<XOR<domainUpdateToOneWithWhereWithoutDepartmentdomainInput, domainUpdateWithoutDepartmentdomainInput>, domainUncheckedUpdateWithoutDepartmentdomainInput>
  }

  export type userCreateNestedOneWithoutGeneraluserInput = {
    create?: XOR<userCreateWithoutGeneraluserInput, userUncheckedCreateWithoutGeneraluserInput>
    connectOrCreate?: userCreateOrConnectWithoutGeneraluserInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneWithoutGeneraluserNestedInput = {
    create?: XOR<userCreateWithoutGeneraluserInput, userUncheckedCreateWithoutGeneraluserInput>
    connectOrCreate?: userCreateOrConnectWithoutGeneraluserInput
    upsert?: userUpsertWithoutGeneraluserInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutGeneraluserInput, userUpdateWithoutGeneraluserInput>, userUncheckedUpdateWithoutGeneraluserInput>
  }

  export type departmentCreateNestedOneWithoutStudentsInput = {
    create?: XOR<departmentCreateWithoutStudentsInput, departmentUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: departmentCreateOrConnectWithoutStudentsInput
    connect?: departmentWhereUniqueInput
  }

  export type userCreateNestedOneWithoutStudentInput = {
    create?: XOR<userCreateWithoutStudentInput, userUncheckedCreateWithoutStudentInput>
    connectOrCreate?: userCreateOrConnectWithoutStudentInput
    connect?: userWhereUniqueInput
  }

  export type teamapplicationCreateNestedManyWithoutStudentInput = {
    create?: XOR<teamapplicationCreateWithoutStudentInput, teamapplicationUncheckedCreateWithoutStudentInput> | teamapplicationCreateWithoutStudentInput[] | teamapplicationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: teamapplicationCreateOrConnectWithoutStudentInput | teamapplicationCreateOrConnectWithoutStudentInput[]
    createMany?: teamapplicationCreateManyStudentInputEnvelope
    connect?: teamapplicationWhereUniqueInput | teamapplicationWhereUniqueInput[]
  }

  export type teamapplicationUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<teamapplicationCreateWithoutStudentInput, teamapplicationUncheckedCreateWithoutStudentInput> | teamapplicationCreateWithoutStudentInput[] | teamapplicationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: teamapplicationCreateOrConnectWithoutStudentInput | teamapplicationCreateOrConnectWithoutStudentInput[]
    createMany?: teamapplicationCreateManyStudentInputEnvelope
    connect?: teamapplicationWhereUniqueInput | teamapplicationWhereUniqueInput[]
  }

  export type departmentUpdateOneWithoutStudentsNestedInput = {
    create?: XOR<departmentCreateWithoutStudentsInput, departmentUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: departmentCreateOrConnectWithoutStudentsInput
    upsert?: departmentUpsertWithoutStudentsInput
    disconnect?: departmentWhereInput | boolean
    delete?: departmentWhereInput | boolean
    connect?: departmentWhereUniqueInput
    update?: XOR<XOR<departmentUpdateToOneWithWhereWithoutStudentsInput, departmentUpdateWithoutStudentsInput>, departmentUncheckedUpdateWithoutStudentsInput>
  }

  export type userUpdateOneWithoutStudentNestedInput = {
    create?: XOR<userCreateWithoutStudentInput, userUncheckedCreateWithoutStudentInput>
    connectOrCreate?: userCreateOrConnectWithoutStudentInput
    upsert?: userUpsertWithoutStudentInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutStudentInput, userUpdateWithoutStudentInput>, userUncheckedUpdateWithoutStudentInput>
  }

  export type teamapplicationUpdateManyWithoutStudentNestedInput = {
    create?: XOR<teamapplicationCreateWithoutStudentInput, teamapplicationUncheckedCreateWithoutStudentInput> | teamapplicationCreateWithoutStudentInput[] | teamapplicationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: teamapplicationCreateOrConnectWithoutStudentInput | teamapplicationCreateOrConnectWithoutStudentInput[]
    upsert?: teamapplicationUpsertWithWhereUniqueWithoutStudentInput | teamapplicationUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: teamapplicationCreateManyStudentInputEnvelope
    set?: teamapplicationWhereUniqueInput | teamapplicationWhereUniqueInput[]
    disconnect?: teamapplicationWhereUniqueInput | teamapplicationWhereUniqueInput[]
    delete?: teamapplicationWhereUniqueInput | teamapplicationWhereUniqueInput[]
    connect?: teamapplicationWhereUniqueInput | teamapplicationWhereUniqueInput[]
    update?: teamapplicationUpdateWithWhereUniqueWithoutStudentInput | teamapplicationUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: teamapplicationUpdateManyWithWhereWithoutStudentInput | teamapplicationUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: teamapplicationScalarWhereInput | teamapplicationScalarWhereInput[]
  }

  export type teamapplicationUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<teamapplicationCreateWithoutStudentInput, teamapplicationUncheckedCreateWithoutStudentInput> | teamapplicationCreateWithoutStudentInput[] | teamapplicationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: teamapplicationCreateOrConnectWithoutStudentInput | teamapplicationCreateOrConnectWithoutStudentInput[]
    upsert?: teamapplicationUpsertWithWhereUniqueWithoutStudentInput | teamapplicationUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: teamapplicationCreateManyStudentInputEnvelope
    set?: teamapplicationWhereUniqueInput | teamapplicationWhereUniqueInput[]
    disconnect?: teamapplicationWhereUniqueInput | teamapplicationWhereUniqueInput[]
    delete?: teamapplicationWhereUniqueInput | teamapplicationWhereUniqueInput[]
    connect?: teamapplicationWhereUniqueInput | teamapplicationWhereUniqueInput[]
    update?: teamapplicationUpdateWithWhereUniqueWithoutStudentInput | teamapplicationUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: teamapplicationUpdateManyWithWhereWithoutStudentInput | teamapplicationUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: teamapplicationScalarWhereInput | teamapplicationScalarWhereInput[]
  }

  export type paperCreateNestedManyWithoutTeacherInput = {
    create?: XOR<paperCreateWithoutTeacherInput, paperUncheckedCreateWithoutTeacherInput> | paperCreateWithoutTeacherInput[] | paperUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: paperCreateOrConnectWithoutTeacherInput | paperCreateOrConnectWithoutTeacherInput[]
    createMany?: paperCreateManyTeacherInputEnvelope
    connect?: paperWhereUniqueInput | paperWhereUniqueInput[]
  }

  export type proposalCreateNestedManyWithoutTeacherInput = {
    create?: XOR<proposalCreateWithoutTeacherInput, proposalUncheckedCreateWithoutTeacherInput> | proposalCreateWithoutTeacherInput[] | proposalUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: proposalCreateOrConnectWithoutTeacherInput | proposalCreateOrConnectWithoutTeacherInput[]
    createMany?: proposalCreateManyTeacherInputEnvelope
    connect?: proposalWhereUniqueInput | proposalWhereUniqueInput[]
  }

  export type reviewerCreateNestedOneWithoutTeacherInput = {
    create?: XOR<reviewerCreateWithoutTeacherInput, reviewerUncheckedCreateWithoutTeacherInput>
    connectOrCreate?: reviewerCreateOrConnectWithoutTeacherInput
    connect?: reviewerWhereUniqueInput
  }

  export type departmentCreateNestedOneWithoutTeachersInput = {
    create?: XOR<departmentCreateWithoutTeachersInput, departmentUncheckedCreateWithoutTeachersInput>
    connectOrCreate?: departmentCreateOrConnectWithoutTeachersInput
    connect?: departmentWhereUniqueInput
  }

  export type userCreateNestedOneWithoutTeacherInput = {
    create?: XOR<userCreateWithoutTeacherInput, userUncheckedCreateWithoutTeacherInput>
    connectOrCreate?: userCreateOrConnectWithoutTeacherInput
    connect?: userWhereUniqueInput
  }

  export type paperUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<paperCreateWithoutTeacherInput, paperUncheckedCreateWithoutTeacherInput> | paperCreateWithoutTeacherInput[] | paperUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: paperCreateOrConnectWithoutTeacherInput | paperCreateOrConnectWithoutTeacherInput[]
    createMany?: paperCreateManyTeacherInputEnvelope
    connect?: paperWhereUniqueInput | paperWhereUniqueInput[]
  }

  export type proposalUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<proposalCreateWithoutTeacherInput, proposalUncheckedCreateWithoutTeacherInput> | proposalCreateWithoutTeacherInput[] | proposalUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: proposalCreateOrConnectWithoutTeacherInput | proposalCreateOrConnectWithoutTeacherInput[]
    createMany?: proposalCreateManyTeacherInputEnvelope
    connect?: proposalWhereUniqueInput | proposalWhereUniqueInput[]
  }

  export type reviewerUncheckedCreateNestedOneWithoutTeacherInput = {
    create?: XOR<reviewerCreateWithoutTeacherInput, reviewerUncheckedCreateWithoutTeacherInput>
    connectOrCreate?: reviewerCreateOrConnectWithoutTeacherInput
    connect?: reviewerWhereUniqueInput
  }

  export type paperUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<paperCreateWithoutTeacherInput, paperUncheckedCreateWithoutTeacherInput> | paperCreateWithoutTeacherInput[] | paperUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: paperCreateOrConnectWithoutTeacherInput | paperCreateOrConnectWithoutTeacherInput[]
    upsert?: paperUpsertWithWhereUniqueWithoutTeacherInput | paperUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: paperCreateManyTeacherInputEnvelope
    set?: paperWhereUniqueInput | paperWhereUniqueInput[]
    disconnect?: paperWhereUniqueInput | paperWhereUniqueInput[]
    delete?: paperWhereUniqueInput | paperWhereUniqueInput[]
    connect?: paperWhereUniqueInput | paperWhereUniqueInput[]
    update?: paperUpdateWithWhereUniqueWithoutTeacherInput | paperUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: paperUpdateManyWithWhereWithoutTeacherInput | paperUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: paperScalarWhereInput | paperScalarWhereInput[]
  }

  export type proposalUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<proposalCreateWithoutTeacherInput, proposalUncheckedCreateWithoutTeacherInput> | proposalCreateWithoutTeacherInput[] | proposalUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: proposalCreateOrConnectWithoutTeacherInput | proposalCreateOrConnectWithoutTeacherInput[]
    upsert?: proposalUpsertWithWhereUniqueWithoutTeacherInput | proposalUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: proposalCreateManyTeacherInputEnvelope
    set?: proposalWhereUniqueInput | proposalWhereUniqueInput[]
    disconnect?: proposalWhereUniqueInput | proposalWhereUniqueInput[]
    delete?: proposalWhereUniqueInput | proposalWhereUniqueInput[]
    connect?: proposalWhereUniqueInput | proposalWhereUniqueInput[]
    update?: proposalUpdateWithWhereUniqueWithoutTeacherInput | proposalUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: proposalUpdateManyWithWhereWithoutTeacherInput | proposalUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: proposalScalarWhereInput | proposalScalarWhereInput[]
  }

  export type reviewerUpdateOneWithoutTeacherNestedInput = {
    create?: XOR<reviewerCreateWithoutTeacherInput, reviewerUncheckedCreateWithoutTeacherInput>
    connectOrCreate?: reviewerCreateOrConnectWithoutTeacherInput
    upsert?: reviewerUpsertWithoutTeacherInput
    disconnect?: reviewerWhereInput | boolean
    delete?: reviewerWhereInput | boolean
    connect?: reviewerWhereUniqueInput
    update?: XOR<XOR<reviewerUpdateToOneWithWhereWithoutTeacherInput, reviewerUpdateWithoutTeacherInput>, reviewerUncheckedUpdateWithoutTeacherInput>
  }

  export type departmentUpdateOneWithoutTeachersNestedInput = {
    create?: XOR<departmentCreateWithoutTeachersInput, departmentUncheckedCreateWithoutTeachersInput>
    connectOrCreate?: departmentCreateOrConnectWithoutTeachersInput
    upsert?: departmentUpsertWithoutTeachersInput
    disconnect?: departmentWhereInput | boolean
    delete?: departmentWhereInput | boolean
    connect?: departmentWhereUniqueInput
    update?: XOR<XOR<departmentUpdateToOneWithWhereWithoutTeachersInput, departmentUpdateWithoutTeachersInput>, departmentUncheckedUpdateWithoutTeachersInput>
  }

  export type userUpdateOneWithoutTeacherNestedInput = {
    create?: XOR<userCreateWithoutTeacherInput, userUncheckedCreateWithoutTeacherInput>
    connectOrCreate?: userCreateOrConnectWithoutTeacherInput
    upsert?: userUpsertWithoutTeacherInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutTeacherInput, userUpdateWithoutTeacherInput>, userUncheckedUpdateWithoutTeacherInput>
  }

  export type paperUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<paperCreateWithoutTeacherInput, paperUncheckedCreateWithoutTeacherInput> | paperCreateWithoutTeacherInput[] | paperUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: paperCreateOrConnectWithoutTeacherInput | paperCreateOrConnectWithoutTeacherInput[]
    upsert?: paperUpsertWithWhereUniqueWithoutTeacherInput | paperUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: paperCreateManyTeacherInputEnvelope
    set?: paperWhereUniqueInput | paperWhereUniqueInput[]
    disconnect?: paperWhereUniqueInput | paperWhereUniqueInput[]
    delete?: paperWhereUniqueInput | paperWhereUniqueInput[]
    connect?: paperWhereUniqueInput | paperWhereUniqueInput[]
    update?: paperUpdateWithWhereUniqueWithoutTeacherInput | paperUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: paperUpdateManyWithWhereWithoutTeacherInput | paperUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: paperScalarWhereInput | paperScalarWhereInput[]
  }

  export type proposalUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<proposalCreateWithoutTeacherInput, proposalUncheckedCreateWithoutTeacherInput> | proposalCreateWithoutTeacherInput[] | proposalUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: proposalCreateOrConnectWithoutTeacherInput | proposalCreateOrConnectWithoutTeacherInput[]
    upsert?: proposalUpsertWithWhereUniqueWithoutTeacherInput | proposalUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: proposalCreateManyTeacherInputEnvelope
    set?: proposalWhereUniqueInput | proposalWhereUniqueInput[]
    disconnect?: proposalWhereUniqueInput | proposalWhereUniqueInput[]
    delete?: proposalWhereUniqueInput | proposalWhereUniqueInput[]
    connect?: proposalWhereUniqueInput | proposalWhereUniqueInput[]
    update?: proposalUpdateWithWhereUniqueWithoutTeacherInput | proposalUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: proposalUpdateManyWithWhereWithoutTeacherInput | proposalUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: proposalScalarWhereInput | proposalScalarWhereInput[]
  }

  export type reviewerUncheckedUpdateOneWithoutTeacherNestedInput = {
    create?: XOR<reviewerCreateWithoutTeacherInput, reviewerUncheckedCreateWithoutTeacherInput>
    connectOrCreate?: reviewerCreateOrConnectWithoutTeacherInput
    upsert?: reviewerUpsertWithoutTeacherInput
    disconnect?: reviewerWhereInput | boolean
    delete?: reviewerWhereInput | boolean
    connect?: reviewerWhereUniqueInput
    update?: XOR<XOR<reviewerUpdateToOneWithWhereWithoutTeacherInput, reviewerUpdateWithoutTeacherInput>, reviewerUncheckedUpdateWithoutTeacherInput>
  }

  export type reviewCreateNestedManyWithoutReviewerInput = {
    create?: XOR<reviewCreateWithoutReviewerInput, reviewUncheckedCreateWithoutReviewerInput> | reviewCreateWithoutReviewerInput[] | reviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: reviewCreateOrConnectWithoutReviewerInput | reviewCreateOrConnectWithoutReviewerInput[]
    createMany?: reviewCreateManyReviewerInputEnvelope
    connect?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
  }

  export type teacherCreateNestedOneWithoutReviewerInput = {
    create?: XOR<teacherCreateWithoutReviewerInput, teacherUncheckedCreateWithoutReviewerInput>
    connectOrCreate?: teacherCreateOrConnectWithoutReviewerInput
    connect?: teacherWhereUniqueInput
  }

  export type reviewerassignmentCreateNestedManyWithoutReviewerInput = {
    create?: XOR<reviewerassignmentCreateWithoutReviewerInput, reviewerassignmentUncheckedCreateWithoutReviewerInput> | reviewerassignmentCreateWithoutReviewerInput[] | reviewerassignmentUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: reviewerassignmentCreateOrConnectWithoutReviewerInput | reviewerassignmentCreateOrConnectWithoutReviewerInput[]
    createMany?: reviewerassignmentCreateManyReviewerInputEnvelope
    connect?: reviewerassignmentWhereUniqueInput | reviewerassignmentWhereUniqueInput[]
  }

  export type reviewUncheckedCreateNestedManyWithoutReviewerInput = {
    create?: XOR<reviewCreateWithoutReviewerInput, reviewUncheckedCreateWithoutReviewerInput> | reviewCreateWithoutReviewerInput[] | reviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: reviewCreateOrConnectWithoutReviewerInput | reviewCreateOrConnectWithoutReviewerInput[]
    createMany?: reviewCreateManyReviewerInputEnvelope
    connect?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
  }

  export type reviewerassignmentUncheckedCreateNestedManyWithoutReviewerInput = {
    create?: XOR<reviewerassignmentCreateWithoutReviewerInput, reviewerassignmentUncheckedCreateWithoutReviewerInput> | reviewerassignmentCreateWithoutReviewerInput[] | reviewerassignmentUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: reviewerassignmentCreateOrConnectWithoutReviewerInput | reviewerassignmentCreateOrConnectWithoutReviewerInput[]
    createMany?: reviewerassignmentCreateManyReviewerInputEnvelope
    connect?: reviewerassignmentWhereUniqueInput | reviewerassignmentWhereUniqueInput[]
  }

  export type NullableEnumReviewerStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReviewerStatus | null
  }

  export type reviewUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<reviewCreateWithoutReviewerInput, reviewUncheckedCreateWithoutReviewerInput> | reviewCreateWithoutReviewerInput[] | reviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: reviewCreateOrConnectWithoutReviewerInput | reviewCreateOrConnectWithoutReviewerInput[]
    upsert?: reviewUpsertWithWhereUniqueWithoutReviewerInput | reviewUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: reviewCreateManyReviewerInputEnvelope
    set?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
    disconnect?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
    delete?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
    connect?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
    update?: reviewUpdateWithWhereUniqueWithoutReviewerInput | reviewUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: reviewUpdateManyWithWhereWithoutReviewerInput | reviewUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: reviewScalarWhereInput | reviewScalarWhereInput[]
  }

  export type teacherUpdateOneWithoutReviewerNestedInput = {
    create?: XOR<teacherCreateWithoutReviewerInput, teacherUncheckedCreateWithoutReviewerInput>
    connectOrCreate?: teacherCreateOrConnectWithoutReviewerInput
    upsert?: teacherUpsertWithoutReviewerInput
    disconnect?: teacherWhereInput | boolean
    delete?: teacherWhereInput | boolean
    connect?: teacherWhereUniqueInput
    update?: XOR<XOR<teacherUpdateToOneWithWhereWithoutReviewerInput, teacherUpdateWithoutReviewerInput>, teacherUncheckedUpdateWithoutReviewerInput>
  }

  export type reviewerassignmentUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<reviewerassignmentCreateWithoutReviewerInput, reviewerassignmentUncheckedCreateWithoutReviewerInput> | reviewerassignmentCreateWithoutReviewerInput[] | reviewerassignmentUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: reviewerassignmentCreateOrConnectWithoutReviewerInput | reviewerassignmentCreateOrConnectWithoutReviewerInput[]
    upsert?: reviewerassignmentUpsertWithWhereUniqueWithoutReviewerInput | reviewerassignmentUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: reviewerassignmentCreateManyReviewerInputEnvelope
    set?: reviewerassignmentWhereUniqueInput | reviewerassignmentWhereUniqueInput[]
    disconnect?: reviewerassignmentWhereUniqueInput | reviewerassignmentWhereUniqueInput[]
    delete?: reviewerassignmentWhereUniqueInput | reviewerassignmentWhereUniqueInput[]
    connect?: reviewerassignmentWhereUniqueInput | reviewerassignmentWhereUniqueInput[]
    update?: reviewerassignmentUpdateWithWhereUniqueWithoutReviewerInput | reviewerassignmentUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: reviewerassignmentUpdateManyWithWhereWithoutReviewerInput | reviewerassignmentUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: reviewerassignmentScalarWhereInput | reviewerassignmentScalarWhereInput[]
  }

  export type reviewUncheckedUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<reviewCreateWithoutReviewerInput, reviewUncheckedCreateWithoutReviewerInput> | reviewCreateWithoutReviewerInput[] | reviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: reviewCreateOrConnectWithoutReviewerInput | reviewCreateOrConnectWithoutReviewerInput[]
    upsert?: reviewUpsertWithWhereUniqueWithoutReviewerInput | reviewUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: reviewCreateManyReviewerInputEnvelope
    set?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
    disconnect?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
    delete?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
    connect?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
    update?: reviewUpdateWithWhereUniqueWithoutReviewerInput | reviewUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: reviewUpdateManyWithWhereWithoutReviewerInput | reviewUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: reviewScalarWhereInput | reviewScalarWhereInput[]
  }

  export type reviewerassignmentUncheckedUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<reviewerassignmentCreateWithoutReviewerInput, reviewerassignmentUncheckedCreateWithoutReviewerInput> | reviewerassignmentCreateWithoutReviewerInput[] | reviewerassignmentUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: reviewerassignmentCreateOrConnectWithoutReviewerInput | reviewerassignmentCreateOrConnectWithoutReviewerInput[]
    upsert?: reviewerassignmentUpsertWithWhereUniqueWithoutReviewerInput | reviewerassignmentUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: reviewerassignmentCreateManyReviewerInputEnvelope
    set?: reviewerassignmentWhereUniqueInput | reviewerassignmentWhereUniqueInput[]
    disconnect?: reviewerassignmentWhereUniqueInput | reviewerassignmentWhereUniqueInput[]
    delete?: reviewerassignmentWhereUniqueInput | reviewerassignmentWhereUniqueInput[]
    connect?: reviewerassignmentWhereUniqueInput | reviewerassignmentWhereUniqueInput[]
    update?: reviewerassignmentUpdateWithWhereUniqueWithoutReviewerInput | reviewerassignmentUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: reviewerassignmentUpdateManyWithWhereWithoutReviewerInput | reviewerassignmentUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: reviewerassignmentScalarWhereInput | reviewerassignmentScalarWhereInput[]
  }

  export type paperCreateNestedManyWithoutTeamInput = {
    create?: XOR<paperCreateWithoutTeamInput, paperUncheckedCreateWithoutTeamInput> | paperCreateWithoutTeamInput[] | paperUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: paperCreateOrConnectWithoutTeamInput | paperCreateOrConnectWithoutTeamInput[]
    createMany?: paperCreateManyTeamInputEnvelope
    connect?: paperWhereUniqueInput | paperWhereUniqueInput[]
  }

  export type proposalCreateNestedManyWithoutTeamInput = {
    create?: XOR<proposalCreateWithoutTeamInput, proposalUncheckedCreateWithoutTeamInput> | proposalCreateWithoutTeamInput[] | proposalUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: proposalCreateOrConnectWithoutTeamInput | proposalCreateOrConnectWithoutTeamInput[]
    createMany?: proposalCreateManyTeamInputEnvelope
    connect?: proposalWhereUniqueInput | proposalWhereUniqueInput[]
  }

  export type userCreateNestedOneWithoutTeamInput = {
    create?: XOR<userCreateWithoutTeamInput, userUncheckedCreateWithoutTeamInput>
    connectOrCreate?: userCreateOrConnectWithoutTeamInput
    connect?: userWhereUniqueInput
  }

  export type domainCreateNestedOneWithoutTeamInput = {
    create?: XOR<domainCreateWithoutTeamInput, domainUncheckedCreateWithoutTeamInput>
    connectOrCreate?: domainCreateOrConnectWithoutTeamInput
    connect?: domainWhereUniqueInput
  }

  export type teamapplicationCreateNestedManyWithoutTeamInput = {
    create?: XOR<teamapplicationCreateWithoutTeamInput, teamapplicationUncheckedCreateWithoutTeamInput> | teamapplicationCreateWithoutTeamInput[] | teamapplicationUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: teamapplicationCreateOrConnectWithoutTeamInput | teamapplicationCreateOrConnectWithoutTeamInput[]
    createMany?: teamapplicationCreateManyTeamInputEnvelope
    connect?: teamapplicationWhereUniqueInput | teamapplicationWhereUniqueInput[]
  }

  export type teamcommentCreateNestedManyWithoutTeamInput = {
    create?: XOR<teamcommentCreateWithoutTeamInput, teamcommentUncheckedCreateWithoutTeamInput> | teamcommentCreateWithoutTeamInput[] | teamcommentUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: teamcommentCreateOrConnectWithoutTeamInput | teamcommentCreateOrConnectWithoutTeamInput[]
    createMany?: teamcommentCreateManyTeamInputEnvelope
    connect?: teamcommentWhereUniqueInput | teamcommentWhereUniqueInput[]
  }

  export type teammemberCreateNestedManyWithoutTeamInput = {
    create?: XOR<teammemberCreateWithoutTeamInput, teammemberUncheckedCreateWithoutTeamInput> | teammemberCreateWithoutTeamInput[] | teammemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: teammemberCreateOrConnectWithoutTeamInput | teammemberCreateOrConnectWithoutTeamInput[]
    createMany?: teammemberCreateManyTeamInputEnvelope
    connect?: teammemberWhereUniqueInput | teammemberWhereUniqueInput[]
  }

  export type paperUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<paperCreateWithoutTeamInput, paperUncheckedCreateWithoutTeamInput> | paperCreateWithoutTeamInput[] | paperUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: paperCreateOrConnectWithoutTeamInput | paperCreateOrConnectWithoutTeamInput[]
    createMany?: paperCreateManyTeamInputEnvelope
    connect?: paperWhereUniqueInput | paperWhereUniqueInput[]
  }

  export type proposalUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<proposalCreateWithoutTeamInput, proposalUncheckedCreateWithoutTeamInput> | proposalCreateWithoutTeamInput[] | proposalUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: proposalCreateOrConnectWithoutTeamInput | proposalCreateOrConnectWithoutTeamInput[]
    createMany?: proposalCreateManyTeamInputEnvelope
    connect?: proposalWhereUniqueInput | proposalWhereUniqueInput[]
  }

  export type teamapplicationUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<teamapplicationCreateWithoutTeamInput, teamapplicationUncheckedCreateWithoutTeamInput> | teamapplicationCreateWithoutTeamInput[] | teamapplicationUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: teamapplicationCreateOrConnectWithoutTeamInput | teamapplicationCreateOrConnectWithoutTeamInput[]
    createMany?: teamapplicationCreateManyTeamInputEnvelope
    connect?: teamapplicationWhereUniqueInput | teamapplicationWhereUniqueInput[]
  }

  export type teamcommentUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<teamcommentCreateWithoutTeamInput, teamcommentUncheckedCreateWithoutTeamInput> | teamcommentCreateWithoutTeamInput[] | teamcommentUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: teamcommentCreateOrConnectWithoutTeamInput | teamcommentCreateOrConnectWithoutTeamInput[]
    createMany?: teamcommentCreateManyTeamInputEnvelope
    connect?: teamcommentWhereUniqueInput | teamcommentWhereUniqueInput[]
  }

  export type teammemberUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<teammemberCreateWithoutTeamInput, teammemberUncheckedCreateWithoutTeamInput> | teammemberCreateWithoutTeamInput[] | teammemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: teammemberCreateOrConnectWithoutTeamInput | teammemberCreateOrConnectWithoutTeamInput[]
    createMany?: teammemberCreateManyTeamInputEnvelope
    connect?: teammemberWhereUniqueInput | teammemberWhereUniqueInput[]
  }

  export type NullableEnumTeamStatusFieldUpdateOperationsInput = {
    set?: $Enums.TeamStatus | null
  }

  export type NullableEnumTeamVisibilityFieldUpdateOperationsInput = {
    set?: $Enums.TeamVisibility | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type paperUpdateManyWithoutTeamNestedInput = {
    create?: XOR<paperCreateWithoutTeamInput, paperUncheckedCreateWithoutTeamInput> | paperCreateWithoutTeamInput[] | paperUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: paperCreateOrConnectWithoutTeamInput | paperCreateOrConnectWithoutTeamInput[]
    upsert?: paperUpsertWithWhereUniqueWithoutTeamInput | paperUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: paperCreateManyTeamInputEnvelope
    set?: paperWhereUniqueInput | paperWhereUniqueInput[]
    disconnect?: paperWhereUniqueInput | paperWhereUniqueInput[]
    delete?: paperWhereUniqueInput | paperWhereUniqueInput[]
    connect?: paperWhereUniqueInput | paperWhereUniqueInput[]
    update?: paperUpdateWithWhereUniqueWithoutTeamInput | paperUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: paperUpdateManyWithWhereWithoutTeamInput | paperUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: paperScalarWhereInput | paperScalarWhereInput[]
  }

  export type proposalUpdateManyWithoutTeamNestedInput = {
    create?: XOR<proposalCreateWithoutTeamInput, proposalUncheckedCreateWithoutTeamInput> | proposalCreateWithoutTeamInput[] | proposalUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: proposalCreateOrConnectWithoutTeamInput | proposalCreateOrConnectWithoutTeamInput[]
    upsert?: proposalUpsertWithWhereUniqueWithoutTeamInput | proposalUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: proposalCreateManyTeamInputEnvelope
    set?: proposalWhereUniqueInput | proposalWhereUniqueInput[]
    disconnect?: proposalWhereUniqueInput | proposalWhereUniqueInput[]
    delete?: proposalWhereUniqueInput | proposalWhereUniqueInput[]
    connect?: proposalWhereUniqueInput | proposalWhereUniqueInput[]
    update?: proposalUpdateWithWhereUniqueWithoutTeamInput | proposalUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: proposalUpdateManyWithWhereWithoutTeamInput | proposalUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: proposalScalarWhereInput | proposalScalarWhereInput[]
  }

  export type userUpdateOneWithoutTeamNestedInput = {
    create?: XOR<userCreateWithoutTeamInput, userUncheckedCreateWithoutTeamInput>
    connectOrCreate?: userCreateOrConnectWithoutTeamInput
    upsert?: userUpsertWithoutTeamInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutTeamInput, userUpdateWithoutTeamInput>, userUncheckedUpdateWithoutTeamInput>
  }

  export type domainUpdateOneWithoutTeamNestedInput = {
    create?: XOR<domainCreateWithoutTeamInput, domainUncheckedCreateWithoutTeamInput>
    connectOrCreate?: domainCreateOrConnectWithoutTeamInput
    upsert?: domainUpsertWithoutTeamInput
    disconnect?: domainWhereInput | boolean
    delete?: domainWhereInput | boolean
    connect?: domainWhereUniqueInput
    update?: XOR<XOR<domainUpdateToOneWithWhereWithoutTeamInput, domainUpdateWithoutTeamInput>, domainUncheckedUpdateWithoutTeamInput>
  }

  export type teamapplicationUpdateManyWithoutTeamNestedInput = {
    create?: XOR<teamapplicationCreateWithoutTeamInput, teamapplicationUncheckedCreateWithoutTeamInput> | teamapplicationCreateWithoutTeamInput[] | teamapplicationUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: teamapplicationCreateOrConnectWithoutTeamInput | teamapplicationCreateOrConnectWithoutTeamInput[]
    upsert?: teamapplicationUpsertWithWhereUniqueWithoutTeamInput | teamapplicationUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: teamapplicationCreateManyTeamInputEnvelope
    set?: teamapplicationWhereUniqueInput | teamapplicationWhereUniqueInput[]
    disconnect?: teamapplicationWhereUniqueInput | teamapplicationWhereUniqueInput[]
    delete?: teamapplicationWhereUniqueInput | teamapplicationWhereUniqueInput[]
    connect?: teamapplicationWhereUniqueInput | teamapplicationWhereUniqueInput[]
    update?: teamapplicationUpdateWithWhereUniqueWithoutTeamInput | teamapplicationUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: teamapplicationUpdateManyWithWhereWithoutTeamInput | teamapplicationUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: teamapplicationScalarWhereInput | teamapplicationScalarWhereInput[]
  }

  export type teamcommentUpdateManyWithoutTeamNestedInput = {
    create?: XOR<teamcommentCreateWithoutTeamInput, teamcommentUncheckedCreateWithoutTeamInput> | teamcommentCreateWithoutTeamInput[] | teamcommentUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: teamcommentCreateOrConnectWithoutTeamInput | teamcommentCreateOrConnectWithoutTeamInput[]
    upsert?: teamcommentUpsertWithWhereUniqueWithoutTeamInput | teamcommentUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: teamcommentCreateManyTeamInputEnvelope
    set?: teamcommentWhereUniqueInput | teamcommentWhereUniqueInput[]
    disconnect?: teamcommentWhereUniqueInput | teamcommentWhereUniqueInput[]
    delete?: teamcommentWhereUniqueInput | teamcommentWhereUniqueInput[]
    connect?: teamcommentWhereUniqueInput | teamcommentWhereUniqueInput[]
    update?: teamcommentUpdateWithWhereUniqueWithoutTeamInput | teamcommentUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: teamcommentUpdateManyWithWhereWithoutTeamInput | teamcommentUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: teamcommentScalarWhereInput | teamcommentScalarWhereInput[]
  }

  export type teammemberUpdateManyWithoutTeamNestedInput = {
    create?: XOR<teammemberCreateWithoutTeamInput, teammemberUncheckedCreateWithoutTeamInput> | teammemberCreateWithoutTeamInput[] | teammemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: teammemberCreateOrConnectWithoutTeamInput | teammemberCreateOrConnectWithoutTeamInput[]
    upsert?: teammemberUpsertWithWhereUniqueWithoutTeamInput | teammemberUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: teammemberCreateManyTeamInputEnvelope
    set?: teammemberWhereUniqueInput | teammemberWhereUniqueInput[]
    disconnect?: teammemberWhereUniqueInput | teammemberWhereUniqueInput[]
    delete?: teammemberWhereUniqueInput | teammemberWhereUniqueInput[]
    connect?: teammemberWhereUniqueInput | teammemberWhereUniqueInput[]
    update?: teammemberUpdateWithWhereUniqueWithoutTeamInput | teammemberUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: teammemberUpdateManyWithWhereWithoutTeamInput | teammemberUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: teammemberScalarWhereInput | teammemberScalarWhereInput[]
  }

  export type paperUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<paperCreateWithoutTeamInput, paperUncheckedCreateWithoutTeamInput> | paperCreateWithoutTeamInput[] | paperUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: paperCreateOrConnectWithoutTeamInput | paperCreateOrConnectWithoutTeamInput[]
    upsert?: paperUpsertWithWhereUniqueWithoutTeamInput | paperUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: paperCreateManyTeamInputEnvelope
    set?: paperWhereUniqueInput | paperWhereUniqueInput[]
    disconnect?: paperWhereUniqueInput | paperWhereUniqueInput[]
    delete?: paperWhereUniqueInput | paperWhereUniqueInput[]
    connect?: paperWhereUniqueInput | paperWhereUniqueInput[]
    update?: paperUpdateWithWhereUniqueWithoutTeamInput | paperUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: paperUpdateManyWithWhereWithoutTeamInput | paperUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: paperScalarWhereInput | paperScalarWhereInput[]
  }

  export type proposalUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<proposalCreateWithoutTeamInput, proposalUncheckedCreateWithoutTeamInput> | proposalCreateWithoutTeamInput[] | proposalUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: proposalCreateOrConnectWithoutTeamInput | proposalCreateOrConnectWithoutTeamInput[]
    upsert?: proposalUpsertWithWhereUniqueWithoutTeamInput | proposalUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: proposalCreateManyTeamInputEnvelope
    set?: proposalWhereUniqueInput | proposalWhereUniqueInput[]
    disconnect?: proposalWhereUniqueInput | proposalWhereUniqueInput[]
    delete?: proposalWhereUniqueInput | proposalWhereUniqueInput[]
    connect?: proposalWhereUniqueInput | proposalWhereUniqueInput[]
    update?: proposalUpdateWithWhereUniqueWithoutTeamInput | proposalUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: proposalUpdateManyWithWhereWithoutTeamInput | proposalUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: proposalScalarWhereInput | proposalScalarWhereInput[]
  }

  export type teamapplicationUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<teamapplicationCreateWithoutTeamInput, teamapplicationUncheckedCreateWithoutTeamInput> | teamapplicationCreateWithoutTeamInput[] | teamapplicationUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: teamapplicationCreateOrConnectWithoutTeamInput | teamapplicationCreateOrConnectWithoutTeamInput[]
    upsert?: teamapplicationUpsertWithWhereUniqueWithoutTeamInput | teamapplicationUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: teamapplicationCreateManyTeamInputEnvelope
    set?: teamapplicationWhereUniqueInput | teamapplicationWhereUniqueInput[]
    disconnect?: teamapplicationWhereUniqueInput | teamapplicationWhereUniqueInput[]
    delete?: teamapplicationWhereUniqueInput | teamapplicationWhereUniqueInput[]
    connect?: teamapplicationWhereUniqueInput | teamapplicationWhereUniqueInput[]
    update?: teamapplicationUpdateWithWhereUniqueWithoutTeamInput | teamapplicationUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: teamapplicationUpdateManyWithWhereWithoutTeamInput | teamapplicationUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: teamapplicationScalarWhereInput | teamapplicationScalarWhereInput[]
  }

  export type teamcommentUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<teamcommentCreateWithoutTeamInput, teamcommentUncheckedCreateWithoutTeamInput> | teamcommentCreateWithoutTeamInput[] | teamcommentUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: teamcommentCreateOrConnectWithoutTeamInput | teamcommentCreateOrConnectWithoutTeamInput[]
    upsert?: teamcommentUpsertWithWhereUniqueWithoutTeamInput | teamcommentUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: teamcommentCreateManyTeamInputEnvelope
    set?: teamcommentWhereUniqueInput | teamcommentWhereUniqueInput[]
    disconnect?: teamcommentWhereUniqueInput | teamcommentWhereUniqueInput[]
    delete?: teamcommentWhereUniqueInput | teamcommentWhereUniqueInput[]
    connect?: teamcommentWhereUniqueInput | teamcommentWhereUniqueInput[]
    update?: teamcommentUpdateWithWhereUniqueWithoutTeamInput | teamcommentUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: teamcommentUpdateManyWithWhereWithoutTeamInput | teamcommentUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: teamcommentScalarWhereInput | teamcommentScalarWhereInput[]
  }

  export type teammemberUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<teammemberCreateWithoutTeamInput, teammemberUncheckedCreateWithoutTeamInput> | teammemberCreateWithoutTeamInput[] | teammemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: teammemberCreateOrConnectWithoutTeamInput | teammemberCreateOrConnectWithoutTeamInput[]
    upsert?: teammemberUpsertWithWhereUniqueWithoutTeamInput | teammemberUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: teammemberCreateManyTeamInputEnvelope
    set?: teammemberWhereUniqueInput | teammemberWhereUniqueInput[]
    disconnect?: teammemberWhereUniqueInput | teammemberWhereUniqueInput[]
    delete?: teammemberWhereUniqueInput | teammemberWhereUniqueInput[]
    connect?: teammemberWhereUniqueInput | teammemberWhereUniqueInput[]
    update?: teammemberUpdateWithWhereUniqueWithoutTeamInput | teammemberUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: teammemberUpdateManyWithWhereWithoutTeamInput | teammemberUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: teammemberScalarWhereInput | teammemberScalarWhereInput[]
  }

  export type teamCreateNestedOneWithoutTeammemberInput = {
    create?: XOR<teamCreateWithoutTeammemberInput, teamUncheckedCreateWithoutTeammemberInput>
    connectOrCreate?: teamCreateOrConnectWithoutTeammemberInput
    connect?: teamWhereUniqueInput
  }

  export type userCreateNestedOneWithoutTeammemberInput = {
    create?: XOR<userCreateWithoutTeammemberInput, userUncheckedCreateWithoutTeammemberInput>
    connectOrCreate?: userCreateOrConnectWithoutTeammemberInput
    connect?: userWhereUniqueInput
  }

  export type NullableEnumTeamRoleFieldUpdateOperationsInput = {
    set?: $Enums.TeamRole | null
  }

  export type teamUpdateOneRequiredWithoutTeammemberNestedInput = {
    create?: XOR<teamCreateWithoutTeammemberInput, teamUncheckedCreateWithoutTeammemberInput>
    connectOrCreate?: teamCreateOrConnectWithoutTeammemberInput
    upsert?: teamUpsertWithoutTeammemberInput
    connect?: teamWhereUniqueInput
    update?: XOR<XOR<teamUpdateToOneWithWhereWithoutTeammemberInput, teamUpdateWithoutTeammemberInput>, teamUncheckedUpdateWithoutTeammemberInput>
  }

  export type userUpdateOneRequiredWithoutTeammemberNestedInput = {
    create?: XOR<userCreateWithoutTeammemberInput, userUncheckedCreateWithoutTeammemberInput>
    connectOrCreate?: userCreateOrConnectWithoutTeammemberInput
    upsert?: userUpsertWithoutTeammemberInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutTeammemberInput, userUpdateWithoutTeammemberInput>, userUncheckedUpdateWithoutTeammemberInput>
  }

  export type studentCreateNestedOneWithoutTeamapplicationInput = {
    create?: XOR<studentCreateWithoutTeamapplicationInput, studentUncheckedCreateWithoutTeamapplicationInput>
    connectOrCreate?: studentCreateOrConnectWithoutTeamapplicationInput
    connect?: studentWhereUniqueInput
  }

  export type teamCreateNestedOneWithoutTeamapplicationInput = {
    create?: XOR<teamCreateWithoutTeamapplicationInput, teamUncheckedCreateWithoutTeamapplicationInput>
    connectOrCreate?: teamCreateOrConnectWithoutTeamapplicationInput
    connect?: teamWhereUniqueInput
  }

  export type EnumApplicationStatusFieldUpdateOperationsInput = {
    set?: $Enums.ApplicationStatus
  }

  export type studentUpdateOneRequiredWithoutTeamapplicationNestedInput = {
    create?: XOR<studentCreateWithoutTeamapplicationInput, studentUncheckedCreateWithoutTeamapplicationInput>
    connectOrCreate?: studentCreateOrConnectWithoutTeamapplicationInput
    upsert?: studentUpsertWithoutTeamapplicationInput
    connect?: studentWhereUniqueInput
    update?: XOR<XOR<studentUpdateToOneWithWhereWithoutTeamapplicationInput, studentUpdateWithoutTeamapplicationInput>, studentUncheckedUpdateWithoutTeamapplicationInput>
  }

  export type teamUpdateOneRequiredWithoutTeamapplicationNestedInput = {
    create?: XOR<teamCreateWithoutTeamapplicationInput, teamUncheckedCreateWithoutTeamapplicationInput>
    connectOrCreate?: teamCreateOrConnectWithoutTeamapplicationInput
    upsert?: teamUpsertWithoutTeamapplicationInput
    connect?: teamWhereUniqueInput
    update?: XOR<XOR<teamUpdateToOneWithWhereWithoutTeamapplicationInput, teamUpdateWithoutTeamapplicationInput>, teamUncheckedUpdateWithoutTeamapplicationInput>
  }

  export type teamCreateNestedOneWithoutTeamcommentInput = {
    create?: XOR<teamCreateWithoutTeamcommentInput, teamUncheckedCreateWithoutTeamcommentInput>
    connectOrCreate?: teamCreateOrConnectWithoutTeamcommentInput
    connect?: teamWhereUniqueInput
  }

  export type userCreateNestedOneWithoutTeamcommentInput = {
    create?: XOR<userCreateWithoutTeamcommentInput, userUncheckedCreateWithoutTeamcommentInput>
    connectOrCreate?: userCreateOrConnectWithoutTeamcommentInput
    connect?: userWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type teamUpdateOneRequiredWithoutTeamcommentNestedInput = {
    create?: XOR<teamCreateWithoutTeamcommentInput, teamUncheckedCreateWithoutTeamcommentInput>
    connectOrCreate?: teamCreateOrConnectWithoutTeamcommentInput
    upsert?: teamUpsertWithoutTeamcommentInput
    connect?: teamWhereUniqueInput
    update?: XOR<XOR<teamUpdateToOneWithWhereWithoutTeamcommentInput, teamUpdateWithoutTeamcommentInput>, teamUncheckedUpdateWithoutTeamcommentInput>
  }

  export type userUpdateOneRequiredWithoutTeamcommentNestedInput = {
    create?: XOR<userCreateWithoutTeamcommentInput, userUncheckedCreateWithoutTeamcommentInput>
    connectOrCreate?: userCreateOrConnectWithoutTeamcommentInput
    upsert?: userUpsertWithoutTeamcommentInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutTeamcommentInput, userUpdateWithoutTeamcommentInput>, userUncheckedUpdateWithoutTeamcommentInput>
  }

  export type teacherCreateNestedOneWithoutPaperInput = {
    create?: XOR<teacherCreateWithoutPaperInput, teacherUncheckedCreateWithoutPaperInput>
    connectOrCreate?: teacherCreateOrConnectWithoutPaperInput
    connect?: teacherWhereUniqueInput
  }

  export type teamCreateNestedOneWithoutPaperInput = {
    create?: XOR<teamCreateWithoutPaperInput, teamUncheckedCreateWithoutPaperInput>
    connectOrCreate?: teamCreateOrConnectWithoutPaperInput
    connect?: teamWhereUniqueInput
  }

  export type reviewCreateNestedManyWithoutPaperInput = {
    create?: XOR<reviewCreateWithoutPaperInput, reviewUncheckedCreateWithoutPaperInput> | reviewCreateWithoutPaperInput[] | reviewUncheckedCreateWithoutPaperInput[]
    connectOrCreate?: reviewCreateOrConnectWithoutPaperInput | reviewCreateOrConnectWithoutPaperInput[]
    createMany?: reviewCreateManyPaperInputEnvelope
    connect?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
  }

  export type reviewerassignmentCreateNestedManyWithoutPaperInput = {
    create?: XOR<reviewerassignmentCreateWithoutPaperInput, reviewerassignmentUncheckedCreateWithoutPaperInput> | reviewerassignmentCreateWithoutPaperInput[] | reviewerassignmentUncheckedCreateWithoutPaperInput[]
    connectOrCreate?: reviewerassignmentCreateOrConnectWithoutPaperInput | reviewerassignmentCreateOrConnectWithoutPaperInput[]
    createMany?: reviewerassignmentCreateManyPaperInputEnvelope
    connect?: reviewerassignmentWhereUniqueInput | reviewerassignmentWhereUniqueInput[]
  }

  export type reviewUncheckedCreateNestedManyWithoutPaperInput = {
    create?: XOR<reviewCreateWithoutPaperInput, reviewUncheckedCreateWithoutPaperInput> | reviewCreateWithoutPaperInput[] | reviewUncheckedCreateWithoutPaperInput[]
    connectOrCreate?: reviewCreateOrConnectWithoutPaperInput | reviewCreateOrConnectWithoutPaperInput[]
    createMany?: reviewCreateManyPaperInputEnvelope
    connect?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
  }

  export type reviewerassignmentUncheckedCreateNestedManyWithoutPaperInput = {
    create?: XOR<reviewerassignmentCreateWithoutPaperInput, reviewerassignmentUncheckedCreateWithoutPaperInput> | reviewerassignmentCreateWithoutPaperInput[] | reviewerassignmentUncheckedCreateWithoutPaperInput[]
    connectOrCreate?: reviewerassignmentCreateOrConnectWithoutPaperInput | reviewerassignmentCreateOrConnectWithoutPaperInput[]
    createMany?: reviewerassignmentCreateManyPaperInputEnvelope
    connect?: reviewerassignmentWhereUniqueInput | reviewerassignmentWhereUniqueInput[]
  }

  export type NullableEnumPaperStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaperStatus | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableEnumReviewDecisionFieldUpdateOperationsInput = {
    set?: $Enums.ReviewDecision | null
  }

  export type teacherUpdateOneWithoutPaperNestedInput = {
    create?: XOR<teacherCreateWithoutPaperInput, teacherUncheckedCreateWithoutPaperInput>
    connectOrCreate?: teacherCreateOrConnectWithoutPaperInput
    upsert?: teacherUpsertWithoutPaperInput
    disconnect?: teacherWhereInput | boolean
    delete?: teacherWhereInput | boolean
    connect?: teacherWhereUniqueInput
    update?: XOR<XOR<teacherUpdateToOneWithWhereWithoutPaperInput, teacherUpdateWithoutPaperInput>, teacherUncheckedUpdateWithoutPaperInput>
  }

  export type teamUpdateOneWithoutPaperNestedInput = {
    create?: XOR<teamCreateWithoutPaperInput, teamUncheckedCreateWithoutPaperInput>
    connectOrCreate?: teamCreateOrConnectWithoutPaperInput
    upsert?: teamUpsertWithoutPaperInput
    disconnect?: teamWhereInput | boolean
    delete?: teamWhereInput | boolean
    connect?: teamWhereUniqueInput
    update?: XOR<XOR<teamUpdateToOneWithWhereWithoutPaperInput, teamUpdateWithoutPaperInput>, teamUncheckedUpdateWithoutPaperInput>
  }

  export type reviewUpdateManyWithoutPaperNestedInput = {
    create?: XOR<reviewCreateWithoutPaperInput, reviewUncheckedCreateWithoutPaperInput> | reviewCreateWithoutPaperInput[] | reviewUncheckedCreateWithoutPaperInput[]
    connectOrCreate?: reviewCreateOrConnectWithoutPaperInput | reviewCreateOrConnectWithoutPaperInput[]
    upsert?: reviewUpsertWithWhereUniqueWithoutPaperInput | reviewUpsertWithWhereUniqueWithoutPaperInput[]
    createMany?: reviewCreateManyPaperInputEnvelope
    set?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
    disconnect?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
    delete?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
    connect?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
    update?: reviewUpdateWithWhereUniqueWithoutPaperInput | reviewUpdateWithWhereUniqueWithoutPaperInput[]
    updateMany?: reviewUpdateManyWithWhereWithoutPaperInput | reviewUpdateManyWithWhereWithoutPaperInput[]
    deleteMany?: reviewScalarWhereInput | reviewScalarWhereInput[]
  }

  export type reviewerassignmentUpdateManyWithoutPaperNestedInput = {
    create?: XOR<reviewerassignmentCreateWithoutPaperInput, reviewerassignmentUncheckedCreateWithoutPaperInput> | reviewerassignmentCreateWithoutPaperInput[] | reviewerassignmentUncheckedCreateWithoutPaperInput[]
    connectOrCreate?: reviewerassignmentCreateOrConnectWithoutPaperInput | reviewerassignmentCreateOrConnectWithoutPaperInput[]
    upsert?: reviewerassignmentUpsertWithWhereUniqueWithoutPaperInput | reviewerassignmentUpsertWithWhereUniqueWithoutPaperInput[]
    createMany?: reviewerassignmentCreateManyPaperInputEnvelope
    set?: reviewerassignmentWhereUniqueInput | reviewerassignmentWhereUniqueInput[]
    disconnect?: reviewerassignmentWhereUniqueInput | reviewerassignmentWhereUniqueInput[]
    delete?: reviewerassignmentWhereUniqueInput | reviewerassignmentWhereUniqueInput[]
    connect?: reviewerassignmentWhereUniqueInput | reviewerassignmentWhereUniqueInput[]
    update?: reviewerassignmentUpdateWithWhereUniqueWithoutPaperInput | reviewerassignmentUpdateWithWhereUniqueWithoutPaperInput[]
    updateMany?: reviewerassignmentUpdateManyWithWhereWithoutPaperInput | reviewerassignmentUpdateManyWithWhereWithoutPaperInput[]
    deleteMany?: reviewerassignmentScalarWhereInput | reviewerassignmentScalarWhereInput[]
  }

  export type reviewUncheckedUpdateManyWithoutPaperNestedInput = {
    create?: XOR<reviewCreateWithoutPaperInput, reviewUncheckedCreateWithoutPaperInput> | reviewCreateWithoutPaperInput[] | reviewUncheckedCreateWithoutPaperInput[]
    connectOrCreate?: reviewCreateOrConnectWithoutPaperInput | reviewCreateOrConnectWithoutPaperInput[]
    upsert?: reviewUpsertWithWhereUniqueWithoutPaperInput | reviewUpsertWithWhereUniqueWithoutPaperInput[]
    createMany?: reviewCreateManyPaperInputEnvelope
    set?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
    disconnect?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
    delete?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
    connect?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
    update?: reviewUpdateWithWhereUniqueWithoutPaperInput | reviewUpdateWithWhereUniqueWithoutPaperInput[]
    updateMany?: reviewUpdateManyWithWhereWithoutPaperInput | reviewUpdateManyWithWhereWithoutPaperInput[]
    deleteMany?: reviewScalarWhereInput | reviewScalarWhereInput[]
  }

  export type reviewerassignmentUncheckedUpdateManyWithoutPaperNestedInput = {
    create?: XOR<reviewerassignmentCreateWithoutPaperInput, reviewerassignmentUncheckedCreateWithoutPaperInput> | reviewerassignmentCreateWithoutPaperInput[] | reviewerassignmentUncheckedCreateWithoutPaperInput[]
    connectOrCreate?: reviewerassignmentCreateOrConnectWithoutPaperInput | reviewerassignmentCreateOrConnectWithoutPaperInput[]
    upsert?: reviewerassignmentUpsertWithWhereUniqueWithoutPaperInput | reviewerassignmentUpsertWithWhereUniqueWithoutPaperInput[]
    createMany?: reviewerassignmentCreateManyPaperInputEnvelope
    set?: reviewerassignmentWhereUniqueInput | reviewerassignmentWhereUniqueInput[]
    disconnect?: reviewerassignmentWhereUniqueInput | reviewerassignmentWhereUniqueInput[]
    delete?: reviewerassignmentWhereUniqueInput | reviewerassignmentWhereUniqueInput[]
    connect?: reviewerassignmentWhereUniqueInput | reviewerassignmentWhereUniqueInput[]
    update?: reviewerassignmentUpdateWithWhereUniqueWithoutPaperInput | reviewerassignmentUpdateWithWhereUniqueWithoutPaperInput[]
    updateMany?: reviewerassignmentUpdateManyWithWhereWithoutPaperInput | reviewerassignmentUpdateManyWithWhereWithoutPaperInput[]
    deleteMany?: reviewerassignmentScalarWhereInput | reviewerassignmentScalarWhereInput[]
  }

  export type teacherCreateNestedOneWithoutProposalInput = {
    create?: XOR<teacherCreateWithoutProposalInput, teacherUncheckedCreateWithoutProposalInput>
    connectOrCreate?: teacherCreateOrConnectWithoutProposalInput
    connect?: teacherWhereUniqueInput
  }

  export type teamCreateNestedOneWithoutProposalInput = {
    create?: XOR<teamCreateWithoutProposalInput, teamUncheckedCreateWithoutProposalInput>
    connectOrCreate?: teamCreateOrConnectWithoutProposalInput
    connect?: teamWhereUniqueInput
  }

  export type reviewCreateNestedManyWithoutProposalInput = {
    create?: XOR<reviewCreateWithoutProposalInput, reviewUncheckedCreateWithoutProposalInput> | reviewCreateWithoutProposalInput[] | reviewUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: reviewCreateOrConnectWithoutProposalInput | reviewCreateOrConnectWithoutProposalInput[]
    createMany?: reviewCreateManyProposalInputEnvelope
    connect?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
  }

  export type reviewerassignmentCreateNestedManyWithoutProposalInput = {
    create?: XOR<reviewerassignmentCreateWithoutProposalInput, reviewerassignmentUncheckedCreateWithoutProposalInput> | reviewerassignmentCreateWithoutProposalInput[] | reviewerassignmentUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: reviewerassignmentCreateOrConnectWithoutProposalInput | reviewerassignmentCreateOrConnectWithoutProposalInput[]
    createMany?: reviewerassignmentCreateManyProposalInputEnvelope
    connect?: reviewerassignmentWhereUniqueInput | reviewerassignmentWhereUniqueInput[]
  }

  export type reviewUncheckedCreateNestedManyWithoutProposalInput = {
    create?: XOR<reviewCreateWithoutProposalInput, reviewUncheckedCreateWithoutProposalInput> | reviewCreateWithoutProposalInput[] | reviewUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: reviewCreateOrConnectWithoutProposalInput | reviewCreateOrConnectWithoutProposalInput[]
    createMany?: reviewCreateManyProposalInputEnvelope
    connect?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
  }

  export type reviewerassignmentUncheckedCreateNestedManyWithoutProposalInput = {
    create?: XOR<reviewerassignmentCreateWithoutProposalInput, reviewerassignmentUncheckedCreateWithoutProposalInput> | reviewerassignmentCreateWithoutProposalInput[] | reviewerassignmentUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: reviewerassignmentCreateOrConnectWithoutProposalInput | reviewerassignmentCreateOrConnectWithoutProposalInput[]
    createMany?: reviewerassignmentCreateManyProposalInputEnvelope
    connect?: reviewerassignmentWhereUniqueInput | reviewerassignmentWhereUniqueInput[]
  }

  export type teacherUpdateOneWithoutProposalNestedInput = {
    create?: XOR<teacherCreateWithoutProposalInput, teacherUncheckedCreateWithoutProposalInput>
    connectOrCreate?: teacherCreateOrConnectWithoutProposalInput
    upsert?: teacherUpsertWithoutProposalInput
    disconnect?: teacherWhereInput | boolean
    delete?: teacherWhereInput | boolean
    connect?: teacherWhereUniqueInput
    update?: XOR<XOR<teacherUpdateToOneWithWhereWithoutProposalInput, teacherUpdateWithoutProposalInput>, teacherUncheckedUpdateWithoutProposalInput>
  }

  export type teamUpdateOneWithoutProposalNestedInput = {
    create?: XOR<teamCreateWithoutProposalInput, teamUncheckedCreateWithoutProposalInput>
    connectOrCreate?: teamCreateOrConnectWithoutProposalInput
    upsert?: teamUpsertWithoutProposalInput
    disconnect?: teamWhereInput | boolean
    delete?: teamWhereInput | boolean
    connect?: teamWhereUniqueInput
    update?: XOR<XOR<teamUpdateToOneWithWhereWithoutProposalInput, teamUpdateWithoutProposalInput>, teamUncheckedUpdateWithoutProposalInput>
  }

  export type reviewUpdateManyWithoutProposalNestedInput = {
    create?: XOR<reviewCreateWithoutProposalInput, reviewUncheckedCreateWithoutProposalInput> | reviewCreateWithoutProposalInput[] | reviewUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: reviewCreateOrConnectWithoutProposalInput | reviewCreateOrConnectWithoutProposalInput[]
    upsert?: reviewUpsertWithWhereUniqueWithoutProposalInput | reviewUpsertWithWhereUniqueWithoutProposalInput[]
    createMany?: reviewCreateManyProposalInputEnvelope
    set?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
    disconnect?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
    delete?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
    connect?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
    update?: reviewUpdateWithWhereUniqueWithoutProposalInput | reviewUpdateWithWhereUniqueWithoutProposalInput[]
    updateMany?: reviewUpdateManyWithWhereWithoutProposalInput | reviewUpdateManyWithWhereWithoutProposalInput[]
    deleteMany?: reviewScalarWhereInput | reviewScalarWhereInput[]
  }

  export type reviewerassignmentUpdateManyWithoutProposalNestedInput = {
    create?: XOR<reviewerassignmentCreateWithoutProposalInput, reviewerassignmentUncheckedCreateWithoutProposalInput> | reviewerassignmentCreateWithoutProposalInput[] | reviewerassignmentUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: reviewerassignmentCreateOrConnectWithoutProposalInput | reviewerassignmentCreateOrConnectWithoutProposalInput[]
    upsert?: reviewerassignmentUpsertWithWhereUniqueWithoutProposalInput | reviewerassignmentUpsertWithWhereUniqueWithoutProposalInput[]
    createMany?: reviewerassignmentCreateManyProposalInputEnvelope
    set?: reviewerassignmentWhereUniqueInput | reviewerassignmentWhereUniqueInput[]
    disconnect?: reviewerassignmentWhereUniqueInput | reviewerassignmentWhereUniqueInput[]
    delete?: reviewerassignmentWhereUniqueInput | reviewerassignmentWhereUniqueInput[]
    connect?: reviewerassignmentWhereUniqueInput | reviewerassignmentWhereUniqueInput[]
    update?: reviewerassignmentUpdateWithWhereUniqueWithoutProposalInput | reviewerassignmentUpdateWithWhereUniqueWithoutProposalInput[]
    updateMany?: reviewerassignmentUpdateManyWithWhereWithoutProposalInput | reviewerassignmentUpdateManyWithWhereWithoutProposalInput[]
    deleteMany?: reviewerassignmentScalarWhereInput | reviewerassignmentScalarWhereInput[]
  }

  export type reviewUncheckedUpdateManyWithoutProposalNestedInput = {
    create?: XOR<reviewCreateWithoutProposalInput, reviewUncheckedCreateWithoutProposalInput> | reviewCreateWithoutProposalInput[] | reviewUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: reviewCreateOrConnectWithoutProposalInput | reviewCreateOrConnectWithoutProposalInput[]
    upsert?: reviewUpsertWithWhereUniqueWithoutProposalInput | reviewUpsertWithWhereUniqueWithoutProposalInput[]
    createMany?: reviewCreateManyProposalInputEnvelope
    set?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
    disconnect?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
    delete?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
    connect?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
    update?: reviewUpdateWithWhereUniqueWithoutProposalInput | reviewUpdateWithWhereUniqueWithoutProposalInput[]
    updateMany?: reviewUpdateManyWithWhereWithoutProposalInput | reviewUpdateManyWithWhereWithoutProposalInput[]
    deleteMany?: reviewScalarWhereInput | reviewScalarWhereInput[]
  }

  export type reviewerassignmentUncheckedUpdateManyWithoutProposalNestedInput = {
    create?: XOR<reviewerassignmentCreateWithoutProposalInput, reviewerassignmentUncheckedCreateWithoutProposalInput> | reviewerassignmentCreateWithoutProposalInput[] | reviewerassignmentUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: reviewerassignmentCreateOrConnectWithoutProposalInput | reviewerassignmentCreateOrConnectWithoutProposalInput[]
    upsert?: reviewerassignmentUpsertWithWhereUniqueWithoutProposalInput | reviewerassignmentUpsertWithWhereUniqueWithoutProposalInput[]
    createMany?: reviewerassignmentCreateManyProposalInputEnvelope
    set?: reviewerassignmentWhereUniqueInput | reviewerassignmentWhereUniqueInput[]
    disconnect?: reviewerassignmentWhereUniqueInput | reviewerassignmentWhereUniqueInput[]
    delete?: reviewerassignmentWhereUniqueInput | reviewerassignmentWhereUniqueInput[]
    connect?: reviewerassignmentWhereUniqueInput | reviewerassignmentWhereUniqueInput[]
    update?: reviewerassignmentUpdateWithWhereUniqueWithoutProposalInput | reviewerassignmentUpdateWithWhereUniqueWithoutProposalInput[]
    updateMany?: reviewerassignmentUpdateManyWithWhereWithoutProposalInput | reviewerassignmentUpdateManyWithWhereWithoutProposalInput[]
    deleteMany?: reviewerassignmentScalarWhereInput | reviewerassignmentScalarWhereInput[]
  }

  export type paperCreateNestedOneWithoutReviewInput = {
    create?: XOR<paperCreateWithoutReviewInput, paperUncheckedCreateWithoutReviewInput>
    connectOrCreate?: paperCreateOrConnectWithoutReviewInput
    connect?: paperWhereUniqueInput
  }

  export type proposalCreateNestedOneWithoutReviewInput = {
    create?: XOR<proposalCreateWithoutReviewInput, proposalUncheckedCreateWithoutReviewInput>
    connectOrCreate?: proposalCreateOrConnectWithoutReviewInput
    connect?: proposalWhereUniqueInput
  }

  export type reviewerCreateNestedOneWithoutReviewInput = {
    create?: XOR<reviewerCreateWithoutReviewInput, reviewerUncheckedCreateWithoutReviewInput>
    connectOrCreate?: reviewerCreateOrConnectWithoutReviewInput
    connect?: reviewerWhereUniqueInput
  }

  export type paperUpdateOneWithoutReviewNestedInput = {
    create?: XOR<paperCreateWithoutReviewInput, paperUncheckedCreateWithoutReviewInput>
    connectOrCreate?: paperCreateOrConnectWithoutReviewInput
    upsert?: paperUpsertWithoutReviewInput
    disconnect?: paperWhereInput | boolean
    delete?: paperWhereInput | boolean
    connect?: paperWhereUniqueInput
    update?: XOR<XOR<paperUpdateToOneWithWhereWithoutReviewInput, paperUpdateWithoutReviewInput>, paperUncheckedUpdateWithoutReviewInput>
  }

  export type proposalUpdateOneWithoutReviewNestedInput = {
    create?: XOR<proposalCreateWithoutReviewInput, proposalUncheckedCreateWithoutReviewInput>
    connectOrCreate?: proposalCreateOrConnectWithoutReviewInput
    upsert?: proposalUpsertWithoutReviewInput
    disconnect?: proposalWhereInput | boolean
    delete?: proposalWhereInput | boolean
    connect?: proposalWhereUniqueInput
    update?: XOR<XOR<proposalUpdateToOneWithWhereWithoutReviewInput, proposalUpdateWithoutReviewInput>, proposalUncheckedUpdateWithoutReviewInput>
  }

  export type reviewerUpdateOneWithoutReviewNestedInput = {
    create?: XOR<reviewerCreateWithoutReviewInput, reviewerUncheckedCreateWithoutReviewInput>
    connectOrCreate?: reviewerCreateOrConnectWithoutReviewInput
    upsert?: reviewerUpsertWithoutReviewInput
    disconnect?: reviewerWhereInput | boolean
    delete?: reviewerWhereInput | boolean
    connect?: reviewerWhereUniqueInput
    update?: XOR<XOR<reviewerUpdateToOneWithWhereWithoutReviewInput, reviewerUpdateWithoutReviewInput>, reviewerUncheckedUpdateWithoutReviewInput>
  }

  export type paperCreateNestedOneWithoutReviewerassignmentInput = {
    create?: XOR<paperCreateWithoutReviewerassignmentInput, paperUncheckedCreateWithoutReviewerassignmentInput>
    connectOrCreate?: paperCreateOrConnectWithoutReviewerassignmentInput
    connect?: paperWhereUniqueInput
  }

  export type proposalCreateNestedOneWithoutReviewerassignmentInput = {
    create?: XOR<proposalCreateWithoutReviewerassignmentInput, proposalUncheckedCreateWithoutReviewerassignmentInput>
    connectOrCreate?: proposalCreateOrConnectWithoutReviewerassignmentInput
    connect?: proposalWhereUniqueInput
  }

  export type reviewerCreateNestedOneWithoutReviewerassignmentInput = {
    create?: XOR<reviewerCreateWithoutReviewerassignmentInput, reviewerUncheckedCreateWithoutReviewerassignmentInput>
    connectOrCreate?: reviewerCreateOrConnectWithoutReviewerassignmentInput
    connect?: reviewerWhereUniqueInput
  }

  export type EnumAssignmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.AssignmentStatus
  }

  export type paperUpdateOneWithoutReviewerassignmentNestedInput = {
    create?: XOR<paperCreateWithoutReviewerassignmentInput, paperUncheckedCreateWithoutReviewerassignmentInput>
    connectOrCreate?: paperCreateOrConnectWithoutReviewerassignmentInput
    upsert?: paperUpsertWithoutReviewerassignmentInput
    disconnect?: paperWhereInput | boolean
    delete?: paperWhereInput | boolean
    connect?: paperWhereUniqueInput
    update?: XOR<XOR<paperUpdateToOneWithWhereWithoutReviewerassignmentInput, paperUpdateWithoutReviewerassignmentInput>, paperUncheckedUpdateWithoutReviewerassignmentInput>
  }

  export type proposalUpdateOneWithoutReviewerassignmentNestedInput = {
    create?: XOR<proposalCreateWithoutReviewerassignmentInput, proposalUncheckedCreateWithoutReviewerassignmentInput>
    connectOrCreate?: proposalCreateOrConnectWithoutReviewerassignmentInput
    upsert?: proposalUpsertWithoutReviewerassignmentInput
    disconnect?: proposalWhereInput | boolean
    delete?: proposalWhereInput | boolean
    connect?: proposalWhereUniqueInput
    update?: XOR<XOR<proposalUpdateToOneWithWhereWithoutReviewerassignmentInput, proposalUpdateWithoutReviewerassignmentInput>, proposalUncheckedUpdateWithoutReviewerassignmentInput>
  }

  export type reviewerUpdateOneRequiredWithoutReviewerassignmentNestedInput = {
    create?: XOR<reviewerCreateWithoutReviewerassignmentInput, reviewerUncheckedCreateWithoutReviewerassignmentInput>
    connectOrCreate?: reviewerCreateOrConnectWithoutReviewerassignmentInput
    upsert?: reviewerUpsertWithoutReviewerassignmentInput
    connect?: reviewerWhereUniqueInput
    update?: XOR<XOR<reviewerUpdateToOneWithWhereWithoutReviewerassignmentInput, reviewerUpdateWithoutReviewerassignmentInput>, reviewerUncheckedUpdateWithoutReviewerassignmentInput>
  }

  export type domainCreateNestedOneWithoutUserdomainInput = {
    create?: XOR<domainCreateWithoutUserdomainInput, domainUncheckedCreateWithoutUserdomainInput>
    connectOrCreate?: domainCreateOrConnectWithoutUserdomainInput
    connect?: domainWhereUniqueInput
  }

  export type userCreateNestedOneWithoutUserdomainInput = {
    create?: XOR<userCreateWithoutUserdomainInput, userUncheckedCreateWithoutUserdomainInput>
    connectOrCreate?: userCreateOrConnectWithoutUserdomainInput
    connect?: userWhereUniqueInput
  }

  export type domainUpdateOneRequiredWithoutUserdomainNestedInput = {
    create?: XOR<domainCreateWithoutUserdomainInput, domainUncheckedCreateWithoutUserdomainInput>
    connectOrCreate?: domainCreateOrConnectWithoutUserdomainInput
    upsert?: domainUpsertWithoutUserdomainInput
    connect?: domainWhereUniqueInput
    update?: XOR<XOR<domainUpdateToOneWithWhereWithoutUserdomainInput, domainUpdateWithoutUserdomainInput>, domainUncheckedUpdateWithoutUserdomainInput>
  }

  export type userUpdateOneRequiredWithoutUserdomainNestedInput = {
    create?: XOR<userCreateWithoutUserdomainInput, userUncheckedCreateWithoutUserdomainInput>
    connectOrCreate?: userCreateOrConnectWithoutUserdomainInput
    upsert?: userUpsertWithoutUserdomainInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutUserdomainInput, userUpdateWithoutUserdomainInput>, userUncheckedUpdateWithoutUserdomainInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumRoleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableFilter<$PrismaModel> | $Enums.Role | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumRoleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableWithAggregatesFilter<$PrismaModel> | $Enums.Role | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRoleNullableFilter<$PrismaModel>
    _max?: NestedEnumRoleNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumReviewerStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewerStatus | EnumReviewerStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ReviewerStatus[] | ListEnumReviewerStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ReviewerStatus[] | ListEnumReviewerStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumReviewerStatusNullableFilter<$PrismaModel> | $Enums.ReviewerStatus | null
  }

  export type NestedEnumReviewerStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewerStatus | EnumReviewerStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ReviewerStatus[] | ListEnumReviewerStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ReviewerStatus[] | ListEnumReviewerStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumReviewerStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.ReviewerStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumReviewerStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumReviewerStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumTeamStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamStatus | EnumTeamStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.TeamStatus[] | ListEnumTeamStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TeamStatus[] | ListEnumTeamStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTeamStatusNullableFilter<$PrismaModel> | $Enums.TeamStatus | null
  }

  export type NestedEnumTeamVisibilityNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamVisibility | EnumTeamVisibilityFieldRefInput<$PrismaModel> | null
    in?: $Enums.TeamVisibility[] | ListEnumTeamVisibilityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TeamVisibility[] | ListEnumTeamVisibilityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTeamVisibilityNullableFilter<$PrismaModel> | $Enums.TeamVisibility | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedEnumTeamStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamStatus | EnumTeamStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.TeamStatus[] | ListEnumTeamStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TeamStatus[] | ListEnumTeamStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTeamStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.TeamStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTeamStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumTeamStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumTeamVisibilityNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamVisibility | EnumTeamVisibilityFieldRefInput<$PrismaModel> | null
    in?: $Enums.TeamVisibility[] | ListEnumTeamVisibilityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TeamVisibility[] | ListEnumTeamVisibilityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTeamVisibilityNullableWithAggregatesFilter<$PrismaModel> | $Enums.TeamVisibility | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTeamVisibilityNullableFilter<$PrismaModel>
    _max?: NestedEnumTeamVisibilityNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumTeamRoleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamRole | EnumTeamRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTeamRoleNullableFilter<$PrismaModel> | $Enums.TeamRole | null
  }

  export type NestedEnumTeamRoleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamRole | EnumTeamRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTeamRoleNullableWithAggregatesFilter<$PrismaModel> | $Enums.TeamRole | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTeamRoleNullableFilter<$PrismaModel>
    _max?: NestedEnumTeamRoleNullableFilter<$PrismaModel>
  }

  export type NestedEnumApplicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusFilter<$PrismaModel> | $Enums.ApplicationStatus
  }

  export type NestedEnumApplicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApplicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApplicationStatusFilter<$PrismaModel>
    _max?: NestedEnumApplicationStatusFilter<$PrismaModel>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumPaperStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaperStatus | EnumPaperStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaperStatus[] | ListEnumPaperStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaperStatus[] | ListEnumPaperStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaperStatusNullableFilter<$PrismaModel> | $Enums.PaperStatus | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumReviewDecisionNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewDecision | EnumReviewDecisionFieldRefInput<$PrismaModel> | null
    in?: $Enums.ReviewDecision[] | ListEnumReviewDecisionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ReviewDecision[] | ListEnumReviewDecisionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumReviewDecisionNullableFilter<$PrismaModel> | $Enums.ReviewDecision | null
  }

  export type NestedEnumPaperStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaperStatus | EnumPaperStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaperStatus[] | ListEnumPaperStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaperStatus[] | ListEnumPaperStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaperStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaperStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaperStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumPaperStatusNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumReviewDecisionNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewDecision | EnumReviewDecisionFieldRefInput<$PrismaModel> | null
    in?: $Enums.ReviewDecision[] | ListEnumReviewDecisionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ReviewDecision[] | ListEnumReviewDecisionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumReviewDecisionNullableWithAggregatesFilter<$PrismaModel> | $Enums.ReviewDecision | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumReviewDecisionNullableFilter<$PrismaModel>
    _max?: NestedEnumReviewDecisionNullableFilter<$PrismaModel>
  }

  export type NestedEnumAssignmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AssignmentStatus | EnumAssignmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssignmentStatusFilter<$PrismaModel> | $Enums.AssignmentStatus
  }

  export type NestedEnumAssignmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssignmentStatus | EnumAssignmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssignmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AssignmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssignmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAssignmentStatusFilter<$PrismaModel>
  }

  export type adminCreateWithoutUserInput = {

  }

  export type adminUncheckedCreateWithoutUserInput = {
    admin_id?: number
  }

  export type adminCreateOrConnectWithoutUserInput = {
    where: adminWhereUniqueInput
    create: XOR<adminCreateWithoutUserInput, adminUncheckedCreateWithoutUserInput>
  }

  export type adminCreateManyUserInputEnvelope = {
    data: adminCreateManyUserInput | adminCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type generaluserCreateWithoutUserInput = {

  }

  export type generaluserUncheckedCreateWithoutUserInput = {
    generaluser_id?: number
  }

  export type generaluserCreateOrConnectWithoutUserInput = {
    where: generaluserWhereUniqueInput
    create: XOR<generaluserCreateWithoutUserInput, generaluserUncheckedCreateWithoutUserInput>
  }

  export type generaluserCreateManyUserInputEnvelope = {
    data: generaluserCreateManyUserInput | generaluserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type studentCreateWithoutUserInput = {
    roll_number?: string | null
    department?: departmentCreateNestedOneWithoutStudentsInput
    teamapplication?: teamapplicationCreateNestedManyWithoutStudentInput
  }

  export type studentUncheckedCreateWithoutUserInput = {
    student_id?: number
    roll_number?: string | null
    department_id?: number | null
    teamapplication?: teamapplicationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type studentCreateOrConnectWithoutUserInput = {
    where: studentWhereUniqueInput
    create: XOR<studentCreateWithoutUserInput, studentUncheckedCreateWithoutUserInput>
  }

  export type studentCreateManyUserInputEnvelope = {
    data: studentCreateManyUserInput | studentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type teacherCreateWithoutUserInput = {
    designation?: string | null
    isReviewer?: boolean
    paper?: paperCreateNestedManyWithoutTeacherInput
    proposal?: proposalCreateNestedManyWithoutTeacherInput
    reviewer?: reviewerCreateNestedOneWithoutTeacherInput
    department?: departmentCreateNestedOneWithoutTeachersInput
  }

  export type teacherUncheckedCreateWithoutUserInput = {
    teacher_id?: number
    designation?: string | null
    department_id?: number | null
    isReviewer?: boolean
    paper?: paperUncheckedCreateNestedManyWithoutTeacherInput
    proposal?: proposalUncheckedCreateNestedManyWithoutTeacherInput
    reviewer?: reviewerUncheckedCreateNestedOneWithoutTeacherInput
  }

  export type teacherCreateOrConnectWithoutUserInput = {
    where: teacherWhereUniqueInput
    create: XOR<teacherCreateWithoutUserInput, teacherUncheckedCreateWithoutUserInput>
  }

  export type teacherCreateManyUserInputEnvelope = {
    data: teacherCreateManyUserInput | teacherCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type teamCreateWithoutCreated_by_userInput = {
    team_name?: string | null
    team_description?: string | null
    status?: $Enums.TeamStatus | null
    visibility?: $Enums.TeamVisibility | null
    max_members?: number | null
    isHiring?: boolean | null
    created_at?: Date | string
    paper?: paperCreateNestedManyWithoutTeamInput
    proposal?: proposalCreateNestedManyWithoutTeamInput
    domain?: domainCreateNestedOneWithoutTeamInput
    teamapplication?: teamapplicationCreateNestedManyWithoutTeamInput
    teamcomment?: teamcommentCreateNestedManyWithoutTeamInput
    teammember?: teammemberCreateNestedManyWithoutTeamInput
  }

  export type teamUncheckedCreateWithoutCreated_by_userInput = {
    team_id?: number
    team_name?: string | null
    team_description?: string | null
    domain_id?: number | null
    status?: $Enums.TeamStatus | null
    visibility?: $Enums.TeamVisibility | null
    max_members?: number | null
    isHiring?: boolean | null
    created_at?: Date | string
    paper?: paperUncheckedCreateNestedManyWithoutTeamInput
    proposal?: proposalUncheckedCreateNestedManyWithoutTeamInput
    teamapplication?: teamapplicationUncheckedCreateNestedManyWithoutTeamInput
    teamcomment?: teamcommentUncheckedCreateNestedManyWithoutTeamInput
    teammember?: teammemberUncheckedCreateNestedManyWithoutTeamInput
  }

  export type teamCreateOrConnectWithoutCreated_by_userInput = {
    where: teamWhereUniqueInput
    create: XOR<teamCreateWithoutCreated_by_userInput, teamUncheckedCreateWithoutCreated_by_userInput>
  }

  export type teamCreateManyCreated_by_userInputEnvelope = {
    data: teamCreateManyCreated_by_userInput | teamCreateManyCreated_by_userInput[]
    skipDuplicates?: boolean
  }

  export type teamcommentCreateWithoutUserInput = {
    comment: string
    created_at?: Date | string
    team: teamCreateNestedOneWithoutTeamcommentInput
  }

  export type teamcommentUncheckedCreateWithoutUserInput = {
    comment_id?: number
    team_id: number
    comment: string
    created_at?: Date | string
  }

  export type teamcommentCreateOrConnectWithoutUserInput = {
    where: teamcommentWhereUniqueInput
    create: XOR<teamcommentCreateWithoutUserInput, teamcommentUncheckedCreateWithoutUserInput>
  }

  export type teamcommentCreateManyUserInputEnvelope = {
    data: teamcommentCreateManyUserInput | teamcommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type teammemberCreateWithoutUserInput = {
    role_in_team?: $Enums.TeamRole | null
    team: teamCreateNestedOneWithoutTeammemberInput
  }

  export type teammemberUncheckedCreateWithoutUserInput = {
    team_id: number
    role_in_team?: $Enums.TeamRole | null
  }

  export type teammemberCreateOrConnectWithoutUserInput = {
    where: teammemberWhereUniqueInput
    create: XOR<teammemberCreateWithoutUserInput, teammemberUncheckedCreateWithoutUserInput>
  }

  export type teammemberCreateManyUserInputEnvelope = {
    data: teammemberCreateManyUserInput | teammemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type userdomainCreateWithoutUserInput = {
    domain: domainCreateNestedOneWithoutUserdomainInput
  }

  export type userdomainUncheckedCreateWithoutUserInput = {
    domain_id: number
  }

  export type userdomainCreateOrConnectWithoutUserInput = {
    where: userdomainWhereUniqueInput
    create: XOR<userdomainCreateWithoutUserInput, userdomainUncheckedCreateWithoutUserInput>
  }

  export type userdomainCreateManyUserInputEnvelope = {
    data: userdomainCreateManyUserInput | userdomainCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type adminUpsertWithWhereUniqueWithoutUserInput = {
    where: adminWhereUniqueInput
    update: XOR<adminUpdateWithoutUserInput, adminUncheckedUpdateWithoutUserInput>
    create: XOR<adminCreateWithoutUserInput, adminUncheckedCreateWithoutUserInput>
  }

  export type adminUpdateWithWhereUniqueWithoutUserInput = {
    where: adminWhereUniqueInput
    data: XOR<adminUpdateWithoutUserInput, adminUncheckedUpdateWithoutUserInput>
  }

  export type adminUpdateManyWithWhereWithoutUserInput = {
    where: adminScalarWhereInput
    data: XOR<adminUpdateManyMutationInput, adminUncheckedUpdateManyWithoutUserInput>
  }

  export type adminScalarWhereInput = {
    AND?: adminScalarWhereInput | adminScalarWhereInput[]
    OR?: adminScalarWhereInput[]
    NOT?: adminScalarWhereInput | adminScalarWhereInput[]
    admin_id?: IntFilter<"admin"> | number
    user_id?: IntNullableFilter<"admin"> | number | null
  }

  export type generaluserUpsertWithWhereUniqueWithoutUserInput = {
    where: generaluserWhereUniqueInput
    update: XOR<generaluserUpdateWithoutUserInput, generaluserUncheckedUpdateWithoutUserInput>
    create: XOR<generaluserCreateWithoutUserInput, generaluserUncheckedCreateWithoutUserInput>
  }

  export type generaluserUpdateWithWhereUniqueWithoutUserInput = {
    where: generaluserWhereUniqueInput
    data: XOR<generaluserUpdateWithoutUserInput, generaluserUncheckedUpdateWithoutUserInput>
  }

  export type generaluserUpdateManyWithWhereWithoutUserInput = {
    where: generaluserScalarWhereInput
    data: XOR<generaluserUpdateManyMutationInput, generaluserUncheckedUpdateManyWithoutUserInput>
  }

  export type generaluserScalarWhereInput = {
    AND?: generaluserScalarWhereInput | generaluserScalarWhereInput[]
    OR?: generaluserScalarWhereInput[]
    NOT?: generaluserScalarWhereInput | generaluserScalarWhereInput[]
    generaluser_id?: IntFilter<"generaluser"> | number
    user_id?: IntNullableFilter<"generaluser"> | number | null
  }

  export type studentUpsertWithWhereUniqueWithoutUserInput = {
    where: studentWhereUniqueInput
    update: XOR<studentUpdateWithoutUserInput, studentUncheckedUpdateWithoutUserInput>
    create: XOR<studentCreateWithoutUserInput, studentUncheckedCreateWithoutUserInput>
  }

  export type studentUpdateWithWhereUniqueWithoutUserInput = {
    where: studentWhereUniqueInput
    data: XOR<studentUpdateWithoutUserInput, studentUncheckedUpdateWithoutUserInput>
  }

  export type studentUpdateManyWithWhereWithoutUserInput = {
    where: studentScalarWhereInput
    data: XOR<studentUpdateManyMutationInput, studentUncheckedUpdateManyWithoutUserInput>
  }

  export type studentScalarWhereInput = {
    AND?: studentScalarWhereInput | studentScalarWhereInput[]
    OR?: studentScalarWhereInput[]
    NOT?: studentScalarWhereInput | studentScalarWhereInput[]
    student_id?: IntFilter<"student"> | number
    roll_number?: StringNullableFilter<"student"> | string | null
    department_id?: IntNullableFilter<"student"> | number | null
    user_id?: IntNullableFilter<"student"> | number | null
  }

  export type teacherUpsertWithWhereUniqueWithoutUserInput = {
    where: teacherWhereUniqueInput
    update: XOR<teacherUpdateWithoutUserInput, teacherUncheckedUpdateWithoutUserInput>
    create: XOR<teacherCreateWithoutUserInput, teacherUncheckedCreateWithoutUserInput>
  }

  export type teacherUpdateWithWhereUniqueWithoutUserInput = {
    where: teacherWhereUniqueInput
    data: XOR<teacherUpdateWithoutUserInput, teacherUncheckedUpdateWithoutUserInput>
  }

  export type teacherUpdateManyWithWhereWithoutUserInput = {
    where: teacherScalarWhereInput
    data: XOR<teacherUpdateManyMutationInput, teacherUncheckedUpdateManyWithoutUserInput>
  }

  export type teacherScalarWhereInput = {
    AND?: teacherScalarWhereInput | teacherScalarWhereInput[]
    OR?: teacherScalarWhereInput[]
    NOT?: teacherScalarWhereInput | teacherScalarWhereInput[]
    teacher_id?: IntFilter<"teacher"> | number
    designation?: StringNullableFilter<"teacher"> | string | null
    department_id?: IntNullableFilter<"teacher"> | number | null
    user_id?: IntNullableFilter<"teacher"> | number | null
    isReviewer?: BoolFilter<"teacher"> | boolean
  }

  export type teamUpsertWithWhereUniqueWithoutCreated_by_userInput = {
    where: teamWhereUniqueInput
    update: XOR<teamUpdateWithoutCreated_by_userInput, teamUncheckedUpdateWithoutCreated_by_userInput>
    create: XOR<teamCreateWithoutCreated_by_userInput, teamUncheckedCreateWithoutCreated_by_userInput>
  }

  export type teamUpdateWithWhereUniqueWithoutCreated_by_userInput = {
    where: teamWhereUniqueInput
    data: XOR<teamUpdateWithoutCreated_by_userInput, teamUncheckedUpdateWithoutCreated_by_userInput>
  }

  export type teamUpdateManyWithWhereWithoutCreated_by_userInput = {
    where: teamScalarWhereInput
    data: XOR<teamUpdateManyMutationInput, teamUncheckedUpdateManyWithoutCreated_by_userInput>
  }

  export type teamScalarWhereInput = {
    AND?: teamScalarWhereInput | teamScalarWhereInput[]
    OR?: teamScalarWhereInput[]
    NOT?: teamScalarWhereInput | teamScalarWhereInput[]
    team_id?: IntFilter<"team"> | number
    team_name?: StringNullableFilter<"team"> | string | null
    team_description?: StringNullableFilter<"team"> | string | null
    domain_id?: IntNullableFilter<"team"> | number | null
    status?: EnumTeamStatusNullableFilter<"team"> | $Enums.TeamStatus | null
    visibility?: EnumTeamVisibilityNullableFilter<"team"> | $Enums.TeamVisibility | null
    max_members?: IntNullableFilter<"team"> | number | null
    isHiring?: BoolNullableFilter<"team"> | boolean | null
    created_at?: DateTimeFilter<"team"> | Date | string
    created_by_user_id?: IntNullableFilter<"team"> | number | null
  }

  export type teamcommentUpsertWithWhereUniqueWithoutUserInput = {
    where: teamcommentWhereUniqueInput
    update: XOR<teamcommentUpdateWithoutUserInput, teamcommentUncheckedUpdateWithoutUserInput>
    create: XOR<teamcommentCreateWithoutUserInput, teamcommentUncheckedCreateWithoutUserInput>
  }

  export type teamcommentUpdateWithWhereUniqueWithoutUserInput = {
    where: teamcommentWhereUniqueInput
    data: XOR<teamcommentUpdateWithoutUserInput, teamcommentUncheckedUpdateWithoutUserInput>
  }

  export type teamcommentUpdateManyWithWhereWithoutUserInput = {
    where: teamcommentScalarWhereInput
    data: XOR<teamcommentUpdateManyMutationInput, teamcommentUncheckedUpdateManyWithoutUserInput>
  }

  export type teamcommentScalarWhereInput = {
    AND?: teamcommentScalarWhereInput | teamcommentScalarWhereInput[]
    OR?: teamcommentScalarWhereInput[]
    NOT?: teamcommentScalarWhereInput | teamcommentScalarWhereInput[]
    comment_id?: IntFilter<"teamcomment"> | number
    team_id?: IntFilter<"teamcomment"> | number
    user_id?: IntFilter<"teamcomment"> | number
    comment?: StringFilter<"teamcomment"> | string
    created_at?: DateTimeFilter<"teamcomment"> | Date | string
  }

  export type teammemberUpsertWithWhereUniqueWithoutUserInput = {
    where: teammemberWhereUniqueInput
    update: XOR<teammemberUpdateWithoutUserInput, teammemberUncheckedUpdateWithoutUserInput>
    create: XOR<teammemberCreateWithoutUserInput, teammemberUncheckedCreateWithoutUserInput>
  }

  export type teammemberUpdateWithWhereUniqueWithoutUserInput = {
    where: teammemberWhereUniqueInput
    data: XOR<teammemberUpdateWithoutUserInput, teammemberUncheckedUpdateWithoutUserInput>
  }

  export type teammemberUpdateManyWithWhereWithoutUserInput = {
    where: teammemberScalarWhereInput
    data: XOR<teammemberUpdateManyMutationInput, teammemberUncheckedUpdateManyWithoutUserInput>
  }

  export type teammemberScalarWhereInput = {
    AND?: teammemberScalarWhereInput | teammemberScalarWhereInput[]
    OR?: teammemberScalarWhereInput[]
    NOT?: teammemberScalarWhereInput | teammemberScalarWhereInput[]
    team_id?: IntFilter<"teammember"> | number
    user_id?: IntFilter<"teammember"> | number
    role_in_team?: EnumTeamRoleNullableFilter<"teammember"> | $Enums.TeamRole | null
  }

  export type userdomainUpsertWithWhereUniqueWithoutUserInput = {
    where: userdomainWhereUniqueInput
    update: XOR<userdomainUpdateWithoutUserInput, userdomainUncheckedUpdateWithoutUserInput>
    create: XOR<userdomainCreateWithoutUserInput, userdomainUncheckedCreateWithoutUserInput>
  }

  export type userdomainUpdateWithWhereUniqueWithoutUserInput = {
    where: userdomainWhereUniqueInput
    data: XOR<userdomainUpdateWithoutUserInput, userdomainUncheckedUpdateWithoutUserInput>
  }

  export type userdomainUpdateManyWithWhereWithoutUserInput = {
    where: userdomainScalarWhereInput
    data: XOR<userdomainUpdateManyMutationInput, userdomainUncheckedUpdateManyWithoutUserInput>
  }

  export type userdomainScalarWhereInput = {
    AND?: userdomainScalarWhereInput | userdomainScalarWhereInput[]
    OR?: userdomainScalarWhereInput[]
    NOT?: userdomainScalarWhereInput | userdomainScalarWhereInput[]
    user_id?: IntFilter<"userdomain"> | number
    domain_id?: IntFilter<"userdomain"> | number
  }

  export type userCreateWithoutAdminInput = {
    name?: string | null
    email?: string | null
    password?: string | null
    profile_image?: string | null
    role?: $Enums.Role | null
    isVerified?: boolean
    isMainAdmin?: boolean
    verifyToken?: string | null
    created_at?: Date | string
    generaluser?: generaluserCreateNestedManyWithoutUserInput
    student?: studentCreateNestedManyWithoutUserInput
    teacher?: teacherCreateNestedManyWithoutUserInput
    team?: teamCreateNestedManyWithoutCreated_by_userInput
    teamcomment?: teamcommentCreateNestedManyWithoutUserInput
    teammember?: teammemberCreateNestedManyWithoutUserInput
    userdomain?: userdomainCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutAdminInput = {
    user_id?: number
    name?: string | null
    email?: string | null
    password?: string | null
    profile_image?: string | null
    role?: $Enums.Role | null
    isVerified?: boolean
    isMainAdmin?: boolean
    verifyToken?: string | null
    created_at?: Date | string
    generaluser?: generaluserUncheckedCreateNestedManyWithoutUserInput
    student?: studentUncheckedCreateNestedManyWithoutUserInput
    teacher?: teacherUncheckedCreateNestedManyWithoutUserInput
    team?: teamUncheckedCreateNestedManyWithoutCreated_by_userInput
    teamcomment?: teamcommentUncheckedCreateNestedManyWithoutUserInput
    teammember?: teammemberUncheckedCreateNestedManyWithoutUserInput
    userdomain?: userdomainUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutAdminInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutAdminInput, userUncheckedCreateWithoutAdminInput>
  }

  export type userUpsertWithoutAdminInput = {
    update: XOR<userUpdateWithoutAdminInput, userUncheckedUpdateWithoutAdminInput>
    create: XOR<userCreateWithoutAdminInput, userUncheckedCreateWithoutAdminInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutAdminInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutAdminInput, userUncheckedUpdateWithoutAdminInput>
  }

  export type userUpdateWithoutAdminInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isMainAdmin?: BoolFieldUpdateOperationsInput | boolean
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    generaluser?: generaluserUpdateManyWithoutUserNestedInput
    student?: studentUpdateManyWithoutUserNestedInput
    teacher?: teacherUpdateManyWithoutUserNestedInput
    team?: teamUpdateManyWithoutCreated_by_userNestedInput
    teamcomment?: teamcommentUpdateManyWithoutUserNestedInput
    teammember?: teammemberUpdateManyWithoutUserNestedInput
    userdomain?: userdomainUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutAdminInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isMainAdmin?: BoolFieldUpdateOperationsInput | boolean
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    generaluser?: generaluserUncheckedUpdateManyWithoutUserNestedInput
    student?: studentUncheckedUpdateManyWithoutUserNestedInput
    teacher?: teacherUncheckedUpdateManyWithoutUserNestedInput
    team?: teamUncheckedUpdateManyWithoutCreated_by_userNestedInput
    teamcomment?: teamcommentUncheckedUpdateManyWithoutUserNestedInput
    teammember?: teammemberUncheckedUpdateManyWithoutUserNestedInput
    userdomain?: userdomainUncheckedUpdateManyWithoutUserNestedInput
  }

  export type departmentdomainCreateWithoutDepartmentInput = {
    domain: domainCreateNestedOneWithoutDepartmentdomainInput
  }

  export type departmentdomainUncheckedCreateWithoutDepartmentInput = {
    domain_id: number
  }

  export type departmentdomainCreateOrConnectWithoutDepartmentInput = {
    where: departmentdomainWhereUniqueInput
    create: XOR<departmentdomainCreateWithoutDepartmentInput, departmentdomainUncheckedCreateWithoutDepartmentInput>
  }

  export type departmentdomainCreateManyDepartmentInputEnvelope = {
    data: departmentdomainCreateManyDepartmentInput | departmentdomainCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type studentCreateWithoutDepartmentInput = {
    roll_number?: string | null
    user?: userCreateNestedOneWithoutStudentInput
    teamapplication?: teamapplicationCreateNestedManyWithoutStudentInput
  }

  export type studentUncheckedCreateWithoutDepartmentInput = {
    student_id?: number
    roll_number?: string | null
    user_id?: number | null
    teamapplication?: teamapplicationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type studentCreateOrConnectWithoutDepartmentInput = {
    where: studentWhereUniqueInput
    create: XOR<studentCreateWithoutDepartmentInput, studentUncheckedCreateWithoutDepartmentInput>
  }

  export type studentCreateManyDepartmentInputEnvelope = {
    data: studentCreateManyDepartmentInput | studentCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type teacherCreateWithoutDepartmentInput = {
    designation?: string | null
    isReviewer?: boolean
    paper?: paperCreateNestedManyWithoutTeacherInput
    proposal?: proposalCreateNestedManyWithoutTeacherInput
    reviewer?: reviewerCreateNestedOneWithoutTeacherInput
    user?: userCreateNestedOneWithoutTeacherInput
  }

  export type teacherUncheckedCreateWithoutDepartmentInput = {
    teacher_id?: number
    designation?: string | null
    user_id?: number | null
    isReviewer?: boolean
    paper?: paperUncheckedCreateNestedManyWithoutTeacherInput
    proposal?: proposalUncheckedCreateNestedManyWithoutTeacherInput
    reviewer?: reviewerUncheckedCreateNestedOneWithoutTeacherInput
  }

  export type teacherCreateOrConnectWithoutDepartmentInput = {
    where: teacherWhereUniqueInput
    create: XOR<teacherCreateWithoutDepartmentInput, teacherUncheckedCreateWithoutDepartmentInput>
  }

  export type teacherCreateManyDepartmentInputEnvelope = {
    data: teacherCreateManyDepartmentInput | teacherCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type departmentdomainUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: departmentdomainWhereUniqueInput
    update: XOR<departmentdomainUpdateWithoutDepartmentInput, departmentdomainUncheckedUpdateWithoutDepartmentInput>
    create: XOR<departmentdomainCreateWithoutDepartmentInput, departmentdomainUncheckedCreateWithoutDepartmentInput>
  }

  export type departmentdomainUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: departmentdomainWhereUniqueInput
    data: XOR<departmentdomainUpdateWithoutDepartmentInput, departmentdomainUncheckedUpdateWithoutDepartmentInput>
  }

  export type departmentdomainUpdateManyWithWhereWithoutDepartmentInput = {
    where: departmentdomainScalarWhereInput
    data: XOR<departmentdomainUpdateManyMutationInput, departmentdomainUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type departmentdomainScalarWhereInput = {
    AND?: departmentdomainScalarWhereInput | departmentdomainScalarWhereInput[]
    OR?: departmentdomainScalarWhereInput[]
    NOT?: departmentdomainScalarWhereInput | departmentdomainScalarWhereInput[]
    department_id?: IntFilter<"departmentdomain"> | number
    domain_id?: IntFilter<"departmentdomain"> | number
  }

  export type studentUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: studentWhereUniqueInput
    update: XOR<studentUpdateWithoutDepartmentInput, studentUncheckedUpdateWithoutDepartmentInput>
    create: XOR<studentCreateWithoutDepartmentInput, studentUncheckedCreateWithoutDepartmentInput>
  }

  export type studentUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: studentWhereUniqueInput
    data: XOR<studentUpdateWithoutDepartmentInput, studentUncheckedUpdateWithoutDepartmentInput>
  }

  export type studentUpdateManyWithWhereWithoutDepartmentInput = {
    where: studentScalarWhereInput
    data: XOR<studentUpdateManyMutationInput, studentUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type teacherUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: teacherWhereUniqueInput
    update: XOR<teacherUpdateWithoutDepartmentInput, teacherUncheckedUpdateWithoutDepartmentInput>
    create: XOR<teacherCreateWithoutDepartmentInput, teacherUncheckedCreateWithoutDepartmentInput>
  }

  export type teacherUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: teacherWhereUniqueInput
    data: XOR<teacherUpdateWithoutDepartmentInput, teacherUncheckedUpdateWithoutDepartmentInput>
  }

  export type teacherUpdateManyWithWhereWithoutDepartmentInput = {
    where: teacherScalarWhereInput
    data: XOR<teacherUpdateManyMutationInput, teacherUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type departmentdomainCreateWithoutDomainInput = {
    department: departmentCreateNestedOneWithoutDepartmentdomainInput
  }

  export type departmentdomainUncheckedCreateWithoutDomainInput = {
    department_id: number
  }

  export type departmentdomainCreateOrConnectWithoutDomainInput = {
    where: departmentdomainWhereUniqueInput
    create: XOR<departmentdomainCreateWithoutDomainInput, departmentdomainUncheckedCreateWithoutDomainInput>
  }

  export type departmentdomainCreateManyDomainInputEnvelope = {
    data: departmentdomainCreateManyDomainInput | departmentdomainCreateManyDomainInput[]
    skipDuplicates?: boolean
  }

  export type teamCreateWithoutDomainInput = {
    team_name?: string | null
    team_description?: string | null
    status?: $Enums.TeamStatus | null
    visibility?: $Enums.TeamVisibility | null
    max_members?: number | null
    isHiring?: boolean | null
    created_at?: Date | string
    paper?: paperCreateNestedManyWithoutTeamInput
    proposal?: proposalCreateNestedManyWithoutTeamInput
    created_by_user?: userCreateNestedOneWithoutTeamInput
    teamapplication?: teamapplicationCreateNestedManyWithoutTeamInput
    teamcomment?: teamcommentCreateNestedManyWithoutTeamInput
    teammember?: teammemberCreateNestedManyWithoutTeamInput
  }

  export type teamUncheckedCreateWithoutDomainInput = {
    team_id?: number
    team_name?: string | null
    team_description?: string | null
    status?: $Enums.TeamStatus | null
    visibility?: $Enums.TeamVisibility | null
    max_members?: number | null
    isHiring?: boolean | null
    created_at?: Date | string
    created_by_user_id?: number | null
    paper?: paperUncheckedCreateNestedManyWithoutTeamInput
    proposal?: proposalUncheckedCreateNestedManyWithoutTeamInput
    teamapplication?: teamapplicationUncheckedCreateNestedManyWithoutTeamInput
    teamcomment?: teamcommentUncheckedCreateNestedManyWithoutTeamInput
    teammember?: teammemberUncheckedCreateNestedManyWithoutTeamInput
  }

  export type teamCreateOrConnectWithoutDomainInput = {
    where: teamWhereUniqueInput
    create: XOR<teamCreateWithoutDomainInput, teamUncheckedCreateWithoutDomainInput>
  }

  export type teamCreateManyDomainInputEnvelope = {
    data: teamCreateManyDomainInput | teamCreateManyDomainInput[]
    skipDuplicates?: boolean
  }

  export type userdomainCreateWithoutDomainInput = {
    user: userCreateNestedOneWithoutUserdomainInput
  }

  export type userdomainUncheckedCreateWithoutDomainInput = {
    user_id: number
  }

  export type userdomainCreateOrConnectWithoutDomainInput = {
    where: userdomainWhereUniqueInput
    create: XOR<userdomainCreateWithoutDomainInput, userdomainUncheckedCreateWithoutDomainInput>
  }

  export type userdomainCreateManyDomainInputEnvelope = {
    data: userdomainCreateManyDomainInput | userdomainCreateManyDomainInput[]
    skipDuplicates?: boolean
  }

  export type departmentdomainUpsertWithWhereUniqueWithoutDomainInput = {
    where: departmentdomainWhereUniqueInput
    update: XOR<departmentdomainUpdateWithoutDomainInput, departmentdomainUncheckedUpdateWithoutDomainInput>
    create: XOR<departmentdomainCreateWithoutDomainInput, departmentdomainUncheckedCreateWithoutDomainInput>
  }

  export type departmentdomainUpdateWithWhereUniqueWithoutDomainInput = {
    where: departmentdomainWhereUniqueInput
    data: XOR<departmentdomainUpdateWithoutDomainInput, departmentdomainUncheckedUpdateWithoutDomainInput>
  }

  export type departmentdomainUpdateManyWithWhereWithoutDomainInput = {
    where: departmentdomainScalarWhereInput
    data: XOR<departmentdomainUpdateManyMutationInput, departmentdomainUncheckedUpdateManyWithoutDomainInput>
  }

  export type teamUpsertWithWhereUniqueWithoutDomainInput = {
    where: teamWhereUniqueInput
    update: XOR<teamUpdateWithoutDomainInput, teamUncheckedUpdateWithoutDomainInput>
    create: XOR<teamCreateWithoutDomainInput, teamUncheckedCreateWithoutDomainInput>
  }

  export type teamUpdateWithWhereUniqueWithoutDomainInput = {
    where: teamWhereUniqueInput
    data: XOR<teamUpdateWithoutDomainInput, teamUncheckedUpdateWithoutDomainInput>
  }

  export type teamUpdateManyWithWhereWithoutDomainInput = {
    where: teamScalarWhereInput
    data: XOR<teamUpdateManyMutationInput, teamUncheckedUpdateManyWithoutDomainInput>
  }

  export type userdomainUpsertWithWhereUniqueWithoutDomainInput = {
    where: userdomainWhereUniqueInput
    update: XOR<userdomainUpdateWithoutDomainInput, userdomainUncheckedUpdateWithoutDomainInput>
    create: XOR<userdomainCreateWithoutDomainInput, userdomainUncheckedCreateWithoutDomainInput>
  }

  export type userdomainUpdateWithWhereUniqueWithoutDomainInput = {
    where: userdomainWhereUniqueInput
    data: XOR<userdomainUpdateWithoutDomainInput, userdomainUncheckedUpdateWithoutDomainInput>
  }

  export type userdomainUpdateManyWithWhereWithoutDomainInput = {
    where: userdomainScalarWhereInput
    data: XOR<userdomainUpdateManyMutationInput, userdomainUncheckedUpdateManyWithoutDomainInput>
  }

  export type departmentCreateWithoutDepartmentdomainInput = {
    department_name?: string | null
    students?: studentCreateNestedManyWithoutDepartmentInput
    teachers?: teacherCreateNestedManyWithoutDepartmentInput
  }

  export type departmentUncheckedCreateWithoutDepartmentdomainInput = {
    department_id?: number
    department_name?: string | null
    students?: studentUncheckedCreateNestedManyWithoutDepartmentInput
    teachers?: teacherUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type departmentCreateOrConnectWithoutDepartmentdomainInput = {
    where: departmentWhereUniqueInput
    create: XOR<departmentCreateWithoutDepartmentdomainInput, departmentUncheckedCreateWithoutDepartmentdomainInput>
  }

  export type domainCreateWithoutDepartmentdomainInput = {
    domain_name?: string | null
    team?: teamCreateNestedManyWithoutDomainInput
    userdomain?: userdomainCreateNestedManyWithoutDomainInput
  }

  export type domainUncheckedCreateWithoutDepartmentdomainInput = {
    domain_id?: number
    domain_name?: string | null
    team?: teamUncheckedCreateNestedManyWithoutDomainInput
    userdomain?: userdomainUncheckedCreateNestedManyWithoutDomainInput
  }

  export type domainCreateOrConnectWithoutDepartmentdomainInput = {
    where: domainWhereUniqueInput
    create: XOR<domainCreateWithoutDepartmentdomainInput, domainUncheckedCreateWithoutDepartmentdomainInput>
  }

  export type departmentUpsertWithoutDepartmentdomainInput = {
    update: XOR<departmentUpdateWithoutDepartmentdomainInput, departmentUncheckedUpdateWithoutDepartmentdomainInput>
    create: XOR<departmentCreateWithoutDepartmentdomainInput, departmentUncheckedCreateWithoutDepartmentdomainInput>
    where?: departmentWhereInput
  }

  export type departmentUpdateToOneWithWhereWithoutDepartmentdomainInput = {
    where?: departmentWhereInput
    data: XOR<departmentUpdateWithoutDepartmentdomainInput, departmentUncheckedUpdateWithoutDepartmentdomainInput>
  }

  export type departmentUpdateWithoutDepartmentdomainInput = {
    department_name?: NullableStringFieldUpdateOperationsInput | string | null
    students?: studentUpdateManyWithoutDepartmentNestedInput
    teachers?: teacherUpdateManyWithoutDepartmentNestedInput
  }

  export type departmentUncheckedUpdateWithoutDepartmentdomainInput = {
    department_id?: IntFieldUpdateOperationsInput | number
    department_name?: NullableStringFieldUpdateOperationsInput | string | null
    students?: studentUncheckedUpdateManyWithoutDepartmentNestedInput
    teachers?: teacherUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type domainUpsertWithoutDepartmentdomainInput = {
    update: XOR<domainUpdateWithoutDepartmentdomainInput, domainUncheckedUpdateWithoutDepartmentdomainInput>
    create: XOR<domainCreateWithoutDepartmentdomainInput, domainUncheckedCreateWithoutDepartmentdomainInput>
    where?: domainWhereInput
  }

  export type domainUpdateToOneWithWhereWithoutDepartmentdomainInput = {
    where?: domainWhereInput
    data: XOR<domainUpdateWithoutDepartmentdomainInput, domainUncheckedUpdateWithoutDepartmentdomainInput>
  }

  export type domainUpdateWithoutDepartmentdomainInput = {
    domain_name?: NullableStringFieldUpdateOperationsInput | string | null
    team?: teamUpdateManyWithoutDomainNestedInput
    userdomain?: userdomainUpdateManyWithoutDomainNestedInput
  }

  export type domainUncheckedUpdateWithoutDepartmentdomainInput = {
    domain_id?: IntFieldUpdateOperationsInput | number
    domain_name?: NullableStringFieldUpdateOperationsInput | string | null
    team?: teamUncheckedUpdateManyWithoutDomainNestedInput
    userdomain?: userdomainUncheckedUpdateManyWithoutDomainNestedInput
  }

  export type userCreateWithoutGeneraluserInput = {
    name?: string | null
    email?: string | null
    password?: string | null
    profile_image?: string | null
    role?: $Enums.Role | null
    isVerified?: boolean
    isMainAdmin?: boolean
    verifyToken?: string | null
    created_at?: Date | string
    admin?: adminCreateNestedManyWithoutUserInput
    student?: studentCreateNestedManyWithoutUserInput
    teacher?: teacherCreateNestedManyWithoutUserInput
    team?: teamCreateNestedManyWithoutCreated_by_userInput
    teamcomment?: teamcommentCreateNestedManyWithoutUserInput
    teammember?: teammemberCreateNestedManyWithoutUserInput
    userdomain?: userdomainCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutGeneraluserInput = {
    user_id?: number
    name?: string | null
    email?: string | null
    password?: string | null
    profile_image?: string | null
    role?: $Enums.Role | null
    isVerified?: boolean
    isMainAdmin?: boolean
    verifyToken?: string | null
    created_at?: Date | string
    admin?: adminUncheckedCreateNestedManyWithoutUserInput
    student?: studentUncheckedCreateNestedManyWithoutUserInput
    teacher?: teacherUncheckedCreateNestedManyWithoutUserInput
    team?: teamUncheckedCreateNestedManyWithoutCreated_by_userInput
    teamcomment?: teamcommentUncheckedCreateNestedManyWithoutUserInput
    teammember?: teammemberUncheckedCreateNestedManyWithoutUserInput
    userdomain?: userdomainUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutGeneraluserInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutGeneraluserInput, userUncheckedCreateWithoutGeneraluserInput>
  }

  export type userUpsertWithoutGeneraluserInput = {
    update: XOR<userUpdateWithoutGeneraluserInput, userUncheckedUpdateWithoutGeneraluserInput>
    create: XOR<userCreateWithoutGeneraluserInput, userUncheckedCreateWithoutGeneraluserInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutGeneraluserInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutGeneraluserInput, userUncheckedUpdateWithoutGeneraluserInput>
  }

  export type userUpdateWithoutGeneraluserInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isMainAdmin?: BoolFieldUpdateOperationsInput | boolean
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: adminUpdateManyWithoutUserNestedInput
    student?: studentUpdateManyWithoutUserNestedInput
    teacher?: teacherUpdateManyWithoutUserNestedInput
    team?: teamUpdateManyWithoutCreated_by_userNestedInput
    teamcomment?: teamcommentUpdateManyWithoutUserNestedInput
    teammember?: teammemberUpdateManyWithoutUserNestedInput
    userdomain?: userdomainUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutGeneraluserInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isMainAdmin?: BoolFieldUpdateOperationsInput | boolean
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: adminUncheckedUpdateManyWithoutUserNestedInput
    student?: studentUncheckedUpdateManyWithoutUserNestedInput
    teacher?: teacherUncheckedUpdateManyWithoutUserNestedInput
    team?: teamUncheckedUpdateManyWithoutCreated_by_userNestedInput
    teamcomment?: teamcommentUncheckedUpdateManyWithoutUserNestedInput
    teammember?: teammemberUncheckedUpdateManyWithoutUserNestedInput
    userdomain?: userdomainUncheckedUpdateManyWithoutUserNestedInput
  }

  export type departmentCreateWithoutStudentsInput = {
    department_name?: string | null
    departmentdomain?: departmentdomainCreateNestedManyWithoutDepartmentInput
    teachers?: teacherCreateNestedManyWithoutDepartmentInput
  }

  export type departmentUncheckedCreateWithoutStudentsInput = {
    department_id?: number
    department_name?: string | null
    departmentdomain?: departmentdomainUncheckedCreateNestedManyWithoutDepartmentInput
    teachers?: teacherUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type departmentCreateOrConnectWithoutStudentsInput = {
    where: departmentWhereUniqueInput
    create: XOR<departmentCreateWithoutStudentsInput, departmentUncheckedCreateWithoutStudentsInput>
  }

  export type userCreateWithoutStudentInput = {
    name?: string | null
    email?: string | null
    password?: string | null
    profile_image?: string | null
    role?: $Enums.Role | null
    isVerified?: boolean
    isMainAdmin?: boolean
    verifyToken?: string | null
    created_at?: Date | string
    admin?: adminCreateNestedManyWithoutUserInput
    generaluser?: generaluserCreateNestedManyWithoutUserInput
    teacher?: teacherCreateNestedManyWithoutUserInput
    team?: teamCreateNestedManyWithoutCreated_by_userInput
    teamcomment?: teamcommentCreateNestedManyWithoutUserInput
    teammember?: teammemberCreateNestedManyWithoutUserInput
    userdomain?: userdomainCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutStudentInput = {
    user_id?: number
    name?: string | null
    email?: string | null
    password?: string | null
    profile_image?: string | null
    role?: $Enums.Role | null
    isVerified?: boolean
    isMainAdmin?: boolean
    verifyToken?: string | null
    created_at?: Date | string
    admin?: adminUncheckedCreateNestedManyWithoutUserInput
    generaluser?: generaluserUncheckedCreateNestedManyWithoutUserInput
    teacher?: teacherUncheckedCreateNestedManyWithoutUserInput
    team?: teamUncheckedCreateNestedManyWithoutCreated_by_userInput
    teamcomment?: teamcommentUncheckedCreateNestedManyWithoutUserInput
    teammember?: teammemberUncheckedCreateNestedManyWithoutUserInput
    userdomain?: userdomainUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutStudentInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutStudentInput, userUncheckedCreateWithoutStudentInput>
  }

  export type teamapplicationCreateWithoutStudentInput = {
    status?: $Enums.ApplicationStatus
    applied_at?: Date | string
    team: teamCreateNestedOneWithoutTeamapplicationInput
  }

  export type teamapplicationUncheckedCreateWithoutStudentInput = {
    application_id?: number
    team_id: number
    status?: $Enums.ApplicationStatus
    applied_at?: Date | string
  }

  export type teamapplicationCreateOrConnectWithoutStudentInput = {
    where: teamapplicationWhereUniqueInput
    create: XOR<teamapplicationCreateWithoutStudentInput, teamapplicationUncheckedCreateWithoutStudentInput>
  }

  export type teamapplicationCreateManyStudentInputEnvelope = {
    data: teamapplicationCreateManyStudentInput | teamapplicationCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type departmentUpsertWithoutStudentsInput = {
    update: XOR<departmentUpdateWithoutStudentsInput, departmentUncheckedUpdateWithoutStudentsInput>
    create: XOR<departmentCreateWithoutStudentsInput, departmentUncheckedCreateWithoutStudentsInput>
    where?: departmentWhereInput
  }

  export type departmentUpdateToOneWithWhereWithoutStudentsInput = {
    where?: departmentWhereInput
    data: XOR<departmentUpdateWithoutStudentsInput, departmentUncheckedUpdateWithoutStudentsInput>
  }

  export type departmentUpdateWithoutStudentsInput = {
    department_name?: NullableStringFieldUpdateOperationsInput | string | null
    departmentdomain?: departmentdomainUpdateManyWithoutDepartmentNestedInput
    teachers?: teacherUpdateManyWithoutDepartmentNestedInput
  }

  export type departmentUncheckedUpdateWithoutStudentsInput = {
    department_id?: IntFieldUpdateOperationsInput | number
    department_name?: NullableStringFieldUpdateOperationsInput | string | null
    departmentdomain?: departmentdomainUncheckedUpdateManyWithoutDepartmentNestedInput
    teachers?: teacherUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type userUpsertWithoutStudentInput = {
    update: XOR<userUpdateWithoutStudentInput, userUncheckedUpdateWithoutStudentInput>
    create: XOR<userCreateWithoutStudentInput, userUncheckedCreateWithoutStudentInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutStudentInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutStudentInput, userUncheckedUpdateWithoutStudentInput>
  }

  export type userUpdateWithoutStudentInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isMainAdmin?: BoolFieldUpdateOperationsInput | boolean
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: adminUpdateManyWithoutUserNestedInput
    generaluser?: generaluserUpdateManyWithoutUserNestedInput
    teacher?: teacherUpdateManyWithoutUserNestedInput
    team?: teamUpdateManyWithoutCreated_by_userNestedInput
    teamcomment?: teamcommentUpdateManyWithoutUserNestedInput
    teammember?: teammemberUpdateManyWithoutUserNestedInput
    userdomain?: userdomainUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutStudentInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isMainAdmin?: BoolFieldUpdateOperationsInput | boolean
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: adminUncheckedUpdateManyWithoutUserNestedInput
    generaluser?: generaluserUncheckedUpdateManyWithoutUserNestedInput
    teacher?: teacherUncheckedUpdateManyWithoutUserNestedInput
    team?: teamUncheckedUpdateManyWithoutCreated_by_userNestedInput
    teamcomment?: teamcommentUncheckedUpdateManyWithoutUserNestedInput
    teammember?: teammemberUncheckedUpdateManyWithoutUserNestedInput
    userdomain?: userdomainUncheckedUpdateManyWithoutUserNestedInput
  }

  export type teamapplicationUpsertWithWhereUniqueWithoutStudentInput = {
    where: teamapplicationWhereUniqueInput
    update: XOR<teamapplicationUpdateWithoutStudentInput, teamapplicationUncheckedUpdateWithoutStudentInput>
    create: XOR<teamapplicationCreateWithoutStudentInput, teamapplicationUncheckedCreateWithoutStudentInput>
  }

  export type teamapplicationUpdateWithWhereUniqueWithoutStudentInput = {
    where: teamapplicationWhereUniqueInput
    data: XOR<teamapplicationUpdateWithoutStudentInput, teamapplicationUncheckedUpdateWithoutStudentInput>
  }

  export type teamapplicationUpdateManyWithWhereWithoutStudentInput = {
    where: teamapplicationScalarWhereInput
    data: XOR<teamapplicationUpdateManyMutationInput, teamapplicationUncheckedUpdateManyWithoutStudentInput>
  }

  export type teamapplicationScalarWhereInput = {
    AND?: teamapplicationScalarWhereInput | teamapplicationScalarWhereInput[]
    OR?: teamapplicationScalarWhereInput[]
    NOT?: teamapplicationScalarWhereInput | teamapplicationScalarWhereInput[]
    application_id?: IntFilter<"teamapplication"> | number
    team_id?: IntFilter<"teamapplication"> | number
    student_id?: IntFilter<"teamapplication"> | number
    status?: EnumApplicationStatusFilter<"teamapplication"> | $Enums.ApplicationStatus
    applied_at?: DateTimeFilter<"teamapplication"> | Date | string
  }

  export type paperCreateWithoutTeacherInput = {
    title?: string | null
    abstract?: string | null
    status?: $Enums.PaperStatus | null
    pdf_path?: string | null
    file_size?: number | null
    created_at?: Date | string
    aggregated_decided_at?: Date | string | null
    aggregated_decision?: $Enums.ReviewDecision | null
    team?: teamCreateNestedOneWithoutPaperInput
    review?: reviewCreateNestedManyWithoutPaperInput
    reviewerassignment?: reviewerassignmentCreateNestedManyWithoutPaperInput
  }

  export type paperUncheckedCreateWithoutTeacherInput = {
    paper_id?: number
    title?: string | null
    abstract?: string | null
    status?: $Enums.PaperStatus | null
    team_id?: number | null
    pdf_path?: string | null
    file_size?: number | null
    created_at?: Date | string
    aggregated_decided_at?: Date | string | null
    aggregated_decision?: $Enums.ReviewDecision | null
    review?: reviewUncheckedCreateNestedManyWithoutPaperInput
    reviewerassignment?: reviewerassignmentUncheckedCreateNestedManyWithoutPaperInput
  }

  export type paperCreateOrConnectWithoutTeacherInput = {
    where: paperWhereUniqueInput
    create: XOR<paperCreateWithoutTeacherInput, paperUncheckedCreateWithoutTeacherInput>
  }

  export type paperCreateManyTeacherInputEnvelope = {
    data: paperCreateManyTeacherInput | paperCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type proposalCreateWithoutTeacherInput = {
    title?: string | null
    abstract?: string | null
    status?: $Enums.PaperStatus | null
    pdf_path?: string | null
    file_size?: number | null
    created_at?: Date | string
    aggregated_decided_at?: Date | string | null
    aggregated_decision?: $Enums.ReviewDecision | null
    team?: teamCreateNestedOneWithoutProposalInput
    review?: reviewCreateNestedManyWithoutProposalInput
    reviewerassignment?: reviewerassignmentCreateNestedManyWithoutProposalInput
  }

  export type proposalUncheckedCreateWithoutTeacherInput = {
    proposal_id?: number
    title?: string | null
    abstract?: string | null
    status?: $Enums.PaperStatus | null
    team_id?: number | null
    pdf_path?: string | null
    file_size?: number | null
    created_at?: Date | string
    aggregated_decided_at?: Date | string | null
    aggregated_decision?: $Enums.ReviewDecision | null
    review?: reviewUncheckedCreateNestedManyWithoutProposalInput
    reviewerassignment?: reviewerassignmentUncheckedCreateNestedManyWithoutProposalInput
  }

  export type proposalCreateOrConnectWithoutTeacherInput = {
    where: proposalWhereUniqueInput
    create: XOR<proposalCreateWithoutTeacherInput, proposalUncheckedCreateWithoutTeacherInput>
  }

  export type proposalCreateManyTeacherInputEnvelope = {
    data: proposalCreateManyTeacherInput | proposalCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type reviewerCreateWithoutTeacherInput = {
    status?: $Enums.ReviewerStatus | null
    review?: reviewCreateNestedManyWithoutReviewerInput
    reviewerassignment?: reviewerassignmentCreateNestedManyWithoutReviewerInput
  }

  export type reviewerUncheckedCreateWithoutTeacherInput = {
    reviewer_id?: number
    status?: $Enums.ReviewerStatus | null
    review?: reviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewerassignment?: reviewerassignmentUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type reviewerCreateOrConnectWithoutTeacherInput = {
    where: reviewerWhereUniqueInput
    create: XOR<reviewerCreateWithoutTeacherInput, reviewerUncheckedCreateWithoutTeacherInput>
  }

  export type departmentCreateWithoutTeachersInput = {
    department_name?: string | null
    departmentdomain?: departmentdomainCreateNestedManyWithoutDepartmentInput
    students?: studentCreateNestedManyWithoutDepartmentInput
  }

  export type departmentUncheckedCreateWithoutTeachersInput = {
    department_id?: number
    department_name?: string | null
    departmentdomain?: departmentdomainUncheckedCreateNestedManyWithoutDepartmentInput
    students?: studentUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type departmentCreateOrConnectWithoutTeachersInput = {
    where: departmentWhereUniqueInput
    create: XOR<departmentCreateWithoutTeachersInput, departmentUncheckedCreateWithoutTeachersInput>
  }

  export type userCreateWithoutTeacherInput = {
    name?: string | null
    email?: string | null
    password?: string | null
    profile_image?: string | null
    role?: $Enums.Role | null
    isVerified?: boolean
    isMainAdmin?: boolean
    verifyToken?: string | null
    created_at?: Date | string
    admin?: adminCreateNestedManyWithoutUserInput
    generaluser?: generaluserCreateNestedManyWithoutUserInput
    student?: studentCreateNestedManyWithoutUserInput
    team?: teamCreateNestedManyWithoutCreated_by_userInput
    teamcomment?: teamcommentCreateNestedManyWithoutUserInput
    teammember?: teammemberCreateNestedManyWithoutUserInput
    userdomain?: userdomainCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutTeacherInput = {
    user_id?: number
    name?: string | null
    email?: string | null
    password?: string | null
    profile_image?: string | null
    role?: $Enums.Role | null
    isVerified?: boolean
    isMainAdmin?: boolean
    verifyToken?: string | null
    created_at?: Date | string
    admin?: adminUncheckedCreateNestedManyWithoutUserInput
    generaluser?: generaluserUncheckedCreateNestedManyWithoutUserInput
    student?: studentUncheckedCreateNestedManyWithoutUserInput
    team?: teamUncheckedCreateNestedManyWithoutCreated_by_userInput
    teamcomment?: teamcommentUncheckedCreateNestedManyWithoutUserInput
    teammember?: teammemberUncheckedCreateNestedManyWithoutUserInput
    userdomain?: userdomainUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutTeacherInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutTeacherInput, userUncheckedCreateWithoutTeacherInput>
  }

  export type paperUpsertWithWhereUniqueWithoutTeacherInput = {
    where: paperWhereUniqueInput
    update: XOR<paperUpdateWithoutTeacherInput, paperUncheckedUpdateWithoutTeacherInput>
    create: XOR<paperCreateWithoutTeacherInput, paperUncheckedCreateWithoutTeacherInput>
  }

  export type paperUpdateWithWhereUniqueWithoutTeacherInput = {
    where: paperWhereUniqueInput
    data: XOR<paperUpdateWithoutTeacherInput, paperUncheckedUpdateWithoutTeacherInput>
  }

  export type paperUpdateManyWithWhereWithoutTeacherInput = {
    where: paperScalarWhereInput
    data: XOR<paperUpdateManyMutationInput, paperUncheckedUpdateManyWithoutTeacherInput>
  }

  export type paperScalarWhereInput = {
    AND?: paperScalarWhereInput | paperScalarWhereInput[]
    OR?: paperScalarWhereInput[]
    NOT?: paperScalarWhereInput | paperScalarWhereInput[]
    paper_id?: IntFilter<"paper"> | number
    title?: StringNullableFilter<"paper"> | string | null
    abstract?: StringNullableFilter<"paper"> | string | null
    status?: EnumPaperStatusNullableFilter<"paper"> | $Enums.PaperStatus | null
    team_id?: IntNullableFilter<"paper"> | number | null
    submitted_by?: IntNullableFilter<"paper"> | number | null
    pdf_path?: StringNullableFilter<"paper"> | string | null
    file_size?: IntNullableFilter<"paper"> | number | null
    created_at?: DateTimeFilter<"paper"> | Date | string
    aggregated_decided_at?: DateTimeNullableFilter<"paper"> | Date | string | null
    aggregated_decision?: EnumReviewDecisionNullableFilter<"paper"> | $Enums.ReviewDecision | null
  }

  export type proposalUpsertWithWhereUniqueWithoutTeacherInput = {
    where: proposalWhereUniqueInput
    update: XOR<proposalUpdateWithoutTeacherInput, proposalUncheckedUpdateWithoutTeacherInput>
    create: XOR<proposalCreateWithoutTeacherInput, proposalUncheckedCreateWithoutTeacherInput>
  }

  export type proposalUpdateWithWhereUniqueWithoutTeacherInput = {
    where: proposalWhereUniqueInput
    data: XOR<proposalUpdateWithoutTeacherInput, proposalUncheckedUpdateWithoutTeacherInput>
  }

  export type proposalUpdateManyWithWhereWithoutTeacherInput = {
    where: proposalScalarWhereInput
    data: XOR<proposalUpdateManyMutationInput, proposalUncheckedUpdateManyWithoutTeacherInput>
  }

  export type proposalScalarWhereInput = {
    AND?: proposalScalarWhereInput | proposalScalarWhereInput[]
    OR?: proposalScalarWhereInput[]
    NOT?: proposalScalarWhereInput | proposalScalarWhereInput[]
    proposal_id?: IntFilter<"proposal"> | number
    title?: StringNullableFilter<"proposal"> | string | null
    abstract?: StringNullableFilter<"proposal"> | string | null
    status?: EnumPaperStatusNullableFilter<"proposal"> | $Enums.PaperStatus | null
    team_id?: IntNullableFilter<"proposal"> | number | null
    submitted_by?: IntNullableFilter<"proposal"> | number | null
    pdf_path?: StringNullableFilter<"proposal"> | string | null
    file_size?: IntNullableFilter<"proposal"> | number | null
    created_at?: DateTimeFilter<"proposal"> | Date | string
    aggregated_decided_at?: DateTimeNullableFilter<"proposal"> | Date | string | null
    aggregated_decision?: EnumReviewDecisionNullableFilter<"proposal"> | $Enums.ReviewDecision | null
  }

  export type reviewerUpsertWithoutTeacherInput = {
    update: XOR<reviewerUpdateWithoutTeacherInput, reviewerUncheckedUpdateWithoutTeacherInput>
    create: XOR<reviewerCreateWithoutTeacherInput, reviewerUncheckedCreateWithoutTeacherInput>
    where?: reviewerWhereInput
  }

  export type reviewerUpdateToOneWithWhereWithoutTeacherInput = {
    where?: reviewerWhereInput
    data: XOR<reviewerUpdateWithoutTeacherInput, reviewerUncheckedUpdateWithoutTeacherInput>
  }

  export type reviewerUpdateWithoutTeacherInput = {
    status?: NullableEnumReviewerStatusFieldUpdateOperationsInput | $Enums.ReviewerStatus | null
    review?: reviewUpdateManyWithoutReviewerNestedInput
    reviewerassignment?: reviewerassignmentUpdateManyWithoutReviewerNestedInput
  }

  export type reviewerUncheckedUpdateWithoutTeacherInput = {
    reviewer_id?: IntFieldUpdateOperationsInput | number
    status?: NullableEnumReviewerStatusFieldUpdateOperationsInput | $Enums.ReviewerStatus | null
    review?: reviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewerassignment?: reviewerassignmentUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type departmentUpsertWithoutTeachersInput = {
    update: XOR<departmentUpdateWithoutTeachersInput, departmentUncheckedUpdateWithoutTeachersInput>
    create: XOR<departmentCreateWithoutTeachersInput, departmentUncheckedCreateWithoutTeachersInput>
    where?: departmentWhereInput
  }

  export type departmentUpdateToOneWithWhereWithoutTeachersInput = {
    where?: departmentWhereInput
    data: XOR<departmentUpdateWithoutTeachersInput, departmentUncheckedUpdateWithoutTeachersInput>
  }

  export type departmentUpdateWithoutTeachersInput = {
    department_name?: NullableStringFieldUpdateOperationsInput | string | null
    departmentdomain?: departmentdomainUpdateManyWithoutDepartmentNestedInput
    students?: studentUpdateManyWithoutDepartmentNestedInput
  }

  export type departmentUncheckedUpdateWithoutTeachersInput = {
    department_id?: IntFieldUpdateOperationsInput | number
    department_name?: NullableStringFieldUpdateOperationsInput | string | null
    departmentdomain?: departmentdomainUncheckedUpdateManyWithoutDepartmentNestedInput
    students?: studentUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type userUpsertWithoutTeacherInput = {
    update: XOR<userUpdateWithoutTeacherInput, userUncheckedUpdateWithoutTeacherInput>
    create: XOR<userCreateWithoutTeacherInput, userUncheckedCreateWithoutTeacherInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutTeacherInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutTeacherInput, userUncheckedUpdateWithoutTeacherInput>
  }

  export type userUpdateWithoutTeacherInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isMainAdmin?: BoolFieldUpdateOperationsInput | boolean
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: adminUpdateManyWithoutUserNestedInput
    generaluser?: generaluserUpdateManyWithoutUserNestedInput
    student?: studentUpdateManyWithoutUserNestedInput
    team?: teamUpdateManyWithoutCreated_by_userNestedInput
    teamcomment?: teamcommentUpdateManyWithoutUserNestedInput
    teammember?: teammemberUpdateManyWithoutUserNestedInput
    userdomain?: userdomainUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutTeacherInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isMainAdmin?: BoolFieldUpdateOperationsInput | boolean
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: adminUncheckedUpdateManyWithoutUserNestedInput
    generaluser?: generaluserUncheckedUpdateManyWithoutUserNestedInput
    student?: studentUncheckedUpdateManyWithoutUserNestedInput
    team?: teamUncheckedUpdateManyWithoutCreated_by_userNestedInput
    teamcomment?: teamcommentUncheckedUpdateManyWithoutUserNestedInput
    teammember?: teammemberUncheckedUpdateManyWithoutUserNestedInput
    userdomain?: userdomainUncheckedUpdateManyWithoutUserNestedInput
  }

  export type reviewCreateWithoutReviewerInput = {
    comments?: string | null
    score?: number | null
    reviewed_at?: Date | string
    attachment_path?: string | null
    decision?: $Enums.ReviewDecision | null
    paper?: paperCreateNestedOneWithoutReviewInput
    proposal?: proposalCreateNestedOneWithoutReviewInput
  }

  export type reviewUncheckedCreateWithoutReviewerInput = {
    review_id?: number
    proposal_id?: number | null
    paper_id?: number | null
    comments?: string | null
    score?: number | null
    reviewed_at?: Date | string
    attachment_path?: string | null
    decision?: $Enums.ReviewDecision | null
  }

  export type reviewCreateOrConnectWithoutReviewerInput = {
    where: reviewWhereUniqueInput
    create: XOR<reviewCreateWithoutReviewerInput, reviewUncheckedCreateWithoutReviewerInput>
  }

  export type reviewCreateManyReviewerInputEnvelope = {
    data: reviewCreateManyReviewerInput | reviewCreateManyReviewerInput[]
    skipDuplicates?: boolean
  }

  export type teacherCreateWithoutReviewerInput = {
    designation?: string | null
    isReviewer?: boolean
    paper?: paperCreateNestedManyWithoutTeacherInput
    proposal?: proposalCreateNestedManyWithoutTeacherInput
    department?: departmentCreateNestedOneWithoutTeachersInput
    user?: userCreateNestedOneWithoutTeacherInput
  }

  export type teacherUncheckedCreateWithoutReviewerInput = {
    teacher_id?: number
    designation?: string | null
    department_id?: number | null
    user_id?: number | null
    isReviewer?: boolean
    paper?: paperUncheckedCreateNestedManyWithoutTeacherInput
    proposal?: proposalUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type teacherCreateOrConnectWithoutReviewerInput = {
    where: teacherWhereUniqueInput
    create: XOR<teacherCreateWithoutReviewerInput, teacherUncheckedCreateWithoutReviewerInput>
  }

  export type reviewerassignmentCreateWithoutReviewerInput = {
    assigned_date?: Date | string
    due_date: Date | string
    status?: $Enums.AssignmentStatus
    completed_at?: Date | string | null
    started_at?: Date | string | null
    paper?: paperCreateNestedOneWithoutReviewerassignmentInput
    proposal?: proposalCreateNestedOneWithoutReviewerassignmentInput
  }

  export type reviewerassignmentUncheckedCreateWithoutReviewerInput = {
    assignment_id?: number
    proposal_id?: number | null
    paper_id?: number | null
    assigned_date?: Date | string
    due_date: Date | string
    status?: $Enums.AssignmentStatus
    completed_at?: Date | string | null
    started_at?: Date | string | null
  }

  export type reviewerassignmentCreateOrConnectWithoutReviewerInput = {
    where: reviewerassignmentWhereUniqueInput
    create: XOR<reviewerassignmentCreateWithoutReviewerInput, reviewerassignmentUncheckedCreateWithoutReviewerInput>
  }

  export type reviewerassignmentCreateManyReviewerInputEnvelope = {
    data: reviewerassignmentCreateManyReviewerInput | reviewerassignmentCreateManyReviewerInput[]
    skipDuplicates?: boolean
  }

  export type reviewUpsertWithWhereUniqueWithoutReviewerInput = {
    where: reviewWhereUniqueInput
    update: XOR<reviewUpdateWithoutReviewerInput, reviewUncheckedUpdateWithoutReviewerInput>
    create: XOR<reviewCreateWithoutReviewerInput, reviewUncheckedCreateWithoutReviewerInput>
  }

  export type reviewUpdateWithWhereUniqueWithoutReviewerInput = {
    where: reviewWhereUniqueInput
    data: XOR<reviewUpdateWithoutReviewerInput, reviewUncheckedUpdateWithoutReviewerInput>
  }

  export type reviewUpdateManyWithWhereWithoutReviewerInput = {
    where: reviewScalarWhereInput
    data: XOR<reviewUpdateManyMutationInput, reviewUncheckedUpdateManyWithoutReviewerInput>
  }

  export type reviewScalarWhereInput = {
    AND?: reviewScalarWhereInput | reviewScalarWhereInput[]
    OR?: reviewScalarWhereInput[]
    NOT?: reviewScalarWhereInput | reviewScalarWhereInput[]
    review_id?: IntFilter<"review"> | number
    reviewer_id?: IntNullableFilter<"review"> | number | null
    proposal_id?: IntNullableFilter<"review"> | number | null
    paper_id?: IntNullableFilter<"review"> | number | null
    comments?: StringNullableFilter<"review"> | string | null
    score?: IntNullableFilter<"review"> | number | null
    reviewed_at?: DateTimeFilter<"review"> | Date | string
    attachment_path?: StringNullableFilter<"review"> | string | null
    decision?: EnumReviewDecisionNullableFilter<"review"> | $Enums.ReviewDecision | null
  }

  export type teacherUpsertWithoutReviewerInput = {
    update: XOR<teacherUpdateWithoutReviewerInput, teacherUncheckedUpdateWithoutReviewerInput>
    create: XOR<teacherCreateWithoutReviewerInput, teacherUncheckedCreateWithoutReviewerInput>
    where?: teacherWhereInput
  }

  export type teacherUpdateToOneWithWhereWithoutReviewerInput = {
    where?: teacherWhereInput
    data: XOR<teacherUpdateWithoutReviewerInput, teacherUncheckedUpdateWithoutReviewerInput>
  }

  export type teacherUpdateWithoutReviewerInput = {
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    isReviewer?: BoolFieldUpdateOperationsInput | boolean
    paper?: paperUpdateManyWithoutTeacherNestedInput
    proposal?: proposalUpdateManyWithoutTeacherNestedInput
    department?: departmentUpdateOneWithoutTeachersNestedInput
    user?: userUpdateOneWithoutTeacherNestedInput
  }

  export type teacherUncheckedUpdateWithoutReviewerInput = {
    teacher_id?: IntFieldUpdateOperationsInput | number
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    department_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    isReviewer?: BoolFieldUpdateOperationsInput | boolean
    paper?: paperUncheckedUpdateManyWithoutTeacherNestedInput
    proposal?: proposalUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type reviewerassignmentUpsertWithWhereUniqueWithoutReviewerInput = {
    where: reviewerassignmentWhereUniqueInput
    update: XOR<reviewerassignmentUpdateWithoutReviewerInput, reviewerassignmentUncheckedUpdateWithoutReviewerInput>
    create: XOR<reviewerassignmentCreateWithoutReviewerInput, reviewerassignmentUncheckedCreateWithoutReviewerInput>
  }

  export type reviewerassignmentUpdateWithWhereUniqueWithoutReviewerInput = {
    where: reviewerassignmentWhereUniqueInput
    data: XOR<reviewerassignmentUpdateWithoutReviewerInput, reviewerassignmentUncheckedUpdateWithoutReviewerInput>
  }

  export type reviewerassignmentUpdateManyWithWhereWithoutReviewerInput = {
    where: reviewerassignmentScalarWhereInput
    data: XOR<reviewerassignmentUpdateManyMutationInput, reviewerassignmentUncheckedUpdateManyWithoutReviewerInput>
  }

  export type reviewerassignmentScalarWhereInput = {
    AND?: reviewerassignmentScalarWhereInput | reviewerassignmentScalarWhereInput[]
    OR?: reviewerassignmentScalarWhereInput[]
    NOT?: reviewerassignmentScalarWhereInput | reviewerassignmentScalarWhereInput[]
    assignment_id?: IntFilter<"reviewerassignment"> | number
    reviewer_id?: IntFilter<"reviewerassignment"> | number
    proposal_id?: IntNullableFilter<"reviewerassignment"> | number | null
    paper_id?: IntNullableFilter<"reviewerassignment"> | number | null
    assigned_date?: DateTimeFilter<"reviewerassignment"> | Date | string
    due_date?: DateTimeFilter<"reviewerassignment"> | Date | string
    status?: EnumAssignmentStatusFilter<"reviewerassignment"> | $Enums.AssignmentStatus
    completed_at?: DateTimeNullableFilter<"reviewerassignment"> | Date | string | null
    started_at?: DateTimeNullableFilter<"reviewerassignment"> | Date | string | null
  }

  export type paperCreateWithoutTeamInput = {
    title?: string | null
    abstract?: string | null
    status?: $Enums.PaperStatus | null
    pdf_path?: string | null
    file_size?: number | null
    created_at?: Date | string
    aggregated_decided_at?: Date | string | null
    aggregated_decision?: $Enums.ReviewDecision | null
    teacher?: teacherCreateNestedOneWithoutPaperInput
    review?: reviewCreateNestedManyWithoutPaperInput
    reviewerassignment?: reviewerassignmentCreateNestedManyWithoutPaperInput
  }

  export type paperUncheckedCreateWithoutTeamInput = {
    paper_id?: number
    title?: string | null
    abstract?: string | null
    status?: $Enums.PaperStatus | null
    submitted_by?: number | null
    pdf_path?: string | null
    file_size?: number | null
    created_at?: Date | string
    aggregated_decided_at?: Date | string | null
    aggregated_decision?: $Enums.ReviewDecision | null
    review?: reviewUncheckedCreateNestedManyWithoutPaperInput
    reviewerassignment?: reviewerassignmentUncheckedCreateNestedManyWithoutPaperInput
  }

  export type paperCreateOrConnectWithoutTeamInput = {
    where: paperWhereUniqueInput
    create: XOR<paperCreateWithoutTeamInput, paperUncheckedCreateWithoutTeamInput>
  }

  export type paperCreateManyTeamInputEnvelope = {
    data: paperCreateManyTeamInput | paperCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type proposalCreateWithoutTeamInput = {
    title?: string | null
    abstract?: string | null
    status?: $Enums.PaperStatus | null
    pdf_path?: string | null
    file_size?: number | null
    created_at?: Date | string
    aggregated_decided_at?: Date | string | null
    aggregated_decision?: $Enums.ReviewDecision | null
    teacher?: teacherCreateNestedOneWithoutProposalInput
    review?: reviewCreateNestedManyWithoutProposalInput
    reviewerassignment?: reviewerassignmentCreateNestedManyWithoutProposalInput
  }

  export type proposalUncheckedCreateWithoutTeamInput = {
    proposal_id?: number
    title?: string | null
    abstract?: string | null
    status?: $Enums.PaperStatus | null
    submitted_by?: number | null
    pdf_path?: string | null
    file_size?: number | null
    created_at?: Date | string
    aggregated_decided_at?: Date | string | null
    aggregated_decision?: $Enums.ReviewDecision | null
    review?: reviewUncheckedCreateNestedManyWithoutProposalInput
    reviewerassignment?: reviewerassignmentUncheckedCreateNestedManyWithoutProposalInput
  }

  export type proposalCreateOrConnectWithoutTeamInput = {
    where: proposalWhereUniqueInput
    create: XOR<proposalCreateWithoutTeamInput, proposalUncheckedCreateWithoutTeamInput>
  }

  export type proposalCreateManyTeamInputEnvelope = {
    data: proposalCreateManyTeamInput | proposalCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type userCreateWithoutTeamInput = {
    name?: string | null
    email?: string | null
    password?: string | null
    profile_image?: string | null
    role?: $Enums.Role | null
    isVerified?: boolean
    isMainAdmin?: boolean
    verifyToken?: string | null
    created_at?: Date | string
    admin?: adminCreateNestedManyWithoutUserInput
    generaluser?: generaluserCreateNestedManyWithoutUserInput
    student?: studentCreateNestedManyWithoutUserInput
    teacher?: teacherCreateNestedManyWithoutUserInput
    teamcomment?: teamcommentCreateNestedManyWithoutUserInput
    teammember?: teammemberCreateNestedManyWithoutUserInput
    userdomain?: userdomainCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutTeamInput = {
    user_id?: number
    name?: string | null
    email?: string | null
    password?: string | null
    profile_image?: string | null
    role?: $Enums.Role | null
    isVerified?: boolean
    isMainAdmin?: boolean
    verifyToken?: string | null
    created_at?: Date | string
    admin?: adminUncheckedCreateNestedManyWithoutUserInput
    generaluser?: generaluserUncheckedCreateNestedManyWithoutUserInput
    student?: studentUncheckedCreateNestedManyWithoutUserInput
    teacher?: teacherUncheckedCreateNestedManyWithoutUserInput
    teamcomment?: teamcommentUncheckedCreateNestedManyWithoutUserInput
    teammember?: teammemberUncheckedCreateNestedManyWithoutUserInput
    userdomain?: userdomainUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutTeamInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutTeamInput, userUncheckedCreateWithoutTeamInput>
  }

  export type domainCreateWithoutTeamInput = {
    domain_name?: string | null
    departmentdomain?: departmentdomainCreateNestedManyWithoutDomainInput
    userdomain?: userdomainCreateNestedManyWithoutDomainInput
  }

  export type domainUncheckedCreateWithoutTeamInput = {
    domain_id?: number
    domain_name?: string | null
    departmentdomain?: departmentdomainUncheckedCreateNestedManyWithoutDomainInput
    userdomain?: userdomainUncheckedCreateNestedManyWithoutDomainInput
  }

  export type domainCreateOrConnectWithoutTeamInput = {
    where: domainWhereUniqueInput
    create: XOR<domainCreateWithoutTeamInput, domainUncheckedCreateWithoutTeamInput>
  }

  export type teamapplicationCreateWithoutTeamInput = {
    status?: $Enums.ApplicationStatus
    applied_at?: Date | string
    student: studentCreateNestedOneWithoutTeamapplicationInput
  }

  export type teamapplicationUncheckedCreateWithoutTeamInput = {
    application_id?: number
    student_id: number
    status?: $Enums.ApplicationStatus
    applied_at?: Date | string
  }

  export type teamapplicationCreateOrConnectWithoutTeamInput = {
    where: teamapplicationWhereUniqueInput
    create: XOR<teamapplicationCreateWithoutTeamInput, teamapplicationUncheckedCreateWithoutTeamInput>
  }

  export type teamapplicationCreateManyTeamInputEnvelope = {
    data: teamapplicationCreateManyTeamInput | teamapplicationCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type teamcommentCreateWithoutTeamInput = {
    comment: string
    created_at?: Date | string
    user: userCreateNestedOneWithoutTeamcommentInput
  }

  export type teamcommentUncheckedCreateWithoutTeamInput = {
    comment_id?: number
    user_id: number
    comment: string
    created_at?: Date | string
  }

  export type teamcommentCreateOrConnectWithoutTeamInput = {
    where: teamcommentWhereUniqueInput
    create: XOR<teamcommentCreateWithoutTeamInput, teamcommentUncheckedCreateWithoutTeamInput>
  }

  export type teamcommentCreateManyTeamInputEnvelope = {
    data: teamcommentCreateManyTeamInput | teamcommentCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type teammemberCreateWithoutTeamInput = {
    role_in_team?: $Enums.TeamRole | null
    user: userCreateNestedOneWithoutTeammemberInput
  }

  export type teammemberUncheckedCreateWithoutTeamInput = {
    user_id: number
    role_in_team?: $Enums.TeamRole | null
  }

  export type teammemberCreateOrConnectWithoutTeamInput = {
    where: teammemberWhereUniqueInput
    create: XOR<teammemberCreateWithoutTeamInput, teammemberUncheckedCreateWithoutTeamInput>
  }

  export type teammemberCreateManyTeamInputEnvelope = {
    data: teammemberCreateManyTeamInput | teammemberCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type paperUpsertWithWhereUniqueWithoutTeamInput = {
    where: paperWhereUniqueInput
    update: XOR<paperUpdateWithoutTeamInput, paperUncheckedUpdateWithoutTeamInput>
    create: XOR<paperCreateWithoutTeamInput, paperUncheckedCreateWithoutTeamInput>
  }

  export type paperUpdateWithWhereUniqueWithoutTeamInput = {
    where: paperWhereUniqueInput
    data: XOR<paperUpdateWithoutTeamInput, paperUncheckedUpdateWithoutTeamInput>
  }

  export type paperUpdateManyWithWhereWithoutTeamInput = {
    where: paperScalarWhereInput
    data: XOR<paperUpdateManyMutationInput, paperUncheckedUpdateManyWithoutTeamInput>
  }

  export type proposalUpsertWithWhereUniqueWithoutTeamInput = {
    where: proposalWhereUniqueInput
    update: XOR<proposalUpdateWithoutTeamInput, proposalUncheckedUpdateWithoutTeamInput>
    create: XOR<proposalCreateWithoutTeamInput, proposalUncheckedCreateWithoutTeamInput>
  }

  export type proposalUpdateWithWhereUniqueWithoutTeamInput = {
    where: proposalWhereUniqueInput
    data: XOR<proposalUpdateWithoutTeamInput, proposalUncheckedUpdateWithoutTeamInput>
  }

  export type proposalUpdateManyWithWhereWithoutTeamInput = {
    where: proposalScalarWhereInput
    data: XOR<proposalUpdateManyMutationInput, proposalUncheckedUpdateManyWithoutTeamInput>
  }

  export type userUpsertWithoutTeamInput = {
    update: XOR<userUpdateWithoutTeamInput, userUncheckedUpdateWithoutTeamInput>
    create: XOR<userCreateWithoutTeamInput, userUncheckedCreateWithoutTeamInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutTeamInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutTeamInput, userUncheckedUpdateWithoutTeamInput>
  }

  export type userUpdateWithoutTeamInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isMainAdmin?: BoolFieldUpdateOperationsInput | boolean
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: adminUpdateManyWithoutUserNestedInput
    generaluser?: generaluserUpdateManyWithoutUserNestedInput
    student?: studentUpdateManyWithoutUserNestedInput
    teacher?: teacherUpdateManyWithoutUserNestedInput
    teamcomment?: teamcommentUpdateManyWithoutUserNestedInput
    teammember?: teammemberUpdateManyWithoutUserNestedInput
    userdomain?: userdomainUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutTeamInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isMainAdmin?: BoolFieldUpdateOperationsInput | boolean
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: adminUncheckedUpdateManyWithoutUserNestedInput
    generaluser?: generaluserUncheckedUpdateManyWithoutUserNestedInput
    student?: studentUncheckedUpdateManyWithoutUserNestedInput
    teacher?: teacherUncheckedUpdateManyWithoutUserNestedInput
    teamcomment?: teamcommentUncheckedUpdateManyWithoutUserNestedInput
    teammember?: teammemberUncheckedUpdateManyWithoutUserNestedInput
    userdomain?: userdomainUncheckedUpdateManyWithoutUserNestedInput
  }

  export type domainUpsertWithoutTeamInput = {
    update: XOR<domainUpdateWithoutTeamInput, domainUncheckedUpdateWithoutTeamInput>
    create: XOR<domainCreateWithoutTeamInput, domainUncheckedCreateWithoutTeamInput>
    where?: domainWhereInput
  }

  export type domainUpdateToOneWithWhereWithoutTeamInput = {
    where?: domainWhereInput
    data: XOR<domainUpdateWithoutTeamInput, domainUncheckedUpdateWithoutTeamInput>
  }

  export type domainUpdateWithoutTeamInput = {
    domain_name?: NullableStringFieldUpdateOperationsInput | string | null
    departmentdomain?: departmentdomainUpdateManyWithoutDomainNestedInput
    userdomain?: userdomainUpdateManyWithoutDomainNestedInput
  }

  export type domainUncheckedUpdateWithoutTeamInput = {
    domain_id?: IntFieldUpdateOperationsInput | number
    domain_name?: NullableStringFieldUpdateOperationsInput | string | null
    departmentdomain?: departmentdomainUncheckedUpdateManyWithoutDomainNestedInput
    userdomain?: userdomainUncheckedUpdateManyWithoutDomainNestedInput
  }

  export type teamapplicationUpsertWithWhereUniqueWithoutTeamInput = {
    where: teamapplicationWhereUniqueInput
    update: XOR<teamapplicationUpdateWithoutTeamInput, teamapplicationUncheckedUpdateWithoutTeamInput>
    create: XOR<teamapplicationCreateWithoutTeamInput, teamapplicationUncheckedCreateWithoutTeamInput>
  }

  export type teamapplicationUpdateWithWhereUniqueWithoutTeamInput = {
    where: teamapplicationWhereUniqueInput
    data: XOR<teamapplicationUpdateWithoutTeamInput, teamapplicationUncheckedUpdateWithoutTeamInput>
  }

  export type teamapplicationUpdateManyWithWhereWithoutTeamInput = {
    where: teamapplicationScalarWhereInput
    data: XOR<teamapplicationUpdateManyMutationInput, teamapplicationUncheckedUpdateManyWithoutTeamInput>
  }

  export type teamcommentUpsertWithWhereUniqueWithoutTeamInput = {
    where: teamcommentWhereUniqueInput
    update: XOR<teamcommentUpdateWithoutTeamInput, teamcommentUncheckedUpdateWithoutTeamInput>
    create: XOR<teamcommentCreateWithoutTeamInput, teamcommentUncheckedCreateWithoutTeamInput>
  }

  export type teamcommentUpdateWithWhereUniqueWithoutTeamInput = {
    where: teamcommentWhereUniqueInput
    data: XOR<teamcommentUpdateWithoutTeamInput, teamcommentUncheckedUpdateWithoutTeamInput>
  }

  export type teamcommentUpdateManyWithWhereWithoutTeamInput = {
    where: teamcommentScalarWhereInput
    data: XOR<teamcommentUpdateManyMutationInput, teamcommentUncheckedUpdateManyWithoutTeamInput>
  }

  export type teammemberUpsertWithWhereUniqueWithoutTeamInput = {
    where: teammemberWhereUniqueInput
    update: XOR<teammemberUpdateWithoutTeamInput, teammemberUncheckedUpdateWithoutTeamInput>
    create: XOR<teammemberCreateWithoutTeamInput, teammemberUncheckedCreateWithoutTeamInput>
  }

  export type teammemberUpdateWithWhereUniqueWithoutTeamInput = {
    where: teammemberWhereUniqueInput
    data: XOR<teammemberUpdateWithoutTeamInput, teammemberUncheckedUpdateWithoutTeamInput>
  }

  export type teammemberUpdateManyWithWhereWithoutTeamInput = {
    where: teammemberScalarWhereInput
    data: XOR<teammemberUpdateManyMutationInput, teammemberUncheckedUpdateManyWithoutTeamInput>
  }

  export type teamCreateWithoutTeammemberInput = {
    team_name?: string | null
    team_description?: string | null
    status?: $Enums.TeamStatus | null
    visibility?: $Enums.TeamVisibility | null
    max_members?: number | null
    isHiring?: boolean | null
    created_at?: Date | string
    paper?: paperCreateNestedManyWithoutTeamInput
    proposal?: proposalCreateNestedManyWithoutTeamInput
    created_by_user?: userCreateNestedOneWithoutTeamInput
    domain?: domainCreateNestedOneWithoutTeamInput
    teamapplication?: teamapplicationCreateNestedManyWithoutTeamInput
    teamcomment?: teamcommentCreateNestedManyWithoutTeamInput
  }

  export type teamUncheckedCreateWithoutTeammemberInput = {
    team_id?: number
    team_name?: string | null
    team_description?: string | null
    domain_id?: number | null
    status?: $Enums.TeamStatus | null
    visibility?: $Enums.TeamVisibility | null
    max_members?: number | null
    isHiring?: boolean | null
    created_at?: Date | string
    created_by_user_id?: number | null
    paper?: paperUncheckedCreateNestedManyWithoutTeamInput
    proposal?: proposalUncheckedCreateNestedManyWithoutTeamInput
    teamapplication?: teamapplicationUncheckedCreateNestedManyWithoutTeamInput
    teamcomment?: teamcommentUncheckedCreateNestedManyWithoutTeamInput
  }

  export type teamCreateOrConnectWithoutTeammemberInput = {
    where: teamWhereUniqueInput
    create: XOR<teamCreateWithoutTeammemberInput, teamUncheckedCreateWithoutTeammemberInput>
  }

  export type userCreateWithoutTeammemberInput = {
    name?: string | null
    email?: string | null
    password?: string | null
    profile_image?: string | null
    role?: $Enums.Role | null
    isVerified?: boolean
    isMainAdmin?: boolean
    verifyToken?: string | null
    created_at?: Date | string
    admin?: adminCreateNestedManyWithoutUserInput
    generaluser?: generaluserCreateNestedManyWithoutUserInput
    student?: studentCreateNestedManyWithoutUserInput
    teacher?: teacherCreateNestedManyWithoutUserInput
    team?: teamCreateNestedManyWithoutCreated_by_userInput
    teamcomment?: teamcommentCreateNestedManyWithoutUserInput
    userdomain?: userdomainCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutTeammemberInput = {
    user_id?: number
    name?: string | null
    email?: string | null
    password?: string | null
    profile_image?: string | null
    role?: $Enums.Role | null
    isVerified?: boolean
    isMainAdmin?: boolean
    verifyToken?: string | null
    created_at?: Date | string
    admin?: adminUncheckedCreateNestedManyWithoutUserInput
    generaluser?: generaluserUncheckedCreateNestedManyWithoutUserInput
    student?: studentUncheckedCreateNestedManyWithoutUserInput
    teacher?: teacherUncheckedCreateNestedManyWithoutUserInput
    team?: teamUncheckedCreateNestedManyWithoutCreated_by_userInput
    teamcomment?: teamcommentUncheckedCreateNestedManyWithoutUserInput
    userdomain?: userdomainUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutTeammemberInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutTeammemberInput, userUncheckedCreateWithoutTeammemberInput>
  }

  export type teamUpsertWithoutTeammemberInput = {
    update: XOR<teamUpdateWithoutTeammemberInput, teamUncheckedUpdateWithoutTeammemberInput>
    create: XOR<teamCreateWithoutTeammemberInput, teamUncheckedCreateWithoutTeammemberInput>
    where?: teamWhereInput
  }

  export type teamUpdateToOneWithWhereWithoutTeammemberInput = {
    where?: teamWhereInput
    data: XOR<teamUpdateWithoutTeammemberInput, teamUncheckedUpdateWithoutTeammemberInput>
  }

  export type teamUpdateWithoutTeammemberInput = {
    team_name?: NullableStringFieldUpdateOperationsInput | string | null
    team_description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumTeamStatusFieldUpdateOperationsInput | $Enums.TeamStatus | null
    visibility?: NullableEnumTeamVisibilityFieldUpdateOperationsInput | $Enums.TeamVisibility | null
    max_members?: NullableIntFieldUpdateOperationsInput | number | null
    isHiring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    paper?: paperUpdateManyWithoutTeamNestedInput
    proposal?: proposalUpdateManyWithoutTeamNestedInput
    created_by_user?: userUpdateOneWithoutTeamNestedInput
    domain?: domainUpdateOneWithoutTeamNestedInput
    teamapplication?: teamapplicationUpdateManyWithoutTeamNestedInput
    teamcomment?: teamcommentUpdateManyWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateWithoutTeammemberInput = {
    team_id?: IntFieldUpdateOperationsInput | number
    team_name?: NullableStringFieldUpdateOperationsInput | string | null
    team_description?: NullableStringFieldUpdateOperationsInput | string | null
    domain_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumTeamStatusFieldUpdateOperationsInput | $Enums.TeamStatus | null
    visibility?: NullableEnumTeamVisibilityFieldUpdateOperationsInput | $Enums.TeamVisibility | null
    max_members?: NullableIntFieldUpdateOperationsInput | number | null
    isHiring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    paper?: paperUncheckedUpdateManyWithoutTeamNestedInput
    proposal?: proposalUncheckedUpdateManyWithoutTeamNestedInput
    teamapplication?: teamapplicationUncheckedUpdateManyWithoutTeamNestedInput
    teamcomment?: teamcommentUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type userUpsertWithoutTeammemberInput = {
    update: XOR<userUpdateWithoutTeammemberInput, userUncheckedUpdateWithoutTeammemberInput>
    create: XOR<userCreateWithoutTeammemberInput, userUncheckedCreateWithoutTeammemberInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutTeammemberInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutTeammemberInput, userUncheckedUpdateWithoutTeammemberInput>
  }

  export type userUpdateWithoutTeammemberInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isMainAdmin?: BoolFieldUpdateOperationsInput | boolean
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: adminUpdateManyWithoutUserNestedInput
    generaluser?: generaluserUpdateManyWithoutUserNestedInput
    student?: studentUpdateManyWithoutUserNestedInput
    teacher?: teacherUpdateManyWithoutUserNestedInput
    team?: teamUpdateManyWithoutCreated_by_userNestedInput
    teamcomment?: teamcommentUpdateManyWithoutUserNestedInput
    userdomain?: userdomainUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutTeammemberInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isMainAdmin?: BoolFieldUpdateOperationsInput | boolean
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: adminUncheckedUpdateManyWithoutUserNestedInput
    generaluser?: generaluserUncheckedUpdateManyWithoutUserNestedInput
    student?: studentUncheckedUpdateManyWithoutUserNestedInput
    teacher?: teacherUncheckedUpdateManyWithoutUserNestedInput
    team?: teamUncheckedUpdateManyWithoutCreated_by_userNestedInput
    teamcomment?: teamcommentUncheckedUpdateManyWithoutUserNestedInput
    userdomain?: userdomainUncheckedUpdateManyWithoutUserNestedInput
  }

  export type studentCreateWithoutTeamapplicationInput = {
    roll_number?: string | null
    department?: departmentCreateNestedOneWithoutStudentsInput
    user?: userCreateNestedOneWithoutStudentInput
  }

  export type studentUncheckedCreateWithoutTeamapplicationInput = {
    student_id?: number
    roll_number?: string | null
    department_id?: number | null
    user_id?: number | null
  }

  export type studentCreateOrConnectWithoutTeamapplicationInput = {
    where: studentWhereUniqueInput
    create: XOR<studentCreateWithoutTeamapplicationInput, studentUncheckedCreateWithoutTeamapplicationInput>
  }

  export type teamCreateWithoutTeamapplicationInput = {
    team_name?: string | null
    team_description?: string | null
    status?: $Enums.TeamStatus | null
    visibility?: $Enums.TeamVisibility | null
    max_members?: number | null
    isHiring?: boolean | null
    created_at?: Date | string
    paper?: paperCreateNestedManyWithoutTeamInput
    proposal?: proposalCreateNestedManyWithoutTeamInput
    created_by_user?: userCreateNestedOneWithoutTeamInput
    domain?: domainCreateNestedOneWithoutTeamInput
    teamcomment?: teamcommentCreateNestedManyWithoutTeamInput
    teammember?: teammemberCreateNestedManyWithoutTeamInput
  }

  export type teamUncheckedCreateWithoutTeamapplicationInput = {
    team_id?: number
    team_name?: string | null
    team_description?: string | null
    domain_id?: number | null
    status?: $Enums.TeamStatus | null
    visibility?: $Enums.TeamVisibility | null
    max_members?: number | null
    isHiring?: boolean | null
    created_at?: Date | string
    created_by_user_id?: number | null
    paper?: paperUncheckedCreateNestedManyWithoutTeamInput
    proposal?: proposalUncheckedCreateNestedManyWithoutTeamInput
    teamcomment?: teamcommentUncheckedCreateNestedManyWithoutTeamInput
    teammember?: teammemberUncheckedCreateNestedManyWithoutTeamInput
  }

  export type teamCreateOrConnectWithoutTeamapplicationInput = {
    where: teamWhereUniqueInput
    create: XOR<teamCreateWithoutTeamapplicationInput, teamUncheckedCreateWithoutTeamapplicationInput>
  }

  export type studentUpsertWithoutTeamapplicationInput = {
    update: XOR<studentUpdateWithoutTeamapplicationInput, studentUncheckedUpdateWithoutTeamapplicationInput>
    create: XOR<studentCreateWithoutTeamapplicationInput, studentUncheckedCreateWithoutTeamapplicationInput>
    where?: studentWhereInput
  }

  export type studentUpdateToOneWithWhereWithoutTeamapplicationInput = {
    where?: studentWhereInput
    data: XOR<studentUpdateWithoutTeamapplicationInput, studentUncheckedUpdateWithoutTeamapplicationInput>
  }

  export type studentUpdateWithoutTeamapplicationInput = {
    roll_number?: NullableStringFieldUpdateOperationsInput | string | null
    department?: departmentUpdateOneWithoutStudentsNestedInput
    user?: userUpdateOneWithoutStudentNestedInput
  }

  export type studentUncheckedUpdateWithoutTeamapplicationInput = {
    student_id?: IntFieldUpdateOperationsInput | number
    roll_number?: NullableStringFieldUpdateOperationsInput | string | null
    department_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type teamUpsertWithoutTeamapplicationInput = {
    update: XOR<teamUpdateWithoutTeamapplicationInput, teamUncheckedUpdateWithoutTeamapplicationInput>
    create: XOR<teamCreateWithoutTeamapplicationInput, teamUncheckedCreateWithoutTeamapplicationInput>
    where?: teamWhereInput
  }

  export type teamUpdateToOneWithWhereWithoutTeamapplicationInput = {
    where?: teamWhereInput
    data: XOR<teamUpdateWithoutTeamapplicationInput, teamUncheckedUpdateWithoutTeamapplicationInput>
  }

  export type teamUpdateWithoutTeamapplicationInput = {
    team_name?: NullableStringFieldUpdateOperationsInput | string | null
    team_description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumTeamStatusFieldUpdateOperationsInput | $Enums.TeamStatus | null
    visibility?: NullableEnumTeamVisibilityFieldUpdateOperationsInput | $Enums.TeamVisibility | null
    max_members?: NullableIntFieldUpdateOperationsInput | number | null
    isHiring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    paper?: paperUpdateManyWithoutTeamNestedInput
    proposal?: proposalUpdateManyWithoutTeamNestedInput
    created_by_user?: userUpdateOneWithoutTeamNestedInput
    domain?: domainUpdateOneWithoutTeamNestedInput
    teamcomment?: teamcommentUpdateManyWithoutTeamNestedInput
    teammember?: teammemberUpdateManyWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateWithoutTeamapplicationInput = {
    team_id?: IntFieldUpdateOperationsInput | number
    team_name?: NullableStringFieldUpdateOperationsInput | string | null
    team_description?: NullableStringFieldUpdateOperationsInput | string | null
    domain_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumTeamStatusFieldUpdateOperationsInput | $Enums.TeamStatus | null
    visibility?: NullableEnumTeamVisibilityFieldUpdateOperationsInput | $Enums.TeamVisibility | null
    max_members?: NullableIntFieldUpdateOperationsInput | number | null
    isHiring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    paper?: paperUncheckedUpdateManyWithoutTeamNestedInput
    proposal?: proposalUncheckedUpdateManyWithoutTeamNestedInput
    teamcomment?: teamcommentUncheckedUpdateManyWithoutTeamNestedInput
    teammember?: teammemberUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type teamCreateWithoutTeamcommentInput = {
    team_name?: string | null
    team_description?: string | null
    status?: $Enums.TeamStatus | null
    visibility?: $Enums.TeamVisibility | null
    max_members?: number | null
    isHiring?: boolean | null
    created_at?: Date | string
    paper?: paperCreateNestedManyWithoutTeamInput
    proposal?: proposalCreateNestedManyWithoutTeamInput
    created_by_user?: userCreateNestedOneWithoutTeamInput
    domain?: domainCreateNestedOneWithoutTeamInput
    teamapplication?: teamapplicationCreateNestedManyWithoutTeamInput
    teammember?: teammemberCreateNestedManyWithoutTeamInput
  }

  export type teamUncheckedCreateWithoutTeamcommentInput = {
    team_id?: number
    team_name?: string | null
    team_description?: string | null
    domain_id?: number | null
    status?: $Enums.TeamStatus | null
    visibility?: $Enums.TeamVisibility | null
    max_members?: number | null
    isHiring?: boolean | null
    created_at?: Date | string
    created_by_user_id?: number | null
    paper?: paperUncheckedCreateNestedManyWithoutTeamInput
    proposal?: proposalUncheckedCreateNestedManyWithoutTeamInput
    teamapplication?: teamapplicationUncheckedCreateNestedManyWithoutTeamInput
    teammember?: teammemberUncheckedCreateNestedManyWithoutTeamInput
  }

  export type teamCreateOrConnectWithoutTeamcommentInput = {
    where: teamWhereUniqueInput
    create: XOR<teamCreateWithoutTeamcommentInput, teamUncheckedCreateWithoutTeamcommentInput>
  }

  export type userCreateWithoutTeamcommentInput = {
    name?: string | null
    email?: string | null
    password?: string | null
    profile_image?: string | null
    role?: $Enums.Role | null
    isVerified?: boolean
    isMainAdmin?: boolean
    verifyToken?: string | null
    created_at?: Date | string
    admin?: adminCreateNestedManyWithoutUserInput
    generaluser?: generaluserCreateNestedManyWithoutUserInput
    student?: studentCreateNestedManyWithoutUserInput
    teacher?: teacherCreateNestedManyWithoutUserInput
    team?: teamCreateNestedManyWithoutCreated_by_userInput
    teammember?: teammemberCreateNestedManyWithoutUserInput
    userdomain?: userdomainCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutTeamcommentInput = {
    user_id?: number
    name?: string | null
    email?: string | null
    password?: string | null
    profile_image?: string | null
    role?: $Enums.Role | null
    isVerified?: boolean
    isMainAdmin?: boolean
    verifyToken?: string | null
    created_at?: Date | string
    admin?: adminUncheckedCreateNestedManyWithoutUserInput
    generaluser?: generaluserUncheckedCreateNestedManyWithoutUserInput
    student?: studentUncheckedCreateNestedManyWithoutUserInput
    teacher?: teacherUncheckedCreateNestedManyWithoutUserInput
    team?: teamUncheckedCreateNestedManyWithoutCreated_by_userInput
    teammember?: teammemberUncheckedCreateNestedManyWithoutUserInput
    userdomain?: userdomainUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutTeamcommentInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutTeamcommentInput, userUncheckedCreateWithoutTeamcommentInput>
  }

  export type teamUpsertWithoutTeamcommentInput = {
    update: XOR<teamUpdateWithoutTeamcommentInput, teamUncheckedUpdateWithoutTeamcommentInput>
    create: XOR<teamCreateWithoutTeamcommentInput, teamUncheckedCreateWithoutTeamcommentInput>
    where?: teamWhereInput
  }

  export type teamUpdateToOneWithWhereWithoutTeamcommentInput = {
    where?: teamWhereInput
    data: XOR<teamUpdateWithoutTeamcommentInput, teamUncheckedUpdateWithoutTeamcommentInput>
  }

  export type teamUpdateWithoutTeamcommentInput = {
    team_name?: NullableStringFieldUpdateOperationsInput | string | null
    team_description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumTeamStatusFieldUpdateOperationsInput | $Enums.TeamStatus | null
    visibility?: NullableEnumTeamVisibilityFieldUpdateOperationsInput | $Enums.TeamVisibility | null
    max_members?: NullableIntFieldUpdateOperationsInput | number | null
    isHiring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    paper?: paperUpdateManyWithoutTeamNestedInput
    proposal?: proposalUpdateManyWithoutTeamNestedInput
    created_by_user?: userUpdateOneWithoutTeamNestedInput
    domain?: domainUpdateOneWithoutTeamNestedInput
    teamapplication?: teamapplicationUpdateManyWithoutTeamNestedInput
    teammember?: teammemberUpdateManyWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateWithoutTeamcommentInput = {
    team_id?: IntFieldUpdateOperationsInput | number
    team_name?: NullableStringFieldUpdateOperationsInput | string | null
    team_description?: NullableStringFieldUpdateOperationsInput | string | null
    domain_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumTeamStatusFieldUpdateOperationsInput | $Enums.TeamStatus | null
    visibility?: NullableEnumTeamVisibilityFieldUpdateOperationsInput | $Enums.TeamVisibility | null
    max_members?: NullableIntFieldUpdateOperationsInput | number | null
    isHiring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    paper?: paperUncheckedUpdateManyWithoutTeamNestedInput
    proposal?: proposalUncheckedUpdateManyWithoutTeamNestedInput
    teamapplication?: teamapplicationUncheckedUpdateManyWithoutTeamNestedInput
    teammember?: teammemberUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type userUpsertWithoutTeamcommentInput = {
    update: XOR<userUpdateWithoutTeamcommentInput, userUncheckedUpdateWithoutTeamcommentInput>
    create: XOR<userCreateWithoutTeamcommentInput, userUncheckedCreateWithoutTeamcommentInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutTeamcommentInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutTeamcommentInput, userUncheckedUpdateWithoutTeamcommentInput>
  }

  export type userUpdateWithoutTeamcommentInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isMainAdmin?: BoolFieldUpdateOperationsInput | boolean
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: adminUpdateManyWithoutUserNestedInput
    generaluser?: generaluserUpdateManyWithoutUserNestedInput
    student?: studentUpdateManyWithoutUserNestedInput
    teacher?: teacherUpdateManyWithoutUserNestedInput
    team?: teamUpdateManyWithoutCreated_by_userNestedInput
    teammember?: teammemberUpdateManyWithoutUserNestedInput
    userdomain?: userdomainUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutTeamcommentInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isMainAdmin?: BoolFieldUpdateOperationsInput | boolean
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: adminUncheckedUpdateManyWithoutUserNestedInput
    generaluser?: generaluserUncheckedUpdateManyWithoutUserNestedInput
    student?: studentUncheckedUpdateManyWithoutUserNestedInput
    teacher?: teacherUncheckedUpdateManyWithoutUserNestedInput
    team?: teamUncheckedUpdateManyWithoutCreated_by_userNestedInput
    teammember?: teammemberUncheckedUpdateManyWithoutUserNestedInput
    userdomain?: userdomainUncheckedUpdateManyWithoutUserNestedInput
  }

  export type teacherCreateWithoutPaperInput = {
    designation?: string | null
    isReviewer?: boolean
    proposal?: proposalCreateNestedManyWithoutTeacherInput
    reviewer?: reviewerCreateNestedOneWithoutTeacherInput
    department?: departmentCreateNestedOneWithoutTeachersInput
    user?: userCreateNestedOneWithoutTeacherInput
  }

  export type teacherUncheckedCreateWithoutPaperInput = {
    teacher_id?: number
    designation?: string | null
    department_id?: number | null
    user_id?: number | null
    isReviewer?: boolean
    proposal?: proposalUncheckedCreateNestedManyWithoutTeacherInput
    reviewer?: reviewerUncheckedCreateNestedOneWithoutTeacherInput
  }

  export type teacherCreateOrConnectWithoutPaperInput = {
    where: teacherWhereUniqueInput
    create: XOR<teacherCreateWithoutPaperInput, teacherUncheckedCreateWithoutPaperInput>
  }

  export type teamCreateWithoutPaperInput = {
    team_name?: string | null
    team_description?: string | null
    status?: $Enums.TeamStatus | null
    visibility?: $Enums.TeamVisibility | null
    max_members?: number | null
    isHiring?: boolean | null
    created_at?: Date | string
    proposal?: proposalCreateNestedManyWithoutTeamInput
    created_by_user?: userCreateNestedOneWithoutTeamInput
    domain?: domainCreateNestedOneWithoutTeamInput
    teamapplication?: teamapplicationCreateNestedManyWithoutTeamInput
    teamcomment?: teamcommentCreateNestedManyWithoutTeamInput
    teammember?: teammemberCreateNestedManyWithoutTeamInput
  }

  export type teamUncheckedCreateWithoutPaperInput = {
    team_id?: number
    team_name?: string | null
    team_description?: string | null
    domain_id?: number | null
    status?: $Enums.TeamStatus | null
    visibility?: $Enums.TeamVisibility | null
    max_members?: number | null
    isHiring?: boolean | null
    created_at?: Date | string
    created_by_user_id?: number | null
    proposal?: proposalUncheckedCreateNestedManyWithoutTeamInput
    teamapplication?: teamapplicationUncheckedCreateNestedManyWithoutTeamInput
    teamcomment?: teamcommentUncheckedCreateNestedManyWithoutTeamInput
    teammember?: teammemberUncheckedCreateNestedManyWithoutTeamInput
  }

  export type teamCreateOrConnectWithoutPaperInput = {
    where: teamWhereUniqueInput
    create: XOR<teamCreateWithoutPaperInput, teamUncheckedCreateWithoutPaperInput>
  }

  export type reviewCreateWithoutPaperInput = {
    comments?: string | null
    score?: number | null
    reviewed_at?: Date | string
    attachment_path?: string | null
    decision?: $Enums.ReviewDecision | null
    proposal?: proposalCreateNestedOneWithoutReviewInput
    reviewer?: reviewerCreateNestedOneWithoutReviewInput
  }

  export type reviewUncheckedCreateWithoutPaperInput = {
    review_id?: number
    reviewer_id?: number | null
    proposal_id?: number | null
    comments?: string | null
    score?: number | null
    reviewed_at?: Date | string
    attachment_path?: string | null
    decision?: $Enums.ReviewDecision | null
  }

  export type reviewCreateOrConnectWithoutPaperInput = {
    where: reviewWhereUniqueInput
    create: XOR<reviewCreateWithoutPaperInput, reviewUncheckedCreateWithoutPaperInput>
  }

  export type reviewCreateManyPaperInputEnvelope = {
    data: reviewCreateManyPaperInput | reviewCreateManyPaperInput[]
    skipDuplicates?: boolean
  }

  export type reviewerassignmentCreateWithoutPaperInput = {
    assigned_date?: Date | string
    due_date: Date | string
    status?: $Enums.AssignmentStatus
    completed_at?: Date | string | null
    started_at?: Date | string | null
    proposal?: proposalCreateNestedOneWithoutReviewerassignmentInput
    reviewer: reviewerCreateNestedOneWithoutReviewerassignmentInput
  }

  export type reviewerassignmentUncheckedCreateWithoutPaperInput = {
    assignment_id?: number
    reviewer_id: number
    proposal_id?: number | null
    assigned_date?: Date | string
    due_date: Date | string
    status?: $Enums.AssignmentStatus
    completed_at?: Date | string | null
    started_at?: Date | string | null
  }

  export type reviewerassignmentCreateOrConnectWithoutPaperInput = {
    where: reviewerassignmentWhereUniqueInput
    create: XOR<reviewerassignmentCreateWithoutPaperInput, reviewerassignmentUncheckedCreateWithoutPaperInput>
  }

  export type reviewerassignmentCreateManyPaperInputEnvelope = {
    data: reviewerassignmentCreateManyPaperInput | reviewerassignmentCreateManyPaperInput[]
    skipDuplicates?: boolean
  }

  export type teacherUpsertWithoutPaperInput = {
    update: XOR<teacherUpdateWithoutPaperInput, teacherUncheckedUpdateWithoutPaperInput>
    create: XOR<teacherCreateWithoutPaperInput, teacherUncheckedCreateWithoutPaperInput>
    where?: teacherWhereInput
  }

  export type teacherUpdateToOneWithWhereWithoutPaperInput = {
    where?: teacherWhereInput
    data: XOR<teacherUpdateWithoutPaperInput, teacherUncheckedUpdateWithoutPaperInput>
  }

  export type teacherUpdateWithoutPaperInput = {
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    isReviewer?: BoolFieldUpdateOperationsInput | boolean
    proposal?: proposalUpdateManyWithoutTeacherNestedInput
    reviewer?: reviewerUpdateOneWithoutTeacherNestedInput
    department?: departmentUpdateOneWithoutTeachersNestedInput
    user?: userUpdateOneWithoutTeacherNestedInput
  }

  export type teacherUncheckedUpdateWithoutPaperInput = {
    teacher_id?: IntFieldUpdateOperationsInput | number
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    department_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    isReviewer?: BoolFieldUpdateOperationsInput | boolean
    proposal?: proposalUncheckedUpdateManyWithoutTeacherNestedInput
    reviewer?: reviewerUncheckedUpdateOneWithoutTeacherNestedInput
  }

  export type teamUpsertWithoutPaperInput = {
    update: XOR<teamUpdateWithoutPaperInput, teamUncheckedUpdateWithoutPaperInput>
    create: XOR<teamCreateWithoutPaperInput, teamUncheckedCreateWithoutPaperInput>
    where?: teamWhereInput
  }

  export type teamUpdateToOneWithWhereWithoutPaperInput = {
    where?: teamWhereInput
    data: XOR<teamUpdateWithoutPaperInput, teamUncheckedUpdateWithoutPaperInput>
  }

  export type teamUpdateWithoutPaperInput = {
    team_name?: NullableStringFieldUpdateOperationsInput | string | null
    team_description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumTeamStatusFieldUpdateOperationsInput | $Enums.TeamStatus | null
    visibility?: NullableEnumTeamVisibilityFieldUpdateOperationsInput | $Enums.TeamVisibility | null
    max_members?: NullableIntFieldUpdateOperationsInput | number | null
    isHiring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    proposal?: proposalUpdateManyWithoutTeamNestedInput
    created_by_user?: userUpdateOneWithoutTeamNestedInput
    domain?: domainUpdateOneWithoutTeamNestedInput
    teamapplication?: teamapplicationUpdateManyWithoutTeamNestedInput
    teamcomment?: teamcommentUpdateManyWithoutTeamNestedInput
    teammember?: teammemberUpdateManyWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateWithoutPaperInput = {
    team_id?: IntFieldUpdateOperationsInput | number
    team_name?: NullableStringFieldUpdateOperationsInput | string | null
    team_description?: NullableStringFieldUpdateOperationsInput | string | null
    domain_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumTeamStatusFieldUpdateOperationsInput | $Enums.TeamStatus | null
    visibility?: NullableEnumTeamVisibilityFieldUpdateOperationsInput | $Enums.TeamVisibility | null
    max_members?: NullableIntFieldUpdateOperationsInput | number | null
    isHiring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    proposal?: proposalUncheckedUpdateManyWithoutTeamNestedInput
    teamapplication?: teamapplicationUncheckedUpdateManyWithoutTeamNestedInput
    teamcomment?: teamcommentUncheckedUpdateManyWithoutTeamNestedInput
    teammember?: teammemberUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type reviewUpsertWithWhereUniqueWithoutPaperInput = {
    where: reviewWhereUniqueInput
    update: XOR<reviewUpdateWithoutPaperInput, reviewUncheckedUpdateWithoutPaperInput>
    create: XOR<reviewCreateWithoutPaperInput, reviewUncheckedCreateWithoutPaperInput>
  }

  export type reviewUpdateWithWhereUniqueWithoutPaperInput = {
    where: reviewWhereUniqueInput
    data: XOR<reviewUpdateWithoutPaperInput, reviewUncheckedUpdateWithoutPaperInput>
  }

  export type reviewUpdateManyWithWhereWithoutPaperInput = {
    where: reviewScalarWhereInput
    data: XOR<reviewUpdateManyMutationInput, reviewUncheckedUpdateManyWithoutPaperInput>
  }

  export type reviewerassignmentUpsertWithWhereUniqueWithoutPaperInput = {
    where: reviewerassignmentWhereUniqueInput
    update: XOR<reviewerassignmentUpdateWithoutPaperInput, reviewerassignmentUncheckedUpdateWithoutPaperInput>
    create: XOR<reviewerassignmentCreateWithoutPaperInput, reviewerassignmentUncheckedCreateWithoutPaperInput>
  }

  export type reviewerassignmentUpdateWithWhereUniqueWithoutPaperInput = {
    where: reviewerassignmentWhereUniqueInput
    data: XOR<reviewerassignmentUpdateWithoutPaperInput, reviewerassignmentUncheckedUpdateWithoutPaperInput>
  }

  export type reviewerassignmentUpdateManyWithWhereWithoutPaperInput = {
    where: reviewerassignmentScalarWhereInput
    data: XOR<reviewerassignmentUpdateManyMutationInput, reviewerassignmentUncheckedUpdateManyWithoutPaperInput>
  }

  export type teacherCreateWithoutProposalInput = {
    designation?: string | null
    isReviewer?: boolean
    paper?: paperCreateNestedManyWithoutTeacherInput
    reviewer?: reviewerCreateNestedOneWithoutTeacherInput
    department?: departmentCreateNestedOneWithoutTeachersInput
    user?: userCreateNestedOneWithoutTeacherInput
  }

  export type teacherUncheckedCreateWithoutProposalInput = {
    teacher_id?: number
    designation?: string | null
    department_id?: number | null
    user_id?: number | null
    isReviewer?: boolean
    paper?: paperUncheckedCreateNestedManyWithoutTeacherInput
    reviewer?: reviewerUncheckedCreateNestedOneWithoutTeacherInput
  }

  export type teacherCreateOrConnectWithoutProposalInput = {
    where: teacherWhereUniqueInput
    create: XOR<teacherCreateWithoutProposalInput, teacherUncheckedCreateWithoutProposalInput>
  }

  export type teamCreateWithoutProposalInput = {
    team_name?: string | null
    team_description?: string | null
    status?: $Enums.TeamStatus | null
    visibility?: $Enums.TeamVisibility | null
    max_members?: number | null
    isHiring?: boolean | null
    created_at?: Date | string
    paper?: paperCreateNestedManyWithoutTeamInput
    created_by_user?: userCreateNestedOneWithoutTeamInput
    domain?: domainCreateNestedOneWithoutTeamInput
    teamapplication?: teamapplicationCreateNestedManyWithoutTeamInput
    teamcomment?: teamcommentCreateNestedManyWithoutTeamInput
    teammember?: teammemberCreateNestedManyWithoutTeamInput
  }

  export type teamUncheckedCreateWithoutProposalInput = {
    team_id?: number
    team_name?: string | null
    team_description?: string | null
    domain_id?: number | null
    status?: $Enums.TeamStatus | null
    visibility?: $Enums.TeamVisibility | null
    max_members?: number | null
    isHiring?: boolean | null
    created_at?: Date | string
    created_by_user_id?: number | null
    paper?: paperUncheckedCreateNestedManyWithoutTeamInput
    teamapplication?: teamapplicationUncheckedCreateNestedManyWithoutTeamInput
    teamcomment?: teamcommentUncheckedCreateNestedManyWithoutTeamInput
    teammember?: teammemberUncheckedCreateNestedManyWithoutTeamInput
  }

  export type teamCreateOrConnectWithoutProposalInput = {
    where: teamWhereUniqueInput
    create: XOR<teamCreateWithoutProposalInput, teamUncheckedCreateWithoutProposalInput>
  }

  export type reviewCreateWithoutProposalInput = {
    comments?: string | null
    score?: number | null
    reviewed_at?: Date | string
    attachment_path?: string | null
    decision?: $Enums.ReviewDecision | null
    paper?: paperCreateNestedOneWithoutReviewInput
    reviewer?: reviewerCreateNestedOneWithoutReviewInput
  }

  export type reviewUncheckedCreateWithoutProposalInput = {
    review_id?: number
    reviewer_id?: number | null
    paper_id?: number | null
    comments?: string | null
    score?: number | null
    reviewed_at?: Date | string
    attachment_path?: string | null
    decision?: $Enums.ReviewDecision | null
  }

  export type reviewCreateOrConnectWithoutProposalInput = {
    where: reviewWhereUniqueInput
    create: XOR<reviewCreateWithoutProposalInput, reviewUncheckedCreateWithoutProposalInput>
  }

  export type reviewCreateManyProposalInputEnvelope = {
    data: reviewCreateManyProposalInput | reviewCreateManyProposalInput[]
    skipDuplicates?: boolean
  }

  export type reviewerassignmentCreateWithoutProposalInput = {
    assigned_date?: Date | string
    due_date: Date | string
    status?: $Enums.AssignmentStatus
    completed_at?: Date | string | null
    started_at?: Date | string | null
    paper?: paperCreateNestedOneWithoutReviewerassignmentInput
    reviewer: reviewerCreateNestedOneWithoutReviewerassignmentInput
  }

  export type reviewerassignmentUncheckedCreateWithoutProposalInput = {
    assignment_id?: number
    reviewer_id: number
    paper_id?: number | null
    assigned_date?: Date | string
    due_date: Date | string
    status?: $Enums.AssignmentStatus
    completed_at?: Date | string | null
    started_at?: Date | string | null
  }

  export type reviewerassignmentCreateOrConnectWithoutProposalInput = {
    where: reviewerassignmentWhereUniqueInput
    create: XOR<reviewerassignmentCreateWithoutProposalInput, reviewerassignmentUncheckedCreateWithoutProposalInput>
  }

  export type reviewerassignmentCreateManyProposalInputEnvelope = {
    data: reviewerassignmentCreateManyProposalInput | reviewerassignmentCreateManyProposalInput[]
    skipDuplicates?: boolean
  }

  export type teacherUpsertWithoutProposalInput = {
    update: XOR<teacherUpdateWithoutProposalInput, teacherUncheckedUpdateWithoutProposalInput>
    create: XOR<teacherCreateWithoutProposalInput, teacherUncheckedCreateWithoutProposalInput>
    where?: teacherWhereInput
  }

  export type teacherUpdateToOneWithWhereWithoutProposalInput = {
    where?: teacherWhereInput
    data: XOR<teacherUpdateWithoutProposalInput, teacherUncheckedUpdateWithoutProposalInput>
  }

  export type teacherUpdateWithoutProposalInput = {
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    isReviewer?: BoolFieldUpdateOperationsInput | boolean
    paper?: paperUpdateManyWithoutTeacherNestedInput
    reviewer?: reviewerUpdateOneWithoutTeacherNestedInput
    department?: departmentUpdateOneWithoutTeachersNestedInput
    user?: userUpdateOneWithoutTeacherNestedInput
  }

  export type teacherUncheckedUpdateWithoutProposalInput = {
    teacher_id?: IntFieldUpdateOperationsInput | number
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    department_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    isReviewer?: BoolFieldUpdateOperationsInput | boolean
    paper?: paperUncheckedUpdateManyWithoutTeacherNestedInput
    reviewer?: reviewerUncheckedUpdateOneWithoutTeacherNestedInput
  }

  export type teamUpsertWithoutProposalInput = {
    update: XOR<teamUpdateWithoutProposalInput, teamUncheckedUpdateWithoutProposalInput>
    create: XOR<teamCreateWithoutProposalInput, teamUncheckedCreateWithoutProposalInput>
    where?: teamWhereInput
  }

  export type teamUpdateToOneWithWhereWithoutProposalInput = {
    where?: teamWhereInput
    data: XOR<teamUpdateWithoutProposalInput, teamUncheckedUpdateWithoutProposalInput>
  }

  export type teamUpdateWithoutProposalInput = {
    team_name?: NullableStringFieldUpdateOperationsInput | string | null
    team_description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumTeamStatusFieldUpdateOperationsInput | $Enums.TeamStatus | null
    visibility?: NullableEnumTeamVisibilityFieldUpdateOperationsInput | $Enums.TeamVisibility | null
    max_members?: NullableIntFieldUpdateOperationsInput | number | null
    isHiring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    paper?: paperUpdateManyWithoutTeamNestedInput
    created_by_user?: userUpdateOneWithoutTeamNestedInput
    domain?: domainUpdateOneWithoutTeamNestedInput
    teamapplication?: teamapplicationUpdateManyWithoutTeamNestedInput
    teamcomment?: teamcommentUpdateManyWithoutTeamNestedInput
    teammember?: teammemberUpdateManyWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateWithoutProposalInput = {
    team_id?: IntFieldUpdateOperationsInput | number
    team_name?: NullableStringFieldUpdateOperationsInput | string | null
    team_description?: NullableStringFieldUpdateOperationsInput | string | null
    domain_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumTeamStatusFieldUpdateOperationsInput | $Enums.TeamStatus | null
    visibility?: NullableEnumTeamVisibilityFieldUpdateOperationsInput | $Enums.TeamVisibility | null
    max_members?: NullableIntFieldUpdateOperationsInput | number | null
    isHiring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    paper?: paperUncheckedUpdateManyWithoutTeamNestedInput
    teamapplication?: teamapplicationUncheckedUpdateManyWithoutTeamNestedInput
    teamcomment?: teamcommentUncheckedUpdateManyWithoutTeamNestedInput
    teammember?: teammemberUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type reviewUpsertWithWhereUniqueWithoutProposalInput = {
    where: reviewWhereUniqueInput
    update: XOR<reviewUpdateWithoutProposalInput, reviewUncheckedUpdateWithoutProposalInput>
    create: XOR<reviewCreateWithoutProposalInput, reviewUncheckedCreateWithoutProposalInput>
  }

  export type reviewUpdateWithWhereUniqueWithoutProposalInput = {
    where: reviewWhereUniqueInput
    data: XOR<reviewUpdateWithoutProposalInput, reviewUncheckedUpdateWithoutProposalInput>
  }

  export type reviewUpdateManyWithWhereWithoutProposalInput = {
    where: reviewScalarWhereInput
    data: XOR<reviewUpdateManyMutationInput, reviewUncheckedUpdateManyWithoutProposalInput>
  }

  export type reviewerassignmentUpsertWithWhereUniqueWithoutProposalInput = {
    where: reviewerassignmentWhereUniqueInput
    update: XOR<reviewerassignmentUpdateWithoutProposalInput, reviewerassignmentUncheckedUpdateWithoutProposalInput>
    create: XOR<reviewerassignmentCreateWithoutProposalInput, reviewerassignmentUncheckedCreateWithoutProposalInput>
  }

  export type reviewerassignmentUpdateWithWhereUniqueWithoutProposalInput = {
    where: reviewerassignmentWhereUniqueInput
    data: XOR<reviewerassignmentUpdateWithoutProposalInput, reviewerassignmentUncheckedUpdateWithoutProposalInput>
  }

  export type reviewerassignmentUpdateManyWithWhereWithoutProposalInput = {
    where: reviewerassignmentScalarWhereInput
    data: XOR<reviewerassignmentUpdateManyMutationInput, reviewerassignmentUncheckedUpdateManyWithoutProposalInput>
  }

  export type paperCreateWithoutReviewInput = {
    title?: string | null
    abstract?: string | null
    status?: $Enums.PaperStatus | null
    pdf_path?: string | null
    file_size?: number | null
    created_at?: Date | string
    aggregated_decided_at?: Date | string | null
    aggregated_decision?: $Enums.ReviewDecision | null
    teacher?: teacherCreateNestedOneWithoutPaperInput
    team?: teamCreateNestedOneWithoutPaperInput
    reviewerassignment?: reviewerassignmentCreateNestedManyWithoutPaperInput
  }

  export type paperUncheckedCreateWithoutReviewInput = {
    paper_id?: number
    title?: string | null
    abstract?: string | null
    status?: $Enums.PaperStatus | null
    team_id?: number | null
    submitted_by?: number | null
    pdf_path?: string | null
    file_size?: number | null
    created_at?: Date | string
    aggregated_decided_at?: Date | string | null
    aggregated_decision?: $Enums.ReviewDecision | null
    reviewerassignment?: reviewerassignmentUncheckedCreateNestedManyWithoutPaperInput
  }

  export type paperCreateOrConnectWithoutReviewInput = {
    where: paperWhereUniqueInput
    create: XOR<paperCreateWithoutReviewInput, paperUncheckedCreateWithoutReviewInput>
  }

  export type proposalCreateWithoutReviewInput = {
    title?: string | null
    abstract?: string | null
    status?: $Enums.PaperStatus | null
    pdf_path?: string | null
    file_size?: number | null
    created_at?: Date | string
    aggregated_decided_at?: Date | string | null
    aggregated_decision?: $Enums.ReviewDecision | null
    teacher?: teacherCreateNestedOneWithoutProposalInput
    team?: teamCreateNestedOneWithoutProposalInput
    reviewerassignment?: reviewerassignmentCreateNestedManyWithoutProposalInput
  }

  export type proposalUncheckedCreateWithoutReviewInput = {
    proposal_id?: number
    title?: string | null
    abstract?: string | null
    status?: $Enums.PaperStatus | null
    team_id?: number | null
    submitted_by?: number | null
    pdf_path?: string | null
    file_size?: number | null
    created_at?: Date | string
    aggregated_decided_at?: Date | string | null
    aggregated_decision?: $Enums.ReviewDecision | null
    reviewerassignment?: reviewerassignmentUncheckedCreateNestedManyWithoutProposalInput
  }

  export type proposalCreateOrConnectWithoutReviewInput = {
    where: proposalWhereUniqueInput
    create: XOR<proposalCreateWithoutReviewInput, proposalUncheckedCreateWithoutReviewInput>
  }

  export type reviewerCreateWithoutReviewInput = {
    status?: $Enums.ReviewerStatus | null
    teacher?: teacherCreateNestedOneWithoutReviewerInput
    reviewerassignment?: reviewerassignmentCreateNestedManyWithoutReviewerInput
  }

  export type reviewerUncheckedCreateWithoutReviewInput = {
    reviewer_id?: number
    teacher_id?: number | null
    status?: $Enums.ReviewerStatus | null
    reviewerassignment?: reviewerassignmentUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type reviewerCreateOrConnectWithoutReviewInput = {
    where: reviewerWhereUniqueInput
    create: XOR<reviewerCreateWithoutReviewInput, reviewerUncheckedCreateWithoutReviewInput>
  }

  export type paperUpsertWithoutReviewInput = {
    update: XOR<paperUpdateWithoutReviewInput, paperUncheckedUpdateWithoutReviewInput>
    create: XOR<paperCreateWithoutReviewInput, paperUncheckedCreateWithoutReviewInput>
    where?: paperWhereInput
  }

  export type paperUpdateToOneWithWhereWithoutReviewInput = {
    where?: paperWhereInput
    data: XOR<paperUpdateWithoutReviewInput, paperUncheckedUpdateWithoutReviewInput>
  }

  export type paperUpdateWithoutReviewInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumPaperStatusFieldUpdateOperationsInput | $Enums.PaperStatus | null
    pdf_path?: NullableStringFieldUpdateOperationsInput | string | null
    file_size?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    aggregated_decided_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aggregated_decision?: NullableEnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision | null
    teacher?: teacherUpdateOneWithoutPaperNestedInput
    team?: teamUpdateOneWithoutPaperNestedInput
    reviewerassignment?: reviewerassignmentUpdateManyWithoutPaperNestedInput
  }

  export type paperUncheckedUpdateWithoutReviewInput = {
    paper_id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumPaperStatusFieldUpdateOperationsInput | $Enums.PaperStatus | null
    team_id?: NullableIntFieldUpdateOperationsInput | number | null
    submitted_by?: NullableIntFieldUpdateOperationsInput | number | null
    pdf_path?: NullableStringFieldUpdateOperationsInput | string | null
    file_size?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    aggregated_decided_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aggregated_decision?: NullableEnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision | null
    reviewerassignment?: reviewerassignmentUncheckedUpdateManyWithoutPaperNestedInput
  }

  export type proposalUpsertWithoutReviewInput = {
    update: XOR<proposalUpdateWithoutReviewInput, proposalUncheckedUpdateWithoutReviewInput>
    create: XOR<proposalCreateWithoutReviewInput, proposalUncheckedCreateWithoutReviewInput>
    where?: proposalWhereInput
  }

  export type proposalUpdateToOneWithWhereWithoutReviewInput = {
    where?: proposalWhereInput
    data: XOR<proposalUpdateWithoutReviewInput, proposalUncheckedUpdateWithoutReviewInput>
  }

  export type proposalUpdateWithoutReviewInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumPaperStatusFieldUpdateOperationsInput | $Enums.PaperStatus | null
    pdf_path?: NullableStringFieldUpdateOperationsInput | string | null
    file_size?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    aggregated_decided_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aggregated_decision?: NullableEnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision | null
    teacher?: teacherUpdateOneWithoutProposalNestedInput
    team?: teamUpdateOneWithoutProposalNestedInput
    reviewerassignment?: reviewerassignmentUpdateManyWithoutProposalNestedInput
  }

  export type proposalUncheckedUpdateWithoutReviewInput = {
    proposal_id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumPaperStatusFieldUpdateOperationsInput | $Enums.PaperStatus | null
    team_id?: NullableIntFieldUpdateOperationsInput | number | null
    submitted_by?: NullableIntFieldUpdateOperationsInput | number | null
    pdf_path?: NullableStringFieldUpdateOperationsInput | string | null
    file_size?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    aggregated_decided_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aggregated_decision?: NullableEnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision | null
    reviewerassignment?: reviewerassignmentUncheckedUpdateManyWithoutProposalNestedInput
  }

  export type reviewerUpsertWithoutReviewInput = {
    update: XOR<reviewerUpdateWithoutReviewInput, reviewerUncheckedUpdateWithoutReviewInput>
    create: XOR<reviewerCreateWithoutReviewInput, reviewerUncheckedCreateWithoutReviewInput>
    where?: reviewerWhereInput
  }

  export type reviewerUpdateToOneWithWhereWithoutReviewInput = {
    where?: reviewerWhereInput
    data: XOR<reviewerUpdateWithoutReviewInput, reviewerUncheckedUpdateWithoutReviewInput>
  }

  export type reviewerUpdateWithoutReviewInput = {
    status?: NullableEnumReviewerStatusFieldUpdateOperationsInput | $Enums.ReviewerStatus | null
    teacher?: teacherUpdateOneWithoutReviewerNestedInput
    reviewerassignment?: reviewerassignmentUpdateManyWithoutReviewerNestedInput
  }

  export type reviewerUncheckedUpdateWithoutReviewInput = {
    reviewer_id?: IntFieldUpdateOperationsInput | number
    teacher_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumReviewerStatusFieldUpdateOperationsInput | $Enums.ReviewerStatus | null
    reviewerassignment?: reviewerassignmentUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type paperCreateWithoutReviewerassignmentInput = {
    title?: string | null
    abstract?: string | null
    status?: $Enums.PaperStatus | null
    pdf_path?: string | null
    file_size?: number | null
    created_at?: Date | string
    aggregated_decided_at?: Date | string | null
    aggregated_decision?: $Enums.ReviewDecision | null
    teacher?: teacherCreateNestedOneWithoutPaperInput
    team?: teamCreateNestedOneWithoutPaperInput
    review?: reviewCreateNestedManyWithoutPaperInput
  }

  export type paperUncheckedCreateWithoutReviewerassignmentInput = {
    paper_id?: number
    title?: string | null
    abstract?: string | null
    status?: $Enums.PaperStatus | null
    team_id?: number | null
    submitted_by?: number | null
    pdf_path?: string | null
    file_size?: number | null
    created_at?: Date | string
    aggregated_decided_at?: Date | string | null
    aggregated_decision?: $Enums.ReviewDecision | null
    review?: reviewUncheckedCreateNestedManyWithoutPaperInput
  }

  export type paperCreateOrConnectWithoutReviewerassignmentInput = {
    where: paperWhereUniqueInput
    create: XOR<paperCreateWithoutReviewerassignmentInput, paperUncheckedCreateWithoutReviewerassignmentInput>
  }

  export type proposalCreateWithoutReviewerassignmentInput = {
    title?: string | null
    abstract?: string | null
    status?: $Enums.PaperStatus | null
    pdf_path?: string | null
    file_size?: number | null
    created_at?: Date | string
    aggregated_decided_at?: Date | string | null
    aggregated_decision?: $Enums.ReviewDecision | null
    teacher?: teacherCreateNestedOneWithoutProposalInput
    team?: teamCreateNestedOneWithoutProposalInput
    review?: reviewCreateNestedManyWithoutProposalInput
  }

  export type proposalUncheckedCreateWithoutReviewerassignmentInput = {
    proposal_id?: number
    title?: string | null
    abstract?: string | null
    status?: $Enums.PaperStatus | null
    team_id?: number | null
    submitted_by?: number | null
    pdf_path?: string | null
    file_size?: number | null
    created_at?: Date | string
    aggregated_decided_at?: Date | string | null
    aggregated_decision?: $Enums.ReviewDecision | null
    review?: reviewUncheckedCreateNestedManyWithoutProposalInput
  }

  export type proposalCreateOrConnectWithoutReviewerassignmentInput = {
    where: proposalWhereUniqueInput
    create: XOR<proposalCreateWithoutReviewerassignmentInput, proposalUncheckedCreateWithoutReviewerassignmentInput>
  }

  export type reviewerCreateWithoutReviewerassignmentInput = {
    status?: $Enums.ReviewerStatus | null
    review?: reviewCreateNestedManyWithoutReviewerInput
    teacher?: teacherCreateNestedOneWithoutReviewerInput
  }

  export type reviewerUncheckedCreateWithoutReviewerassignmentInput = {
    reviewer_id?: number
    teacher_id?: number | null
    status?: $Enums.ReviewerStatus | null
    review?: reviewUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type reviewerCreateOrConnectWithoutReviewerassignmentInput = {
    where: reviewerWhereUniqueInput
    create: XOR<reviewerCreateWithoutReviewerassignmentInput, reviewerUncheckedCreateWithoutReviewerassignmentInput>
  }

  export type paperUpsertWithoutReviewerassignmentInput = {
    update: XOR<paperUpdateWithoutReviewerassignmentInput, paperUncheckedUpdateWithoutReviewerassignmentInput>
    create: XOR<paperCreateWithoutReviewerassignmentInput, paperUncheckedCreateWithoutReviewerassignmentInput>
    where?: paperWhereInput
  }

  export type paperUpdateToOneWithWhereWithoutReviewerassignmentInput = {
    where?: paperWhereInput
    data: XOR<paperUpdateWithoutReviewerassignmentInput, paperUncheckedUpdateWithoutReviewerassignmentInput>
  }

  export type paperUpdateWithoutReviewerassignmentInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumPaperStatusFieldUpdateOperationsInput | $Enums.PaperStatus | null
    pdf_path?: NullableStringFieldUpdateOperationsInput | string | null
    file_size?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    aggregated_decided_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aggregated_decision?: NullableEnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision | null
    teacher?: teacherUpdateOneWithoutPaperNestedInput
    team?: teamUpdateOneWithoutPaperNestedInput
    review?: reviewUpdateManyWithoutPaperNestedInput
  }

  export type paperUncheckedUpdateWithoutReviewerassignmentInput = {
    paper_id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumPaperStatusFieldUpdateOperationsInput | $Enums.PaperStatus | null
    team_id?: NullableIntFieldUpdateOperationsInput | number | null
    submitted_by?: NullableIntFieldUpdateOperationsInput | number | null
    pdf_path?: NullableStringFieldUpdateOperationsInput | string | null
    file_size?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    aggregated_decided_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aggregated_decision?: NullableEnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision | null
    review?: reviewUncheckedUpdateManyWithoutPaperNestedInput
  }

  export type proposalUpsertWithoutReviewerassignmentInput = {
    update: XOR<proposalUpdateWithoutReviewerassignmentInput, proposalUncheckedUpdateWithoutReviewerassignmentInput>
    create: XOR<proposalCreateWithoutReviewerassignmentInput, proposalUncheckedCreateWithoutReviewerassignmentInput>
    where?: proposalWhereInput
  }

  export type proposalUpdateToOneWithWhereWithoutReviewerassignmentInput = {
    where?: proposalWhereInput
    data: XOR<proposalUpdateWithoutReviewerassignmentInput, proposalUncheckedUpdateWithoutReviewerassignmentInput>
  }

  export type proposalUpdateWithoutReviewerassignmentInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumPaperStatusFieldUpdateOperationsInput | $Enums.PaperStatus | null
    pdf_path?: NullableStringFieldUpdateOperationsInput | string | null
    file_size?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    aggregated_decided_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aggregated_decision?: NullableEnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision | null
    teacher?: teacherUpdateOneWithoutProposalNestedInput
    team?: teamUpdateOneWithoutProposalNestedInput
    review?: reviewUpdateManyWithoutProposalNestedInput
  }

  export type proposalUncheckedUpdateWithoutReviewerassignmentInput = {
    proposal_id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumPaperStatusFieldUpdateOperationsInput | $Enums.PaperStatus | null
    team_id?: NullableIntFieldUpdateOperationsInput | number | null
    submitted_by?: NullableIntFieldUpdateOperationsInput | number | null
    pdf_path?: NullableStringFieldUpdateOperationsInput | string | null
    file_size?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    aggregated_decided_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aggregated_decision?: NullableEnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision | null
    review?: reviewUncheckedUpdateManyWithoutProposalNestedInput
  }

  export type reviewerUpsertWithoutReviewerassignmentInput = {
    update: XOR<reviewerUpdateWithoutReviewerassignmentInput, reviewerUncheckedUpdateWithoutReviewerassignmentInput>
    create: XOR<reviewerCreateWithoutReviewerassignmentInput, reviewerUncheckedCreateWithoutReviewerassignmentInput>
    where?: reviewerWhereInput
  }

  export type reviewerUpdateToOneWithWhereWithoutReviewerassignmentInput = {
    where?: reviewerWhereInput
    data: XOR<reviewerUpdateWithoutReviewerassignmentInput, reviewerUncheckedUpdateWithoutReviewerassignmentInput>
  }

  export type reviewerUpdateWithoutReviewerassignmentInput = {
    status?: NullableEnumReviewerStatusFieldUpdateOperationsInput | $Enums.ReviewerStatus | null
    review?: reviewUpdateManyWithoutReviewerNestedInput
    teacher?: teacherUpdateOneWithoutReviewerNestedInput
  }

  export type reviewerUncheckedUpdateWithoutReviewerassignmentInput = {
    reviewer_id?: IntFieldUpdateOperationsInput | number
    teacher_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumReviewerStatusFieldUpdateOperationsInput | $Enums.ReviewerStatus | null
    review?: reviewUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type domainCreateWithoutUserdomainInput = {
    domain_name?: string | null
    departmentdomain?: departmentdomainCreateNestedManyWithoutDomainInput
    team?: teamCreateNestedManyWithoutDomainInput
  }

  export type domainUncheckedCreateWithoutUserdomainInput = {
    domain_id?: number
    domain_name?: string | null
    departmentdomain?: departmentdomainUncheckedCreateNestedManyWithoutDomainInput
    team?: teamUncheckedCreateNestedManyWithoutDomainInput
  }

  export type domainCreateOrConnectWithoutUserdomainInput = {
    where: domainWhereUniqueInput
    create: XOR<domainCreateWithoutUserdomainInput, domainUncheckedCreateWithoutUserdomainInput>
  }

  export type userCreateWithoutUserdomainInput = {
    name?: string | null
    email?: string | null
    password?: string | null
    profile_image?: string | null
    role?: $Enums.Role | null
    isVerified?: boolean
    isMainAdmin?: boolean
    verifyToken?: string | null
    created_at?: Date | string
    admin?: adminCreateNestedManyWithoutUserInput
    generaluser?: generaluserCreateNestedManyWithoutUserInput
    student?: studentCreateNestedManyWithoutUserInput
    teacher?: teacherCreateNestedManyWithoutUserInput
    team?: teamCreateNestedManyWithoutCreated_by_userInput
    teamcomment?: teamcommentCreateNestedManyWithoutUserInput
    teammember?: teammemberCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutUserdomainInput = {
    user_id?: number
    name?: string | null
    email?: string | null
    password?: string | null
    profile_image?: string | null
    role?: $Enums.Role | null
    isVerified?: boolean
    isMainAdmin?: boolean
    verifyToken?: string | null
    created_at?: Date | string
    admin?: adminUncheckedCreateNestedManyWithoutUserInput
    generaluser?: generaluserUncheckedCreateNestedManyWithoutUserInput
    student?: studentUncheckedCreateNestedManyWithoutUserInput
    teacher?: teacherUncheckedCreateNestedManyWithoutUserInput
    team?: teamUncheckedCreateNestedManyWithoutCreated_by_userInput
    teamcomment?: teamcommentUncheckedCreateNestedManyWithoutUserInput
    teammember?: teammemberUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutUserdomainInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUserdomainInput, userUncheckedCreateWithoutUserdomainInput>
  }

  export type domainUpsertWithoutUserdomainInput = {
    update: XOR<domainUpdateWithoutUserdomainInput, domainUncheckedUpdateWithoutUserdomainInput>
    create: XOR<domainCreateWithoutUserdomainInput, domainUncheckedCreateWithoutUserdomainInput>
    where?: domainWhereInput
  }

  export type domainUpdateToOneWithWhereWithoutUserdomainInput = {
    where?: domainWhereInput
    data: XOR<domainUpdateWithoutUserdomainInput, domainUncheckedUpdateWithoutUserdomainInput>
  }

  export type domainUpdateWithoutUserdomainInput = {
    domain_name?: NullableStringFieldUpdateOperationsInput | string | null
    departmentdomain?: departmentdomainUpdateManyWithoutDomainNestedInput
    team?: teamUpdateManyWithoutDomainNestedInput
  }

  export type domainUncheckedUpdateWithoutUserdomainInput = {
    domain_id?: IntFieldUpdateOperationsInput | number
    domain_name?: NullableStringFieldUpdateOperationsInput | string | null
    departmentdomain?: departmentdomainUncheckedUpdateManyWithoutDomainNestedInput
    team?: teamUncheckedUpdateManyWithoutDomainNestedInput
  }

  export type userUpsertWithoutUserdomainInput = {
    update: XOR<userUpdateWithoutUserdomainInput, userUncheckedUpdateWithoutUserdomainInput>
    create: XOR<userCreateWithoutUserdomainInput, userUncheckedCreateWithoutUserdomainInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutUserdomainInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutUserdomainInput, userUncheckedUpdateWithoutUserdomainInput>
  }

  export type userUpdateWithoutUserdomainInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isMainAdmin?: BoolFieldUpdateOperationsInput | boolean
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: adminUpdateManyWithoutUserNestedInput
    generaluser?: generaluserUpdateManyWithoutUserNestedInput
    student?: studentUpdateManyWithoutUserNestedInput
    teacher?: teacherUpdateManyWithoutUserNestedInput
    team?: teamUpdateManyWithoutCreated_by_userNestedInput
    teamcomment?: teamcommentUpdateManyWithoutUserNestedInput
    teammember?: teammemberUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutUserdomainInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isMainAdmin?: BoolFieldUpdateOperationsInput | boolean
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: adminUncheckedUpdateManyWithoutUserNestedInput
    generaluser?: generaluserUncheckedUpdateManyWithoutUserNestedInput
    student?: studentUncheckedUpdateManyWithoutUserNestedInput
    teacher?: teacherUncheckedUpdateManyWithoutUserNestedInput
    team?: teamUncheckedUpdateManyWithoutCreated_by_userNestedInput
    teamcomment?: teamcommentUncheckedUpdateManyWithoutUserNestedInput
    teammember?: teammemberUncheckedUpdateManyWithoutUserNestedInput
  }

  export type adminCreateManyUserInput = {
    admin_id?: number
  }

  export type generaluserCreateManyUserInput = {
    generaluser_id?: number
  }

  export type studentCreateManyUserInput = {
    student_id?: number
    roll_number?: string | null
    department_id?: number | null
  }

  export type teacherCreateManyUserInput = {
    teacher_id?: number
    designation?: string | null
    department_id?: number | null
    isReviewer?: boolean
  }

  export type teamCreateManyCreated_by_userInput = {
    team_id?: number
    team_name?: string | null
    team_description?: string | null
    domain_id?: number | null
    status?: $Enums.TeamStatus | null
    visibility?: $Enums.TeamVisibility | null
    max_members?: number | null
    isHiring?: boolean | null
    created_at?: Date | string
  }

  export type teamcommentCreateManyUserInput = {
    comment_id?: number
    team_id: number
    comment: string
    created_at?: Date | string
  }

  export type teammemberCreateManyUserInput = {
    team_id: number
    role_in_team?: $Enums.TeamRole | null
  }

  export type userdomainCreateManyUserInput = {
    domain_id: number
  }

  export type adminUpdateWithoutUserInput = {

  }

  export type adminUncheckedUpdateWithoutUserInput = {
    admin_id?: IntFieldUpdateOperationsInput | number
  }

  export type adminUncheckedUpdateManyWithoutUserInput = {
    admin_id?: IntFieldUpdateOperationsInput | number
  }

  export type generaluserUpdateWithoutUserInput = {

  }

  export type generaluserUncheckedUpdateWithoutUserInput = {
    generaluser_id?: IntFieldUpdateOperationsInput | number
  }

  export type generaluserUncheckedUpdateManyWithoutUserInput = {
    generaluser_id?: IntFieldUpdateOperationsInput | number
  }

  export type studentUpdateWithoutUserInput = {
    roll_number?: NullableStringFieldUpdateOperationsInput | string | null
    department?: departmentUpdateOneWithoutStudentsNestedInput
    teamapplication?: teamapplicationUpdateManyWithoutStudentNestedInput
  }

  export type studentUncheckedUpdateWithoutUserInput = {
    student_id?: IntFieldUpdateOperationsInput | number
    roll_number?: NullableStringFieldUpdateOperationsInput | string | null
    department_id?: NullableIntFieldUpdateOperationsInput | number | null
    teamapplication?: teamapplicationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type studentUncheckedUpdateManyWithoutUserInput = {
    student_id?: IntFieldUpdateOperationsInput | number
    roll_number?: NullableStringFieldUpdateOperationsInput | string | null
    department_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type teacherUpdateWithoutUserInput = {
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    isReviewer?: BoolFieldUpdateOperationsInput | boolean
    paper?: paperUpdateManyWithoutTeacherNestedInput
    proposal?: proposalUpdateManyWithoutTeacherNestedInput
    reviewer?: reviewerUpdateOneWithoutTeacherNestedInput
    department?: departmentUpdateOneWithoutTeachersNestedInput
  }

  export type teacherUncheckedUpdateWithoutUserInput = {
    teacher_id?: IntFieldUpdateOperationsInput | number
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    department_id?: NullableIntFieldUpdateOperationsInput | number | null
    isReviewer?: BoolFieldUpdateOperationsInput | boolean
    paper?: paperUncheckedUpdateManyWithoutTeacherNestedInput
    proposal?: proposalUncheckedUpdateManyWithoutTeacherNestedInput
    reviewer?: reviewerUncheckedUpdateOneWithoutTeacherNestedInput
  }

  export type teacherUncheckedUpdateManyWithoutUserInput = {
    teacher_id?: IntFieldUpdateOperationsInput | number
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    department_id?: NullableIntFieldUpdateOperationsInput | number | null
    isReviewer?: BoolFieldUpdateOperationsInput | boolean
  }

  export type teamUpdateWithoutCreated_by_userInput = {
    team_name?: NullableStringFieldUpdateOperationsInput | string | null
    team_description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumTeamStatusFieldUpdateOperationsInput | $Enums.TeamStatus | null
    visibility?: NullableEnumTeamVisibilityFieldUpdateOperationsInput | $Enums.TeamVisibility | null
    max_members?: NullableIntFieldUpdateOperationsInput | number | null
    isHiring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    paper?: paperUpdateManyWithoutTeamNestedInput
    proposal?: proposalUpdateManyWithoutTeamNestedInput
    domain?: domainUpdateOneWithoutTeamNestedInput
    teamapplication?: teamapplicationUpdateManyWithoutTeamNestedInput
    teamcomment?: teamcommentUpdateManyWithoutTeamNestedInput
    teammember?: teammemberUpdateManyWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateWithoutCreated_by_userInput = {
    team_id?: IntFieldUpdateOperationsInput | number
    team_name?: NullableStringFieldUpdateOperationsInput | string | null
    team_description?: NullableStringFieldUpdateOperationsInput | string | null
    domain_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumTeamStatusFieldUpdateOperationsInput | $Enums.TeamStatus | null
    visibility?: NullableEnumTeamVisibilityFieldUpdateOperationsInput | $Enums.TeamVisibility | null
    max_members?: NullableIntFieldUpdateOperationsInput | number | null
    isHiring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    paper?: paperUncheckedUpdateManyWithoutTeamNestedInput
    proposal?: proposalUncheckedUpdateManyWithoutTeamNestedInput
    teamapplication?: teamapplicationUncheckedUpdateManyWithoutTeamNestedInput
    teamcomment?: teamcommentUncheckedUpdateManyWithoutTeamNestedInput
    teammember?: teammemberUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateManyWithoutCreated_by_userInput = {
    team_id?: IntFieldUpdateOperationsInput | number
    team_name?: NullableStringFieldUpdateOperationsInput | string | null
    team_description?: NullableStringFieldUpdateOperationsInput | string | null
    domain_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumTeamStatusFieldUpdateOperationsInput | $Enums.TeamStatus | null
    visibility?: NullableEnumTeamVisibilityFieldUpdateOperationsInput | $Enums.TeamVisibility | null
    max_members?: NullableIntFieldUpdateOperationsInput | number | null
    isHiring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type teamcommentUpdateWithoutUserInput = {
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: teamUpdateOneRequiredWithoutTeamcommentNestedInput
  }

  export type teamcommentUncheckedUpdateWithoutUserInput = {
    comment_id?: IntFieldUpdateOperationsInput | number
    team_id?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type teamcommentUncheckedUpdateManyWithoutUserInput = {
    comment_id?: IntFieldUpdateOperationsInput | number
    team_id?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type teammemberUpdateWithoutUserInput = {
    role_in_team?: NullableEnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole | null
    team?: teamUpdateOneRequiredWithoutTeammemberNestedInput
  }

  export type teammemberUncheckedUpdateWithoutUserInput = {
    team_id?: IntFieldUpdateOperationsInput | number
    role_in_team?: NullableEnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole | null
  }

  export type teammemberUncheckedUpdateManyWithoutUserInput = {
    team_id?: IntFieldUpdateOperationsInput | number
    role_in_team?: NullableEnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole | null
  }

  export type userdomainUpdateWithoutUserInput = {
    domain?: domainUpdateOneRequiredWithoutUserdomainNestedInput
  }

  export type userdomainUncheckedUpdateWithoutUserInput = {
    domain_id?: IntFieldUpdateOperationsInput | number
  }

  export type userdomainUncheckedUpdateManyWithoutUserInput = {
    domain_id?: IntFieldUpdateOperationsInput | number
  }

  export type departmentdomainCreateManyDepartmentInput = {
    domain_id: number
  }

  export type studentCreateManyDepartmentInput = {
    student_id?: number
    roll_number?: string | null
    user_id?: number | null
  }

  export type teacherCreateManyDepartmentInput = {
    teacher_id?: number
    designation?: string | null
    user_id?: number | null
    isReviewer?: boolean
  }

  export type departmentdomainUpdateWithoutDepartmentInput = {
    domain?: domainUpdateOneRequiredWithoutDepartmentdomainNestedInput
  }

  export type departmentdomainUncheckedUpdateWithoutDepartmentInput = {
    domain_id?: IntFieldUpdateOperationsInput | number
  }

  export type departmentdomainUncheckedUpdateManyWithoutDepartmentInput = {
    domain_id?: IntFieldUpdateOperationsInput | number
  }

  export type studentUpdateWithoutDepartmentInput = {
    roll_number?: NullableStringFieldUpdateOperationsInput | string | null
    user?: userUpdateOneWithoutStudentNestedInput
    teamapplication?: teamapplicationUpdateManyWithoutStudentNestedInput
  }

  export type studentUncheckedUpdateWithoutDepartmentInput = {
    student_id?: IntFieldUpdateOperationsInput | number
    roll_number?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    teamapplication?: teamapplicationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type studentUncheckedUpdateManyWithoutDepartmentInput = {
    student_id?: IntFieldUpdateOperationsInput | number
    roll_number?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type teacherUpdateWithoutDepartmentInput = {
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    isReviewer?: BoolFieldUpdateOperationsInput | boolean
    paper?: paperUpdateManyWithoutTeacherNestedInput
    proposal?: proposalUpdateManyWithoutTeacherNestedInput
    reviewer?: reviewerUpdateOneWithoutTeacherNestedInput
    user?: userUpdateOneWithoutTeacherNestedInput
  }

  export type teacherUncheckedUpdateWithoutDepartmentInput = {
    teacher_id?: IntFieldUpdateOperationsInput | number
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    isReviewer?: BoolFieldUpdateOperationsInput | boolean
    paper?: paperUncheckedUpdateManyWithoutTeacherNestedInput
    proposal?: proposalUncheckedUpdateManyWithoutTeacherNestedInput
    reviewer?: reviewerUncheckedUpdateOneWithoutTeacherNestedInput
  }

  export type teacherUncheckedUpdateManyWithoutDepartmentInput = {
    teacher_id?: IntFieldUpdateOperationsInput | number
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    isReviewer?: BoolFieldUpdateOperationsInput | boolean
  }

  export type departmentdomainCreateManyDomainInput = {
    department_id: number
  }

  export type teamCreateManyDomainInput = {
    team_id?: number
    team_name?: string | null
    team_description?: string | null
    status?: $Enums.TeamStatus | null
    visibility?: $Enums.TeamVisibility | null
    max_members?: number | null
    isHiring?: boolean | null
    created_at?: Date | string
    created_by_user_id?: number | null
  }

  export type userdomainCreateManyDomainInput = {
    user_id: number
  }

  export type departmentdomainUpdateWithoutDomainInput = {
    department?: departmentUpdateOneRequiredWithoutDepartmentdomainNestedInput
  }

  export type departmentdomainUncheckedUpdateWithoutDomainInput = {
    department_id?: IntFieldUpdateOperationsInput | number
  }

  export type departmentdomainUncheckedUpdateManyWithoutDomainInput = {
    department_id?: IntFieldUpdateOperationsInput | number
  }

  export type teamUpdateWithoutDomainInput = {
    team_name?: NullableStringFieldUpdateOperationsInput | string | null
    team_description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumTeamStatusFieldUpdateOperationsInput | $Enums.TeamStatus | null
    visibility?: NullableEnumTeamVisibilityFieldUpdateOperationsInput | $Enums.TeamVisibility | null
    max_members?: NullableIntFieldUpdateOperationsInput | number | null
    isHiring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    paper?: paperUpdateManyWithoutTeamNestedInput
    proposal?: proposalUpdateManyWithoutTeamNestedInput
    created_by_user?: userUpdateOneWithoutTeamNestedInput
    teamapplication?: teamapplicationUpdateManyWithoutTeamNestedInput
    teamcomment?: teamcommentUpdateManyWithoutTeamNestedInput
    teammember?: teammemberUpdateManyWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateWithoutDomainInput = {
    team_id?: IntFieldUpdateOperationsInput | number
    team_name?: NullableStringFieldUpdateOperationsInput | string | null
    team_description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumTeamStatusFieldUpdateOperationsInput | $Enums.TeamStatus | null
    visibility?: NullableEnumTeamVisibilityFieldUpdateOperationsInput | $Enums.TeamVisibility | null
    max_members?: NullableIntFieldUpdateOperationsInput | number | null
    isHiring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    paper?: paperUncheckedUpdateManyWithoutTeamNestedInput
    proposal?: proposalUncheckedUpdateManyWithoutTeamNestedInput
    teamapplication?: teamapplicationUncheckedUpdateManyWithoutTeamNestedInput
    teamcomment?: teamcommentUncheckedUpdateManyWithoutTeamNestedInput
    teammember?: teammemberUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateManyWithoutDomainInput = {
    team_id?: IntFieldUpdateOperationsInput | number
    team_name?: NullableStringFieldUpdateOperationsInput | string | null
    team_description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumTeamStatusFieldUpdateOperationsInput | $Enums.TeamStatus | null
    visibility?: NullableEnumTeamVisibilityFieldUpdateOperationsInput | $Enums.TeamVisibility | null
    max_members?: NullableIntFieldUpdateOperationsInput | number | null
    isHiring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by_user_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type userdomainUpdateWithoutDomainInput = {
    user?: userUpdateOneRequiredWithoutUserdomainNestedInput
  }

  export type userdomainUncheckedUpdateWithoutDomainInput = {
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type userdomainUncheckedUpdateManyWithoutDomainInput = {
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type teamapplicationCreateManyStudentInput = {
    application_id?: number
    team_id: number
    status?: $Enums.ApplicationStatus
    applied_at?: Date | string
  }

  export type teamapplicationUpdateWithoutStudentInput = {
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    applied_at?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: teamUpdateOneRequiredWithoutTeamapplicationNestedInput
  }

  export type teamapplicationUncheckedUpdateWithoutStudentInput = {
    application_id?: IntFieldUpdateOperationsInput | number
    team_id?: IntFieldUpdateOperationsInput | number
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    applied_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type teamapplicationUncheckedUpdateManyWithoutStudentInput = {
    application_id?: IntFieldUpdateOperationsInput | number
    team_id?: IntFieldUpdateOperationsInput | number
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    applied_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paperCreateManyTeacherInput = {
    paper_id?: number
    title?: string | null
    abstract?: string | null
    status?: $Enums.PaperStatus | null
    team_id?: number | null
    pdf_path?: string | null
    file_size?: number | null
    created_at?: Date | string
    aggregated_decided_at?: Date | string | null
    aggregated_decision?: $Enums.ReviewDecision | null
  }

  export type proposalCreateManyTeacherInput = {
    proposal_id?: number
    title?: string | null
    abstract?: string | null
    status?: $Enums.PaperStatus | null
    team_id?: number | null
    pdf_path?: string | null
    file_size?: number | null
    created_at?: Date | string
    aggregated_decided_at?: Date | string | null
    aggregated_decision?: $Enums.ReviewDecision | null
  }

  export type paperUpdateWithoutTeacherInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumPaperStatusFieldUpdateOperationsInput | $Enums.PaperStatus | null
    pdf_path?: NullableStringFieldUpdateOperationsInput | string | null
    file_size?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    aggregated_decided_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aggregated_decision?: NullableEnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision | null
    team?: teamUpdateOneWithoutPaperNestedInput
    review?: reviewUpdateManyWithoutPaperNestedInput
    reviewerassignment?: reviewerassignmentUpdateManyWithoutPaperNestedInput
  }

  export type paperUncheckedUpdateWithoutTeacherInput = {
    paper_id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumPaperStatusFieldUpdateOperationsInput | $Enums.PaperStatus | null
    team_id?: NullableIntFieldUpdateOperationsInput | number | null
    pdf_path?: NullableStringFieldUpdateOperationsInput | string | null
    file_size?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    aggregated_decided_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aggregated_decision?: NullableEnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision | null
    review?: reviewUncheckedUpdateManyWithoutPaperNestedInput
    reviewerassignment?: reviewerassignmentUncheckedUpdateManyWithoutPaperNestedInput
  }

  export type paperUncheckedUpdateManyWithoutTeacherInput = {
    paper_id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumPaperStatusFieldUpdateOperationsInput | $Enums.PaperStatus | null
    team_id?: NullableIntFieldUpdateOperationsInput | number | null
    pdf_path?: NullableStringFieldUpdateOperationsInput | string | null
    file_size?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    aggregated_decided_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aggregated_decision?: NullableEnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision | null
  }

  export type proposalUpdateWithoutTeacherInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumPaperStatusFieldUpdateOperationsInput | $Enums.PaperStatus | null
    pdf_path?: NullableStringFieldUpdateOperationsInput | string | null
    file_size?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    aggregated_decided_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aggregated_decision?: NullableEnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision | null
    team?: teamUpdateOneWithoutProposalNestedInput
    review?: reviewUpdateManyWithoutProposalNestedInput
    reviewerassignment?: reviewerassignmentUpdateManyWithoutProposalNestedInput
  }

  export type proposalUncheckedUpdateWithoutTeacherInput = {
    proposal_id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumPaperStatusFieldUpdateOperationsInput | $Enums.PaperStatus | null
    team_id?: NullableIntFieldUpdateOperationsInput | number | null
    pdf_path?: NullableStringFieldUpdateOperationsInput | string | null
    file_size?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    aggregated_decided_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aggregated_decision?: NullableEnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision | null
    review?: reviewUncheckedUpdateManyWithoutProposalNestedInput
    reviewerassignment?: reviewerassignmentUncheckedUpdateManyWithoutProposalNestedInput
  }

  export type proposalUncheckedUpdateManyWithoutTeacherInput = {
    proposal_id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumPaperStatusFieldUpdateOperationsInput | $Enums.PaperStatus | null
    team_id?: NullableIntFieldUpdateOperationsInput | number | null
    pdf_path?: NullableStringFieldUpdateOperationsInput | string | null
    file_size?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    aggregated_decided_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aggregated_decision?: NullableEnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision | null
  }

  export type reviewCreateManyReviewerInput = {
    review_id?: number
    proposal_id?: number | null
    paper_id?: number | null
    comments?: string | null
    score?: number | null
    reviewed_at?: Date | string
    attachment_path?: string | null
    decision?: $Enums.ReviewDecision | null
  }

  export type reviewerassignmentCreateManyReviewerInput = {
    assignment_id?: number
    proposal_id?: number | null
    paper_id?: number | null
    assigned_date?: Date | string
    due_date: Date | string
    status?: $Enums.AssignmentStatus
    completed_at?: Date | string | null
    started_at?: Date | string | null
  }

  export type reviewUpdateWithoutReviewerInput = {
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    reviewed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    attachment_path?: NullableStringFieldUpdateOperationsInput | string | null
    decision?: NullableEnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision | null
    paper?: paperUpdateOneWithoutReviewNestedInput
    proposal?: proposalUpdateOneWithoutReviewNestedInput
  }

  export type reviewUncheckedUpdateWithoutReviewerInput = {
    review_id?: IntFieldUpdateOperationsInput | number
    proposal_id?: NullableIntFieldUpdateOperationsInput | number | null
    paper_id?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    reviewed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    attachment_path?: NullableStringFieldUpdateOperationsInput | string | null
    decision?: NullableEnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision | null
  }

  export type reviewUncheckedUpdateManyWithoutReviewerInput = {
    review_id?: IntFieldUpdateOperationsInput | number
    proposal_id?: NullableIntFieldUpdateOperationsInput | number | null
    paper_id?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    reviewed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    attachment_path?: NullableStringFieldUpdateOperationsInput | string | null
    decision?: NullableEnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision | null
  }

  export type reviewerassignmentUpdateWithoutReviewerInput = {
    assigned_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paper?: paperUpdateOneWithoutReviewerassignmentNestedInput
    proposal?: proposalUpdateOneWithoutReviewerassignmentNestedInput
  }

  export type reviewerassignmentUncheckedUpdateWithoutReviewerInput = {
    assignment_id?: IntFieldUpdateOperationsInput | number
    proposal_id?: NullableIntFieldUpdateOperationsInput | number | null
    paper_id?: NullableIntFieldUpdateOperationsInput | number | null
    assigned_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reviewerassignmentUncheckedUpdateManyWithoutReviewerInput = {
    assignment_id?: IntFieldUpdateOperationsInput | number
    proposal_id?: NullableIntFieldUpdateOperationsInput | number | null
    paper_id?: NullableIntFieldUpdateOperationsInput | number | null
    assigned_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type paperCreateManyTeamInput = {
    paper_id?: number
    title?: string | null
    abstract?: string | null
    status?: $Enums.PaperStatus | null
    submitted_by?: number | null
    pdf_path?: string | null
    file_size?: number | null
    created_at?: Date | string
    aggregated_decided_at?: Date | string | null
    aggregated_decision?: $Enums.ReviewDecision | null
  }

  export type proposalCreateManyTeamInput = {
    proposal_id?: number
    title?: string | null
    abstract?: string | null
    status?: $Enums.PaperStatus | null
    submitted_by?: number | null
    pdf_path?: string | null
    file_size?: number | null
    created_at?: Date | string
    aggregated_decided_at?: Date | string | null
    aggregated_decision?: $Enums.ReviewDecision | null
  }

  export type teamapplicationCreateManyTeamInput = {
    application_id?: number
    student_id: number
    status?: $Enums.ApplicationStatus
    applied_at?: Date | string
  }

  export type teamcommentCreateManyTeamInput = {
    comment_id?: number
    user_id: number
    comment: string
    created_at?: Date | string
  }

  export type teammemberCreateManyTeamInput = {
    user_id: number
    role_in_team?: $Enums.TeamRole | null
  }

  export type paperUpdateWithoutTeamInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumPaperStatusFieldUpdateOperationsInput | $Enums.PaperStatus | null
    pdf_path?: NullableStringFieldUpdateOperationsInput | string | null
    file_size?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    aggregated_decided_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aggregated_decision?: NullableEnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision | null
    teacher?: teacherUpdateOneWithoutPaperNestedInput
    review?: reviewUpdateManyWithoutPaperNestedInput
    reviewerassignment?: reviewerassignmentUpdateManyWithoutPaperNestedInput
  }

  export type paperUncheckedUpdateWithoutTeamInput = {
    paper_id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumPaperStatusFieldUpdateOperationsInput | $Enums.PaperStatus | null
    submitted_by?: NullableIntFieldUpdateOperationsInput | number | null
    pdf_path?: NullableStringFieldUpdateOperationsInput | string | null
    file_size?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    aggregated_decided_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aggregated_decision?: NullableEnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision | null
    review?: reviewUncheckedUpdateManyWithoutPaperNestedInput
    reviewerassignment?: reviewerassignmentUncheckedUpdateManyWithoutPaperNestedInput
  }

  export type paperUncheckedUpdateManyWithoutTeamInput = {
    paper_id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumPaperStatusFieldUpdateOperationsInput | $Enums.PaperStatus | null
    submitted_by?: NullableIntFieldUpdateOperationsInput | number | null
    pdf_path?: NullableStringFieldUpdateOperationsInput | string | null
    file_size?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    aggregated_decided_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aggregated_decision?: NullableEnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision | null
  }

  export type proposalUpdateWithoutTeamInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumPaperStatusFieldUpdateOperationsInput | $Enums.PaperStatus | null
    pdf_path?: NullableStringFieldUpdateOperationsInput | string | null
    file_size?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    aggregated_decided_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aggregated_decision?: NullableEnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision | null
    teacher?: teacherUpdateOneWithoutProposalNestedInput
    review?: reviewUpdateManyWithoutProposalNestedInput
    reviewerassignment?: reviewerassignmentUpdateManyWithoutProposalNestedInput
  }

  export type proposalUncheckedUpdateWithoutTeamInput = {
    proposal_id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumPaperStatusFieldUpdateOperationsInput | $Enums.PaperStatus | null
    submitted_by?: NullableIntFieldUpdateOperationsInput | number | null
    pdf_path?: NullableStringFieldUpdateOperationsInput | string | null
    file_size?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    aggregated_decided_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aggregated_decision?: NullableEnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision | null
    review?: reviewUncheckedUpdateManyWithoutProposalNestedInput
    reviewerassignment?: reviewerassignmentUncheckedUpdateManyWithoutProposalNestedInput
  }

  export type proposalUncheckedUpdateManyWithoutTeamInput = {
    proposal_id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumPaperStatusFieldUpdateOperationsInput | $Enums.PaperStatus | null
    submitted_by?: NullableIntFieldUpdateOperationsInput | number | null
    pdf_path?: NullableStringFieldUpdateOperationsInput | string | null
    file_size?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    aggregated_decided_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aggregated_decision?: NullableEnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision | null
  }

  export type teamapplicationUpdateWithoutTeamInput = {
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    applied_at?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: studentUpdateOneRequiredWithoutTeamapplicationNestedInput
  }

  export type teamapplicationUncheckedUpdateWithoutTeamInput = {
    application_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    applied_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type teamapplicationUncheckedUpdateManyWithoutTeamInput = {
    application_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    applied_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type teamcommentUpdateWithoutTeamInput = {
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutTeamcommentNestedInput
  }

  export type teamcommentUncheckedUpdateWithoutTeamInput = {
    comment_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type teamcommentUncheckedUpdateManyWithoutTeamInput = {
    comment_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type teammemberUpdateWithoutTeamInput = {
    role_in_team?: NullableEnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole | null
    user?: userUpdateOneRequiredWithoutTeammemberNestedInput
  }

  export type teammemberUncheckedUpdateWithoutTeamInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    role_in_team?: NullableEnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole | null
  }

  export type teammemberUncheckedUpdateManyWithoutTeamInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    role_in_team?: NullableEnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole | null
  }

  export type reviewCreateManyPaperInput = {
    review_id?: number
    reviewer_id?: number | null
    proposal_id?: number | null
    comments?: string | null
    score?: number | null
    reviewed_at?: Date | string
    attachment_path?: string | null
    decision?: $Enums.ReviewDecision | null
  }

  export type reviewerassignmentCreateManyPaperInput = {
    assignment_id?: number
    reviewer_id: number
    proposal_id?: number | null
    assigned_date?: Date | string
    due_date: Date | string
    status?: $Enums.AssignmentStatus
    completed_at?: Date | string | null
    started_at?: Date | string | null
  }

  export type reviewUpdateWithoutPaperInput = {
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    reviewed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    attachment_path?: NullableStringFieldUpdateOperationsInput | string | null
    decision?: NullableEnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision | null
    proposal?: proposalUpdateOneWithoutReviewNestedInput
    reviewer?: reviewerUpdateOneWithoutReviewNestedInput
  }

  export type reviewUncheckedUpdateWithoutPaperInput = {
    review_id?: IntFieldUpdateOperationsInput | number
    reviewer_id?: NullableIntFieldUpdateOperationsInput | number | null
    proposal_id?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    reviewed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    attachment_path?: NullableStringFieldUpdateOperationsInput | string | null
    decision?: NullableEnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision | null
  }

  export type reviewUncheckedUpdateManyWithoutPaperInput = {
    review_id?: IntFieldUpdateOperationsInput | number
    reviewer_id?: NullableIntFieldUpdateOperationsInput | number | null
    proposal_id?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    reviewed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    attachment_path?: NullableStringFieldUpdateOperationsInput | string | null
    decision?: NullableEnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision | null
  }

  export type reviewerassignmentUpdateWithoutPaperInput = {
    assigned_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    proposal?: proposalUpdateOneWithoutReviewerassignmentNestedInput
    reviewer?: reviewerUpdateOneRequiredWithoutReviewerassignmentNestedInput
  }

  export type reviewerassignmentUncheckedUpdateWithoutPaperInput = {
    assignment_id?: IntFieldUpdateOperationsInput | number
    reviewer_id?: IntFieldUpdateOperationsInput | number
    proposal_id?: NullableIntFieldUpdateOperationsInput | number | null
    assigned_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reviewerassignmentUncheckedUpdateManyWithoutPaperInput = {
    assignment_id?: IntFieldUpdateOperationsInput | number
    reviewer_id?: IntFieldUpdateOperationsInput | number
    proposal_id?: NullableIntFieldUpdateOperationsInput | number | null
    assigned_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reviewCreateManyProposalInput = {
    review_id?: number
    reviewer_id?: number | null
    paper_id?: number | null
    comments?: string | null
    score?: number | null
    reviewed_at?: Date | string
    attachment_path?: string | null
    decision?: $Enums.ReviewDecision | null
  }

  export type reviewerassignmentCreateManyProposalInput = {
    assignment_id?: number
    reviewer_id: number
    paper_id?: number | null
    assigned_date?: Date | string
    due_date: Date | string
    status?: $Enums.AssignmentStatus
    completed_at?: Date | string | null
    started_at?: Date | string | null
  }

  export type reviewUpdateWithoutProposalInput = {
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    reviewed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    attachment_path?: NullableStringFieldUpdateOperationsInput | string | null
    decision?: NullableEnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision | null
    paper?: paperUpdateOneWithoutReviewNestedInput
    reviewer?: reviewerUpdateOneWithoutReviewNestedInput
  }

  export type reviewUncheckedUpdateWithoutProposalInput = {
    review_id?: IntFieldUpdateOperationsInput | number
    reviewer_id?: NullableIntFieldUpdateOperationsInput | number | null
    paper_id?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    reviewed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    attachment_path?: NullableStringFieldUpdateOperationsInput | string | null
    decision?: NullableEnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision | null
  }

  export type reviewUncheckedUpdateManyWithoutProposalInput = {
    review_id?: IntFieldUpdateOperationsInput | number
    reviewer_id?: NullableIntFieldUpdateOperationsInput | number | null
    paper_id?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    reviewed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    attachment_path?: NullableStringFieldUpdateOperationsInput | string | null
    decision?: NullableEnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision | null
  }

  export type reviewerassignmentUpdateWithoutProposalInput = {
    assigned_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paper?: paperUpdateOneWithoutReviewerassignmentNestedInput
    reviewer?: reviewerUpdateOneRequiredWithoutReviewerassignmentNestedInput
  }

  export type reviewerassignmentUncheckedUpdateWithoutProposalInput = {
    assignment_id?: IntFieldUpdateOperationsInput | number
    reviewer_id?: IntFieldUpdateOperationsInput | number
    paper_id?: NullableIntFieldUpdateOperationsInput | number | null
    assigned_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reviewerassignmentUncheckedUpdateManyWithoutProposalInput = {
    assignment_id?: IntFieldUpdateOperationsInput | number
    reviewer_id?: IntFieldUpdateOperationsInput | number
    paper_id?: NullableIntFieldUpdateOperationsInput | number | null
    assigned_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}